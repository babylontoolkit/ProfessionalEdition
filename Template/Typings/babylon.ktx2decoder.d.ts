
declare module KTX2DECODER {


    /**     * Resources used for the implementation:     *  - 3js KTX2 loader: https://github.com/mrdoob/three.js/blob/dfb5c23ce126ec845e4aa240599915fef5375797/examples/jsm/loaders/KTX2Loader.js     *  - Universal Texture Transcoders: https://github.com/KhronosGroup/Universal-Texture-Transcoders     *  - KTX2 specification: http://github.khronos.org/KTX-Specification/     *  - KTX2 binaries to convert files: https://github.com/KhronosGroup/KTX-Software/releases     *  - KTX specification: https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html     *  - KTX-Software: https://github.com/KhronosGroup/KTX-Software     */    export interface IDecodedData {        width: number;        height: number;        transcodedFormat: number;        mipmaps: Array<IMipmap>;        isInGammaSpace: boolean;        hasAlpha: boolean;        errors?: string;        transcoderName?: string;    }    export interface IMipmap {        data: Uint8Array | null;        width: number;        height: number;    }    export interface ICompressedFormatCapabilities {        astc?: boolean;        bptc?: boolean;        s3tc?: boolean;        pvrtc?: boolean;        etc2?: boolean;        etc1?: boolean;    }    export interface IKTX2DecoderOptions {        /** use RGBA format if ASTC and BC7 are not available as transcoded format */        useRGBAIfASTCBC7NotAvailableWhenUASTC?: boolean;        /** force to always use RGBA for transcoded format */        forceRGBA?: boolean;        /**         * list of transcoders to bypass when looking for a suitable transcoder. The available transcoders are:         *      UniversalTranscoder_UASTC_ASTC         *      UniversalTranscoder_UASTC_BC7         *      UniversalTranscoder_UASTC_RGBA_UNORM         *      UniversalTranscoder_UASTC_RGBA_SRGB         *      MSCTranscoder         */        bypassTranscoders?: string[];    }    /**     * Class for decoding KTX2 files     *     */    export class KTX2Decoder {        private _transcoderMgr;        private _zstdDecoder;        constructor();        decode(data: Uint8Array, caps: ICompressedFormatCapabilities, options?: IKTX2DecoderOptions): Promise<IDecodedData | null>;        private _decodeData;    }

    /** @hidden */    export enum SupercompressionScheme {        None = 0,        BasisLZ = 1,        ZStandard = 2,        ZLib = 3    }    /** @hidden */    export interface IKTX2_Header {        vkFormat: number;        typeSize: number;        pixelWidth: number;        pixelHeight: number;        pixelDepth: number;        layerCount: number;        faceCount: number;        levelCount: number;        supercompressionScheme: number;        dfdByteOffset: number;        dfdByteLength: number;        kvdByteOffset: number;        kvdByteLength: number;        sgdByteOffset: number;        sgdByteLength: number;    }    /** @hidden */    export interface IKTX2_Level {        byteOffset: number;        byteLength: number;        uncompressedByteLength: number;    }    interface IKTX2_Sample {        bitOffset: number;        bitLength: number;        channelType: number;        channelFlags: number;        samplePosition: number[];        sampleLower: number;        sampleUpper: number;    }    /** @hidden */    export interface IKTX2_DFD {        vendorId: number;        descriptorType: number;        versionNumber: number;        descriptorBlockSize: number;        colorModel: number;        colorPrimaries: number;        transferFunction: number;        flags: number;        texelBlockDimension: {            x: number;            y: number;            z: number;            w: number;        };        bytesPlane: Array<number>;        numSamples: number;        samples: Array<IKTX2_Sample>;    }    /** @hidden */    export interface IKTX2_ImageDesc {        imageFlags: number;        rgbSliceByteOffset: number;        rgbSliceByteLength: number;        alphaSliceByteOffset: number;        alphaSliceByteLength: number;    }    /** @hidden */    export interface IKTX2_SupercompressionGlobalData {        endpointCount?: number;        selectorCount?: number;        endpointsByteLength?: number;        selectorsByteLength?: number;        tablesByteLength?: number;        extendedByteLength?: number;        imageDescs?: Array<IKTX2_ImageDesc>;        endpointsData?: Uint8Array;        selectorsData?: Uint8Array;        tablesData?: Uint8Array;        extendedData?: Uint8Array;    }    export class KTX2FileReader {        private _data;        private _header;        private _levels;        private _dfdBlock;        private _supercompressionGlobalData;        /**         * Will throw an exception if the file can't be parsed         * @param data         */        constructor(data: Uint8Array);        get data(): Uint8Array;        get header(): IKTX2_Header;        get levels(): Array<IKTX2_Level>;        get dfdBlock(): IKTX2_DFD;        get supercompressionGlobalData(): IKTX2_SupercompressionGlobalData;        isValid(): boolean;        parse(): void;        private _getImageCount;        get textureFormat(): sourceTextureFormat;        get hasAlpha(): boolean;        get needZSTDDecoder(): boolean;        get isInGammaSpace(): boolean;        static IsValid(data: ArrayBufferView): boolean;    }

    /**     * Utility class for reading from a data buffer     */    export class DataReader {        /**         * The current byte offset from the beginning of the data buffer.         */        get byteOffset(): number;        private _dataView;        private _dataByteOffset;        /**         * Constructor         * @param buffer The buffer to set         * @param byteOffset The starting offset in the buffer         * @param byteLength The byte length of the buffer         */        constructor(buffer: ArrayBuffer | ArrayBufferView, byteOffset?: number, byteLength?: number);        /**         * Read a unsigned 8-bit integer from the currently loaded data range.         * @returns The 8-bit integer read         */        readUint8(): number;        /**         * Read a signed 8-bit integer from the currently loaded data range.         * @returns The 8-bit integer read         */        readInt8(): number;        /**         * Read a unsigned 16-bit integer from the currently loaded data range.         * @returns The 16-bit integer read         */        readUint16(): number;        /**         * Read a signed 16-bit integer from the currently loaded data range.         * @returns The 16-bit integer read         */        readInt16(): number;        /**         * Read a unsigned 32-bit integer from the currently loaded data range.         * @returns The 32-bit integer read         */        readUint32(): number;        /**         * Read a signed 32-bit integer from the currently loaded data range.         * @returns The 32-bit integer read         */        readInt32(): number;        /**         * Read a unsigned 32-bit integer from the currently loaded data range.         * @returns The 32-bit integer read         */        readUint64(): number;        /**         * Read a byte array from the currently loaded data range.         * @param byteLength The byte length to read         * @returns The byte array read         */        readUint8Array(byteLength: number): Uint8Array;        /**         * Skips the given byte length the currently loaded data range.         * @param byteLength The byte length to skip         * @returns This instance         */        skipBytes(byteLength: number): this;    }



    export class TranscodeDecisionTree {        private static _IsLeafNode;        private _hasAlpha;        private _isPowerOfTwo;        private _caps;        private _options;        private _transcodeFormat;        private _engineFormat;        private _roundToMultiple4;        get transcodeFormat(): number;        get engineFormat(): number;        get roundToMultiple4(): boolean;        constructor(textureFormat: sourceTextureFormat, hasAlpha: boolean, isPowerOfTwo: boolean, caps: any, options?: any);        private _parseNode;    }

    /**     * @hidden     */    export enum sourceTextureFormat {        ETC1S = 0,        UASTC4x4 = 1    }    /**     * @hidden     */    export enum transcodeTarget {        ASTC_4x4_RGBA = 0,        BC7_RGBA = 1,        BC3_RGBA = 2,        BC1_RGB = 3,        PVRTC1_4_RGBA = 4,        PVRTC1_4_RGB = 5,        ETC2_RGBA = 6,        ETC1_RGB = 7,        RGBA32 = 8    }    /**     * @hidden     */    export class Transcoder {        static CanTranscode(src: sourceTextureFormat, dst: transcodeTarget, isInGammaSpace: boolean): boolean;        static Name: string;        getName(): string;        initialize(): void;        needMemoryManager(): boolean;        setMemoryManager(memoryMgr: WASMMemoryManager): void;        transcode(src: sourceTextureFormat, dst: transcodeTarget, level: number, width: number, height: number, uncompressedByteLength: number, ktx2Reader: KTX2FileReader, imageDesc: IKTX2_ImageDesc | null, encodedData: Uint8Array): Promise<Uint8Array | null>;    }

    /**     * @hidden     */    export class TranscoderManager {        static _Transcoders: Array<typeof Transcoder>;        static RegisterTranscoder(transcoder: typeof Transcoder): void;        private static _TranscoderInstances;        private _wasmMemoryManager;        findTranscoder(src: sourceTextureFormat, dst: transcodeTarget, isInGammaSpace: boolean, bypass?: string[]): Transcoder | null;        private _getExistingTranscoder;    }



    /**     * @hidden     */    export class LiteTranscoder_UASTC_ASTC extends LiteTranscoder {        /**         * URL to use when loading the wasm module for the transcoder         */        static WasmModuleURL: string;        static CanTranscode(src: sourceTextureFormat, dst: transcodeTarget, isInGammaSpace: boolean): boolean;        static Name: string;        getName(): string;        initialize(): void;    }

    /**     * @hidden     */    export class LiteTranscoder_UASTC_BC7 extends LiteTranscoder {        /**         * URL to use when loading the wasm module for the transcoder         */        static WasmModuleURL: string;        static CanTranscode(src: sourceTextureFormat, dst: transcodeTarget, isInGammaSpace: boolean): boolean;        static Name: string;        getName(): string;        initialize(): void;    }

    /**     * @hidden     */    export class LiteTranscoder_UASTC_RGBA_SRGB extends LiteTranscoder {        /**         * URL to use when loading the wasm module for the transcoder (srgb)         */        static WasmModuleURL: string;        static CanTranscode(src: sourceTextureFormat, dst: transcodeTarget, isInGammaSpace: boolean): boolean;        static Name: string;        getName(): string;        initialize(): void;        transcode(src: sourceTextureFormat, dst: transcodeTarget, level: number, width: number, height: number, uncompressedByteLength: number, ktx2Reader: KTX2FileReader, imageDesc: IKTX2_ImageDesc | null, encodedData: Uint8Array): Promise<Uint8Array | null>;    }

    /**     * @hidden     */    export class LiteTranscoder_UASTC_RGBA_UNORM extends LiteTranscoder {        /**         * URL to use when loading the wasm module for the transcoder (unorm)         */        static WasmModuleURL: string;        static CanTranscode(src: sourceTextureFormat, dst: transcodeTarget, isInGammaSpace: boolean): boolean;        static Name: string;        getName(): string;        initialize(): void;        transcode(src: sourceTextureFormat, dst: transcodeTarget, level: number, width: number, height: number, uncompressedByteLength: number, ktx2Reader: KTX2FileReader, imageDesc: IKTX2_ImageDesc | null, encodedData: Uint8Array): Promise<Uint8Array | null>;    }

    /**     * @hidden     */    export class LiteTranscoder extends Transcoder {        private _modulePath;        private _modulePromise;        private _memoryManager;        protected _transcodeInPlace: boolean;        protected _loadModule(): Promise<{            module: any;        }>;        protected get memoryManager(): WASMMemoryManager;        protected setModulePath(modulePath: string): void;        initialize(): void;        needMemoryManager(): boolean;        setMemoryManager(memoryMgr: WASMMemoryManager): void;        transcode(src: sourceTextureFormat, dst: transcodeTarget, level: number, width: number, height: number, uncompressedByteLength: number, ktx2Reader: KTX2FileReader, imageDesc: IKTX2_ImageDesc | null, encodedData: Uint8Array): Promise<Uint8Array | null>;        protected _prepareTranscoding(width: number, height: number, uncompressedByteLength: number, encodedData: Uint8Array, forceRGBA?: boolean): [Uint8Array, Uint8Array | null, number];    }

    /**     * @hidden     */    export class MSCTranscoder extends Transcoder {        /**         * URL to use when loading the MSC transcoder         */        static JSModuleURL: string;        /**         * URL to use when loading the wasm module for the transcoder         */        static WasmModuleURL: string;        static UseFromWorkerThread: boolean;        static Name: string;        getName(): string;        private _mscBasisTranscoderPromise;        private _mscBasisModule;        private _getMSCBasisTranscoder;        static CanTranscode(src: sourceTextureFormat, dst: transcodeTarget, isInGammaSpace: boolean): boolean;        transcode(src: sourceTextureFormat, dst: transcodeTarget, level: number, width: number, height: number, uncompressedByteLength: number, ktx2Reader: KTX2FileReader, imageDesc: IKTX2_ImageDesc | null, encodedData: Uint8Array): Promise<Uint8Array | null>;    }

    /**     * @hidden     */    export class WASMMemoryManager {        static LoadBinariesFromCurrentThread: boolean;        static InitialMemoryPages: number;        private static _RequestId;        static LoadWASM(path: string): Promise<ArrayBuffer>;        private _memory;        private _numPages;        private _memoryView;        private _memoryViewByteLength;        private _memoryViewOffset;        constructor(initialMemoryPages?: number);        get wasmMemory(): WebAssembly.Memory;        getMemoryView(numPages: number, offset?: number, byteLength?: number): Uint8Array;    }

    /**     * ZSTD (Zstandard) decoder.     */    export class ZSTDDecoder {        static WasmModuleURL: string;        init(): Promise<void>;        _init(result: WebAssembly.WebAssemblyInstantiatedSource): void;        decode(array: Uint8Array, uncompressedSize?: number): Uint8Array;    }    /**     * BSD License     *     * For Zstandard software     *     * Copyright (c) 2016-present, Yann Collet, Facebook, Inc. All rights reserved.     *     * Redistribution and use in source and binary forms, with or without modification,     * are permitted provided that the following conditions are met:     *     *  * Redistributions of source code must retain the above copyright notice, this     *    list of conditions and the following disclaimer.     *     *  * Redistributions in binary form must reproduce the above copyright notice,     *    this list of conditions and the following disclaimer in the documentation     *    and/or other materials provided with the distribution.     *     *  * Neither the name Facebook nor the names of its contributors may be used to     *    endorse or promote products derived from this software without specific     *    prior written permission.     *     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR     * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES     * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON     * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS     * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.     */


}


                
{"version":3,"file":"babylonjs.addons.min.js","mappings":"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","sources":["webpack://ADDONS/webpack/universalModuleDefinition","webpack://ADDONS/../../../dev/addons/src/msdfText/shaders/msdf.vertex.ts","webpack://ADDONS/../../../dev/addons/src/msdfText/shadersWGSL/msdf.fragment.ts","webpack://ADDONS/../../../dev/addons/src/msdfText/shaders/msdf.fragment.ts","webpack://ADDONS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://ADDONS/../../../dev/addons/src/msdfText/shadersWGSL/msdf.vertex.ts","webpack://ADDONS/webpack/bootstrap","webpack://ADDONS/webpack/runtime/compat get default export","webpack://ADDONS/webpack/runtime/define property getters","webpack://ADDONS/webpack/runtime/hasOwnProperty shorthand","webpack://ADDONS/webpack/runtime/make namespace object","webpack://ADDONS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://ADDONS/../../../dev/addons/src/atmosphere/atmospherePBRMaterialPlugin.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/atmospherePerCameraVariables.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/atmospherePhysicalProperties.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/sampling.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/ShadersInclude/atmosphereFragmentDeclaration.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/ShadersInclude/atmosphereUboDeclaration.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/ShadersInclude/depthFunctions.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/ShadersInclude/atmosphereFunctions.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/diffuseSkyIrradiance.fragment.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/fullscreenTriangle.vertex.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/diffuseSkyIrradianceLut.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/transmittance.fragment.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/transmittanceLut.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/compositeAerialPerspective.fragment.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/compositeSky.fragment.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/compositeGlobeAtmosphere.fragment.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/multiScattering.fragment.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/skyView.fragment.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/aerialPerspective.fragment.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/Shaders/ShadersInclude/atmosphereVertexDeclaration.ts","webpack://ADDONS/../../../dev/addons/src/msdfText/fontAsset.ts","webpack://ADDONS/../../../dev/addons/src/atmosphere/atmosphere.ts","webpack://ADDONS/../../../dev/addons/src/htmlMesh/htmlMeshRenderer.ts","webpack://ADDONS/../../../dev/addons/src/htmlMesh/pointerEventsCapture.ts","webpack://ADDONS/../../../dev/addons/src/htmlMesh/pointerEventsCaptureBehavior.ts","webpack://ADDONS/../../../dev/addons/src/htmlMesh/fitStrategy.ts","webpack://ADDONS/../../../dev/addons/src/htmlMesh/htmlMesh.ts","webpack://ADDONS/../../../dev/addons/src/navigation/factory/common.ts","webpack://ADDONS/../../../dev/addons/src/msdfText/paragraphOptions.ts","webpack://ADDONS/../../../dev/addons/src/msdfText/sdf/paragraph.ts","webpack://ADDONS/../../../dev/addons/src/msdfText/textRenderer.ts","webpack://ADDONS/../../../dev/addons/src/navigation/common/tile-cache.ts","webpack://ADDONS/../../../dev/addons/src/navigation/common/config.ts","webpack://ADDONS/../../../dev/addons/src/navigation/plugin/RecastJSCrowd.ts","webpack://ADDONS/../../../dev/addons/src/navigation/common/convert.ts","webpack://ADDONS/../../../dev/addons/src/navigation/types.ts","webpack://ADDONS/../../../dev/addons/src/navigation/common/smooth-path.ts","webpack://ADDONS/../../../dev/addons/src/navigation/common/getters.ts","webpack://ADDONS/../../../dev/addons/src/navigation/debug/simple-debug.ts","webpack://ADDONS/../../../dev/addons/src/navigation/generator/generator.single-thread.ts","webpack://ADDONS/../../../dev/addons/src/navigation/generator/injection.ts","webpack://ADDONS/../../../dev/addons/src/navigation/plugin/RecastNavigationJSPlugin.ts","webpack://ADDONS/../../../dev/addons/src/navigation/factory/factory.single-thread.ts","webpack://ADDONS/../../../dev/addons/src/navigation/common/utils.ts","webpack://ADDONS/../../../dev/addons/src/navigation/generator/generator.common.ts","webpack://ADDONS/../../../dev/addons/src/navigation/debug/NavigationDebugger.ts","webpack://ADDONS/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-addons\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-addons\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"ADDONS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"msdfVertexShader\";\nconst shader = `#define BILLBOARD 1\n#define BILLBOARDSCREENPROJECTED 2\nattribute vec2 offsets;attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;attribute vec4 uvs;uniform mat4 transform;uniform mat4 parentWorld;uniform mat4 view;uniform mat4 projection;uniform vec3 center;uniform int mode;varying vec2 atlasUV;void main(void) {mat4 world=mat4(world0,world1,world2,world3);vec4 worldPos=transform*(world*vec4(offsets.xy-vec2(0.5,0.5),0.,1.0));if (mode>=BILLBOARD) {vec3 viewPos=(view*parentWorld*vec4(0.,0.,0.,1.0)).xyz; \nif (mode==BILLBOARDSCREENPROJECTED) {viewPos.x/=viewPos.z;viewPos.y/=viewPos.z;viewPos.z=1.0;}\ngl_Position=projection*vec4(viewPos+worldPos.xyz,1.0); } else {vec3 viewPos=(view*parentWorld*worldPos).xyz; \ngl_Position=projection*vec4(viewPos,1.0); }\natlasUV=vec2(uvs.x+offsets.x*uvs.z,uvs.y+(1.0-offsets.y)*uvs.w);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const msdfVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"msdfPixelShader\";\nconst shader = `var fontAtlas: texture_2d<f32>;var fontAtlasSampler: sampler;uniform uColor: vec4f;uniform thickness: f32;uniform uStrokeColor: vec4f;uniform uStrokeInsetWidth: f32;uniform uStrokeOutsetWidth: f32;varying atlasUV: vec2f;fn median(msdf: vec3<f32>)->f32 {let a=min(msdf.r,msdf.g);let b=max(msdf.r,msdf.g);return max(a,min(b,msdf.b));}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let s=textureSample(fontAtlas,fontAtlasSampler,input.atlasUV).rgb;let sigDist=median(s)-0.5+uniforms.thickness;let afwidth=length(vec2<f32>(dpdx(sigDist),dpdy(sigDist)));let alpha=clamp(sigDist/afwidth+0.5,0.0,1.0);let sigDistOutset=sigDist+uniforms.uStrokeOutsetWidth*0.5;let sigDistInset=sigDist-uniforms.uStrokeInsetWidth*0.5;let afwidthOutset=length(vec2<f32>(dpdx(sigDistOutset),dpdy(sigDistOutset)));let afwidthInset=length(vec2<f32>(dpdx(sigDistInset),dpdy(sigDistInset)));let outset=clamp(sigDistOutset/afwidthOutset+0.5,0.0,1.0);let inset=1.0-clamp(sigDistInset/afwidthInset+0.5,0.0,1.0);let border=outset*inset;let filledFragColor=vec4<f32>(uniforms.uColor.rgb,alpha*uniforms.uColor.a);let strokedFragColor=vec4<f32>(uniforms.uStrokeColor.rgb,border*uniforms.uStrokeColor.a);fragmentOutputs.color=mix(filledFragColor,strokedFragColor,border);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const msdfPixelShaderWGSL = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"msdfPixelShader\";\nconst shader = `#extension GL_OES_standard_derivatives : enable\nprecision highp float;uniform sampler2D fontAtlas;uniform vec4 uColor;uniform vec4 uStrokeColor;uniform float uStrokeInsetWidth;uniform float uStrokeOutsetWidth;uniform float thickness;varying vec2 atlasUV;float median(vec3 msdf) {return max(min(msdf.r,msdf.g),min(max(msdf.r,msdf.g),msdf.b));}\nvoid main(void)\n{vec3 s=texture2D(fontAtlas,atlasUV).rgb;float sigDist=median(s)-0.5+thickness;float alpha=clamp(sigDist/fwidth(sigDist)+0.5,0.0,1.0);float sigDistOutset=sigDist+uStrokeOutsetWidth*0.5;float sigDistInset=sigDist-uStrokeInsetWidth*0.5;float outset=clamp(sigDistOutset/fwidth(sigDistOutset)+0.5,0.0,1.0);float inset=1.0-clamp(sigDistInset/fwidth(sigDistInset)+0.5,0.0,1.0);float border=outset*inset;vec4 filledFragColor=vec4(uColor.rgb,alpha*uColor.a);vec4 strokedFragColor=vec4(uStrokeColor.rgb,border*uStrokeColor.a);gl_FragColor=mix(filledFragColor,strokedFragColor,border);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const msdfPixelShader = { name, shader };\n","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"msdfVertexShader\";\nconst shader = `#define BILLBOARD 1\n#define BILLBOARDSCREENPROJECTED 2\nattribute offsets: vec2f;attribute world0: vec4f;attribute world1: vec4f;attribute world2: vec4f;attribute world3: vec4f;attribute uvs: vec4f;uniform transform: mat4x4f;uniform parentWorld: mat4x4f;uniform view: mat4x4f;uniform projection: mat4x4f;uniform mode: u32;varying atlasUV: vec2f;@vertex\nfn main(input: VertexInputs)->FragmentInputs {let world=mat4x4<f32>(input.world0,input.world1,input.world2,input.world3);let localOffset=vec4<f32>(input.offsets-vec2<f32>(0.5,0.5),0.0,1.0);let worldPos=uniforms.transform*world*localOffset;if (uniforms.mode>=BILLBOARD) { \nvar viewPos=(uniforms.view*uniforms.parentWorld*vec4f(0.,0.,0.,1.0)).xyz;if (uniforms.mode==BILLBOARDSCREENPROJECTED) {viewPos=vec3f(viewPos.x/viewPos.z,viewPos.y/viewPos.z,1.0);} \nvertexOutputs.position=uniforms.projection*vec4<f32>(viewPos+worldPos.xyz,1.0);} else { \nlet viewPos=(uniforms.view*uniforms.parentWorld*worldPos).xyz;vertexOutputs.position=uniforms.projection*vec4<f32>(viewPos,1.0);}\nvertexOutputs.atlasUV=vec2<f32>(\ninput.uvs.x+input.offsets.x*input.uvs.z,\ninput.uvs.y+(1.0-input.offsets.y)*input.uvs.w\n);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const msdfVertexShaderWGSL = { name, shader };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { Atmosphere } from \"./atmosphere\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\r\nimport { MaterialPluginBase } from \"core/Materials/materialPluginBase\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { UniformBuffer } from \"core/Materials/uniformBuffer\";\r\nimport { Vector3FromFloatsToRef, Vector3ScaleToRef } from \"core/Maths/math.vector.functions\";\r\n\r\nclass AtmospherePBRMaterialDefines extends MaterialDefines {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public USE_AERIAL_PERSPECTIVE_LUT: boolean;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public APPLY_AERIAL_PERSPECTIVE_INTENSITY = false;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS = false;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public SAMPLE_TRANSMITTANCE_LUT = true;\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public EXCLUDE_RAY_MARCHING_FUNCTIONS = true;\r\n\r\n    /**\r\n     * Constructs the {@link AtmospherePBRMaterialDefines}.\r\n     * @param useAerialPerspectiveLut - Whether to use the aerial perspective LUT.\r\n     */\r\n    constructor(useAerialPerspectiveLut: boolean) {\r\n        super();\r\n        this.USE_AERIAL_PERSPECTIVE_LUT = useAerialPerspectiveLut;\r\n    }\r\n}\r\n\r\nconst OriginOffsetUniformName = \"originOffsetKm\";\r\nconst InverseViewportSizeUniformName = \"inverseViewportSize\";\r\n\r\nconst UboArray = [\r\n    { name: OriginOffsetUniformName, size: 3, type: \"vec3\" },\r\n    { name: \"_atmoPbrPadding1\", size: 1, type: \"float\" },\r\n    { name: InverseViewportSizeUniformName, size: 2, type: \"vec2\" },\r\n];\r\nconst MakeUniforms = (atmosphere: Atmosphere) => ({\r\n    ubo: UboArray,\r\n    fragment: `uniform vec2 ${InverseViewportSizeUniformName};\\nuniform vec3 ${OriginOffsetUniformName};\\n`,\r\n    externalUniforms: atmosphere.uniformBuffer.getUniformNames(),\r\n});\r\n\r\nconst PluginName = \"AtmospherePBRMaterialPlugin\";\r\nconst PluginPriority = 600;\r\nconst OriginOffsetKm = { x: 0, y: 0, z: 0 };\r\n\r\n/**\r\n * Adds shading logic to a PBRMaterial that provides radiance, diffuse sky irradiance, and aerial perspective from the atmosphere.\r\n */\r\nexport class AtmospherePBRMaterialPlugin extends MaterialPluginBase {\r\n    /**\r\n     * Constructs the {@link AtmospherePBRMaterialPlugin}.\r\n     * @param material - The material to apply the plugin to.\r\n     * @param _atmosphere - The atmosphere to use for shading.\r\n     * @param _isAerialPerspectiveEnabled - Whether to apply aerial perspective.\r\n     */\r\n    constructor(\r\n        material: Material,\r\n        private readonly _atmosphere: Atmosphere,\r\n        private readonly _isAerialPerspectiveEnabled = false\r\n    ) {\r\n        super(\r\n            material,\r\n            PluginName,\r\n            PluginPriority,\r\n            {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                USE_CUSTOM_REFLECTION: _atmosphere.diffuseSkyIrradianceLut !== null,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                CUSTOM_FRAGMENT_BEFORE_FOG: _isAerialPerspectiveEnabled,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                USE_AERIAL_PERSPECTIVE_LUT: _isAerialPerspectiveEnabled && _atmosphere.isAerialPerspectiveLutEnabled,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                APPLY_AERIAL_PERSPECTIVE_INTENSITY: _isAerialPerspectiveEnabled && _atmosphere.aerialPerspectiveIntensity !== 1.0,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS: _isAerialPerspectiveEnabled && _atmosphere.aerialPerspectiveRadianceBias !== 0.0,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                SAMPLE_TRANSMITTANCE_LUT: true,\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                EXCLUDE_RAY_MARCHING_FUNCTIONS: true,\r\n            },\r\n            false, // addPluginToList -- false because we need to control when this is added to the list\r\n            true, // enable\r\n            true // resolveIncludes\r\n        );\r\n\r\n        this.doNotSerialize = true;\r\n\r\n        // This calls `getCode` so we need to do this after having initialized the class fields.\r\n        this._pluginManager._addPlugin(this);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getUniformBuffersNames(_ubos: string[]): void {\r\n        const uniformBuffer = this._atmosphere.uniformBuffer;\r\n        if (uniformBuffer.useUbo) {\r\n            _ubos.push(uniformBuffer.name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getUniforms() {\r\n        return MakeUniforms(this._atmosphere);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override isReadyForSubMesh(): boolean {\r\n        let isReady = true;\r\n        const atmosphere = this._atmosphere;\r\n        if (this._isAerialPerspectiveEnabled && atmosphere.isAerialPerspectiveLutEnabled) {\r\n            const aerialPerspectiveLutRenderTarget = atmosphere.aerialPerspectiveLutRenderTarget;\r\n            isReady = isReady && !!aerialPerspectiveLutRenderTarget?.isReady();\r\n        }\r\n        const transmittanceLutRenderTarget = atmosphere.transmittanceLut?.renderTarget ?? null;\r\n        isReady = isReady && !!transmittanceLutRenderTarget?.isReady();\r\n        return isReady;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getActiveTextures(_activeTextures: BaseTexture[]): void {\r\n        const atmosphere = this._atmosphere;\r\n        if (this._isAerialPerspectiveEnabled && atmosphere.isAerialPerspectiveLutEnabled) {\r\n            const aerialPerspectiveLutRenderTarget = atmosphere.aerialPerspectiveLutRenderTarget;\r\n            if (aerialPerspectiveLutRenderTarget) {\r\n                _activeTextures.push(aerialPerspectiveLutRenderTarget);\r\n            }\r\n        }\r\n\r\n        const transmittanceLutRenderTarget = atmosphere.transmittanceLut?.renderTarget ?? null;\r\n        if (transmittanceLutRenderTarget) {\r\n            _activeTextures.push(transmittanceLutRenderTarget);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer): void {\r\n        const atmosphere = this._atmosphere;\r\n        const scene = atmosphere.scene;\r\n        const engine = scene.getEngine();\r\n\r\n        // Bind the atmosphere's uniform buffer to the effect.\r\n        const effect = uniformBuffer.currentEffect;\r\n        if (effect) {\r\n            this._atmosphere.bindUniformBufferToEffect(effect);\r\n        }\r\n\r\n        // Need the offset to apply which will take a world space position and convert it to a global space position in the atmosphere.\r\n        // If floating origin mode is enabled, that offset is the floating origin offset.\r\n        // If not, it's an offset up the Y-axis by the planet radius.\r\n        uniformBuffer.updateVector3(\r\n            OriginOffsetUniformName,\r\n            scene.floatingOriginMode\r\n                ? Vector3ScaleToRef(scene.floatingOriginOffset, 0.001, OriginOffsetKm) // Convert to kilometers\r\n                : Vector3FromFloatsToRef(0, atmosphere.physicalProperties.planetRadius, 0, OriginOffsetKm) // planetRadius is already in kilometers\r\n        );\r\n\r\n        const width = engine.getRenderWidth();\r\n        const height = engine.getRenderHeight();\r\n        uniformBuffer.updateFloat2(InverseViewportSizeUniformName, 1.0 / width, 1.0 / height);\r\n\r\n        if (this._isAerialPerspectiveEnabled && atmosphere.isAerialPerspectiveLutEnabled) {\r\n            const aerialPerspectiveLutRenderTarget = atmosphere.aerialPerspectiveLutRenderTarget;\r\n            uniformBuffer.setTexture(\"aerialPerspectiveLut\", aerialPerspectiveLutRenderTarget);\r\n        }\r\n        const transmittanceLutRenderTarget = atmosphere.transmittanceLut?.renderTarget ?? null;\r\n        uniformBuffer.setTexture(\"transmittanceLut\", transmittanceLutRenderTarget);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override prepareDefines(defines: AtmospherePBRMaterialDefines): void {\r\n        const lastUseAerialPerspectiveLut = defines.USE_AERIAL_PERSPECTIVE_LUT;\r\n        const lastApplyAerialPerspectiveIntensity = defines.APPLY_AERIAL_PERSPECTIVE_INTENSITY;\r\n        const lastApplyAerialPerspectiveRadianceBias = defines.APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS;\r\n        defines.USE_AERIAL_PERSPECTIVE_LUT = this._isAerialPerspectiveEnabled && this._atmosphere.isAerialPerspectiveLutEnabled;\r\n        defines.APPLY_AERIAL_PERSPECTIVE_INTENSITY = this._isAerialPerspectiveEnabled && this._atmosphere.aerialPerspectiveIntensity !== 1.0;\r\n        defines.APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS = this._isAerialPerspectiveEnabled && this._atmosphere.aerialPerspectiveRadianceBias !== 0.0;\r\n        if (\r\n            lastUseAerialPerspectiveLut !== defines.USE_AERIAL_PERSPECTIVE_LUT ||\r\n            lastApplyAerialPerspectiveIntensity !== defines.APPLY_AERIAL_PERSPECTIVE_INTENSITY ||\r\n            lastApplyAerialPerspectiveRadianceBias !== defines.APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS\r\n        ) {\r\n            defines.markAllAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"transmittanceLut\");\r\n        if (this._isAerialPerspectiveEnabled && this._atmosphere.isAerialPerspectiveLutEnabled) {\r\n            samplers.push(\"aerialPerspectiveLut\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public override getCustomCode(shaderType: string): Nullable<Record<string, string>> {\r\n        // Assumed inputs are light0, vPositionW, normalW.\r\n        // Only works for directional lights.\r\n        if (shaderType !== \"fragment\") {\r\n            return null;\r\n        }\r\n\r\n        const useUbo = this._atmosphere.scene.getEngine().supportsUniformBuffers;\r\n        const directionToLightSnippet = useUbo ? \"-light0.vLightData.xyz\" : \"-vLightData0.xyz\";\r\n\r\n        const useAtmosphereUbo = this._atmosphere.uniformBuffer.useUbo;\r\n        const atmosphereImportSnippet = useAtmosphereUbo ? \"#include<atmosphereUboDeclaration>\" : \"#include<atmosphereFragmentDeclaration>\";\r\n\r\n        return {\r\n            CUSTOM_FRAGMENT_DEFINITIONS:\r\n                this._isAerialPerspectiveEnabled && this._atmosphere.isAerialPerspectiveLutEnabled\r\n                    ? `uniform sampler2D transmittanceLut;\\r\\nprecision highp sampler2DArray;\\r\\nuniform sampler2DArray aerialPerspectiveLut;\\r\\n${atmosphereImportSnippet}\\r\\n#include<atmosphereFunctions>`\r\n                    : `uniform sampler2D transmittanceLut;\\r\\n${atmosphereImportSnippet}\\r\\n#include<atmosphereFunctions>`,\r\n            CUSTOM_LIGHT0_COLOR: `\r\n            {\r\n                vec3 positionGlobal = 0.001 * vPositionW + ${OriginOffsetUniformName};\r\n                float positionRadius = length(positionGlobal);\r\n                vec3 geocentricNormal = positionGlobal / positionRadius;\r\n                vec3 directionToLight = ${directionToLightSnippet};\r\n                float cosAngleLightToZenith = dot(directionToLight, geocentricNormal);\r\n                diffuse0 = lightIntensity * sampleTransmittanceLut(transmittanceLut, positionRadius, cosAngleLightToZenith);\r\n            }\r\n`,\r\n            CUSTOM_REFLECTION: `\r\n            {\r\n                vec3 positionGlobal =  0.001 * vPositionW + ${OriginOffsetUniformName};\r\n                float positionRadius = length(positionGlobal);\r\n                vec3 geocentricNormal = positionGlobal / positionRadius;\r\n\r\n                vec3 directionToLight = ${directionToLightSnippet};\r\n                float cosAngleLightToZenith = dot(directionToLight, geocentricNormal);\r\n\r\n                vec2 uv = vec2(0.5 + 0.5 * cosAngleLightToZenith, (positionRadius - planetRadius) / atmosphereThickness);\r\n                float irradianceScaleT = 0.5 * dot(normalW, geocentricNormal) + 0.5;\r\n                float irradianceScale = ((-0.6652 * irradianceScaleT) + 1.5927) * irradianceScaleT + 0.1023;\r\n                vec3 environmentIrradiance = lightIntensity * sampleReflection(irradianceSampler, uv).rgb;\r\n\r\n                // Add a contribution here to estimate indirect lighting.\r\n                const float r = 0.2;\r\n                float indirect = getLuminance(environmentIrradiance) / max(0.00001, 1. - r);\r\n                environmentIrradiance *= irradianceScale;\r\n                environmentIrradiance += indirect;\r\n\r\n                environmentIrradiance += additionalDiffuseSkyIrradiance;\r\n\r\n                const float diffuseBrdf = 1. / PI;\r\n                environmentIrradiance *= diffuseBrdf * diffuseSkyIrradianceIntensity;\r\n\r\n                reflectionOut.environmentIrradiance = environmentIrradiance;\r\n                reflectionOut.environmentRadiance.rgb = reflectionOut.environmentIrradiance;\r\n            }\r\n`,\r\n            // TODO: Support full ray marching if USE_AERIAL_PERSPECTIVE_LUT is disabled.\r\n            CUSTOM_FRAGMENT_BEFORE_FOG: `\r\n            #if USE_AERIAL_PERSPECTIVE_LUT\r\n            {\r\n                float distanceFromCameraKm = 0.001 * distance(vEyePosition.xyz, vPositionW);\r\n                vec4 aerialPerspective = vec4(0.);\r\n                if (sampleAerialPerspectiveLut(\r\n                        gl_FragCoord.xy * ${InverseViewportSizeUniformName},\r\n                        true,\r\n                        distanceFromCameraKm,\r\n                        NumAerialPerspectiveLutLayers,\r\n                        AerialPerspectiveLutKMPerSlice,\r\n                        AerialPerspectiveLutRangeKM,\r\n                        aerialPerspective)) {\r\n                    finalColor = aerialPerspective + (1. - aerialPerspective.a) * finalColor;\r\n                }\r\n            }\r\n            #endif\r\n`,\r\n        };\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { IMatrixLike, IVector3Like, IVector4Like } from \"core/Maths/math.like\";\r\nimport { Matrix, Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport { Ray } from \"core/Culling/ray.core\";\r\nimport { Vector3Dot } from \"core/Maths/math.vector.functions\";\r\n\r\nconst TempRay = new Ray(Vector3.Zero(), Vector3.Zero());\r\n\r\n/**\r\n * Variables that are used to render the atmosphere and are computed per-camera.\r\n */\r\nexport class AtmospherePerCameraVariables {\r\n    private _inverseViewProjectionMatrixWithoutTranslation = Matrix.Identity();\r\n    private _directionToLightRelativeToCameraGeocentricNormal = Vector3.Up();\r\n    private _cosAngleLightToZenith = 0;\r\n    private _cameraRadius = 0;\r\n    private _clampedCameraRadius = 0;\r\n    private _cameraHeight = 0;\r\n    private _clampedCameraHeight = 0;\r\n    private _cameraPositionGlobal = new Vector3();\r\n    private _clampedCameraPositionGlobal = new Vector3();\r\n    private _cosCameraHorizonAngleFromZenith = 0;\r\n    private _sinCameraAtmosphereHorizonAngleFromNadir = 0;\r\n    private _cameraGeocentricNormal = Vector3.Up();\r\n    private _cameraForward = Vector3.Down();\r\n    private _cameraNearPlane = 0;\r\n    private _cameraPosition = new Vector3();\r\n    private _viewport = new Vector4();\r\n    private _lastViewMatrix = Matrix.Identity();\r\n    private _lastProjectionMatrix = Matrix.Identity();\r\n    private _inverseViewMatrixWithoutTranslation = Matrix.Identity();\r\n    private _inverseProjectionMatrix = Matrix.Identity();\r\n\r\n    /**\r\n     * The inverse view projection matrix is used to unproject rays.\r\n     * To avoid precision issues, the translation part of the matrix has been removed.\r\n     */\r\n    public get inverseViewProjectionMatrixWithoutTranslation(): IMatrixLike {\r\n        return this._inverseViewProjectionMatrixWithoutTranslation;\r\n    }\r\n\r\n    /**\r\n     * The direction to the light relative to the geocentric normal under the camera.\r\n     */\r\n    public get directionToLightRelativeToCameraGeocentricNormal(): IVector3Like {\r\n        return this._directionToLightRelativeToCameraGeocentricNormal;\r\n    }\r\n\r\n    /**\r\n     * The cosine of the angle between the light direction and zenith.\r\n     */\r\n    public get cosAngleLightToZenith(): number {\r\n        return this._cosAngleLightToZenith;\r\n    }\r\n\r\n    /**\r\n     * The distance from the camera to the planet origin in kilometers.\r\n     */\r\n    public get cameraRadius(): number {\r\n        return this._cameraRadius;\r\n    }\r\n\r\n    /**\r\n     * The distance from the camera to the planet origin, clamped to the planet radius offset, in kilometers.\r\n     */\r\n    public get clampedCameraRadius(): number {\r\n        return this._clampedCameraRadius;\r\n    }\r\n\r\n    /**\r\n     * The height of the camera above the planet surface in kilometers.\r\n     */\r\n    public get cameraHeight(): number {\r\n        return this._cameraHeight;\r\n    }\r\n\r\n    /**\r\n     * The height of the camera above the planet surface, clamped to the planet radius offset, in kilometers.\r\n     */\r\n    public get clampedCameraHeight(): number {\r\n        return this._clampedCameraHeight;\r\n    }\r\n\r\n    /**\r\n     * The camera position in global space kilometers.\r\n     *\r\n     * The behavior of this value depends on whether floating origin mode is enabled:\r\n     * - If floating origin mode is enabled, this is simply the camera's global position scaled to kilometers. The atmosphere's origin height is used to offset the camera position along its geocentric normal.\r\n     * - If floating origin mode is disabled, the camera's y position is offset by the planet radius plus any origin height.\r\n     */\r\n    public get cameraPositionGlobal(): IVector3Like {\r\n        return this._cameraPositionGlobal;\r\n    }\r\n\r\n    /**\r\n     * The camera position, clamped to the planet radius offset, in global space kilometers.\r\n     * See {@link cameraPositionGlobal} for details on how the value is computed.\r\n     */\r\n    public get clampedCameraPositionGlobal(): IVector3Like {\r\n        return this._clampedCameraPositionGlobal;\r\n    }\r\n\r\n    /**\r\n     * The cosine of the angle from the zenith to the horizon of the planet, measured from the camera position.\r\n     */\r\n    public get cosCameraHorizonAngleFromZenith(): number {\r\n        return this._cosCameraHorizonAngleFromZenith;\r\n    }\r\n\r\n    /**\r\n     * The sine of the angle from the nadir to the horizon of the atmosphere, measured from the camera position.\r\n     */\r\n    public get sinCameraAtmosphereHorizonAngleFromNadir(): number {\r\n        return this._sinCameraAtmosphereHorizonAngleFromNadir;\r\n    }\r\n\r\n    /**\r\n     * The geocentric normal of the camera in global space i.e., the normalization of {@link cameraPositionGlobal}.\r\n     * Note the behavior of this value depends on whether floating origin mode is enabled. See {@link cameraPositionGlobal} for details.\r\n     */\r\n    public get cameraGeocentricNormal(): IVector3Like {\r\n        return this._cameraGeocentricNormal;\r\n    }\r\n\r\n    /**\r\n     * The camera's forward direction in world space.\r\n     */\r\n    public get cameraForward(): IVector3Like {\r\n        return this._cameraForward;\r\n    }\r\n\r\n    /**\r\n     * The distance to the near plane of the camera.\r\n     */\r\n    public get cameraNearPlane(): number {\r\n        return this._cameraNearPlane;\r\n    }\r\n\r\n    /**\r\n     * The camera's position in world space.\r\n     */\r\n    public get cameraPosition(): IVector3Like {\r\n        return this._cameraPosition;\r\n    }\r\n\r\n    /**\r\n     * The viewport for the camera.\r\n     */\r\n    public get viewport(): IVector4Like {\r\n        return this._viewport;\r\n    }\r\n\r\n    /**\r\n     * Updates the variables.\r\n     * @param camera - The camera to update the variables for.\r\n     * @param planetRadius - The radius of the planet in kilometers.\r\n     * @param planetRadiusWithOffset - The radius of the planet with the offset in kilometers.\r\n     * @param atmosphereRadius - The radius of the atmosphere in kilometers.\r\n     * @param directionToLight - The direction to the light in world space.\r\n     * @param originHeight - The height of the origin (distance from planet's surface) in kilometers.\r\n     */\r\n    public update(camera: Camera, planetRadius: number, planetRadiusWithOffset: number, atmosphereRadius: number, directionToLight: IVector3Like, originHeight: number): void {\r\n        this._cameraNearPlane = camera.minZ;\r\n        this._cameraForward.copyFrom(camera.getForwardRayToRef(TempRay, 1).direction);\r\n\r\n        const scene = camera.getScene();\r\n        const engine = scene.getEngine();\r\n        this._viewport.copyFromFloats(0.0, 0.0, engine.getRenderWidth(), engine.getRenderHeight());\r\n\r\n        // Compute inverse view projection matrix, but remove the translational component to increase precision.\r\n        const viewMatrix = camera.getViewMatrix();\r\n        const projectionMatrix = camera.getProjectionMatrix();\r\n        const lastViewMatrix = this._lastViewMatrix;\r\n        const lastProjectionMatrix = this._lastProjectionMatrix;\r\n        if (!lastViewMatrix.equals(viewMatrix) || !lastProjectionMatrix.equals(projectionMatrix)) {\r\n            lastViewMatrix.copyFrom(viewMatrix);\r\n            lastViewMatrix.setTranslation(Vector3.ZeroReadOnly);\r\n            lastViewMatrix.invertToRef(this._inverseViewMatrixWithoutTranslation);\r\n\r\n            lastProjectionMatrix.copyFrom(projectionMatrix);\r\n            lastProjectionMatrix.invertToRef(this._inverseProjectionMatrix);\r\n            this._inverseProjectionMatrix.multiplyToRef(this._inverseViewMatrixWithoutTranslation, this._inverseViewProjectionMatrixWithoutTranslation);\r\n        }\r\n\r\n        // Compute the global space position of the camera in kilometers.\r\n        const cameraPositionGlobal = this._cameraPosition.copyFrom(camera.globalPosition).scaleToRef(0.001, this._cameraPositionGlobal); // scale to kilometers\r\n\r\n        // Apply the origin height to the camera position, and in doing so, compute the camera geocentric normal.\r\n        if (scene.floatingOriginMode) {\r\n            // When in floating origin mode, assume world space origin is at the planet center.\r\n            // Therefore \"up\" is away from the planet center (0, 0, 0).\r\n            cameraPositionGlobal.normalizeToRef(this._cameraGeocentricNormal);\r\n            this._cameraGeocentricNormal.scaleAndAddToRef(originHeight, cameraPositionGlobal);\r\n        } else {\r\n            // If not in floating origin mode, offset the camera position by the origin height.\r\n            // Assume the origin is directly above the planet surface along the up axis (y axis).\r\n            cameraPositionGlobal.y += planetRadius + originHeight;\r\n            cameraPositionGlobal.normalizeToRef(this._cameraGeocentricNormal);\r\n        }\r\n\r\n        this._cameraRadius = cameraPositionGlobal.length(); // distance from planet center\r\n        this._cameraHeight = this._cameraRadius - planetRadius; // height above planet surface\r\n\r\n        // Clamp the camera parameters.\r\n        this._clampedCameraRadius = this._cameraRadius;\r\n        if (this._clampedCameraRadius < planetRadiusWithOffset) {\r\n            this._clampedCameraRadius = planetRadiusWithOffset;\r\n            this._cameraGeocentricNormal.scaleToRef(planetRadiusWithOffset, this._clampedCameraPositionGlobal);\r\n        } else {\r\n            this._clampedCameraPositionGlobal.copyFrom(cameraPositionGlobal);\r\n        }\r\n\r\n        this._cosCameraHorizonAngleFromZenith = ComputeCosHorizonAngleFromZenith(planetRadius, this._clampedCameraRadius);\r\n        this._sinCameraAtmosphereHorizonAngleFromNadir = Math.min(1.0, atmosphereRadius / this._clampedCameraRadius);\r\n        this._clampedCameraHeight = this._clampedCameraRadius - planetRadius;\r\n\r\n        // Compute the direction to the light relative to the camera's geocentric normal.\r\n        {\r\n            this._cosAngleLightToZenith = Vector3Dot(directionToLight, this._cameraGeocentricNormal);\r\n            const lightZenithSinAngle = Math.sqrt(Math.max(0.0, 1.0 - this._cosAngleLightToZenith * this._cosAngleLightToZenith));\r\n            this._directionToLightRelativeToCameraGeocentricNormal.copyFromFloats(lightZenithSinAngle, this._cosAngleLightToZenith, 0.0);\r\n            this._directionToLightRelativeToCameraGeocentricNormal.normalize();\r\n        }\r\n    }\r\n}\r\n\r\nconst ComputeCosHorizonAngleFromZenith = (planetRadius: number, radius: number): number => {\r\n    const sinHorizonAngleFromNadir = Math.min(1, planetRadius / radius);\r\n    const cosHorizonAngleFromNadir = Math.sqrt(1 - sinHorizonAngleFromNadir * sinHorizonAngleFromNadir);\r\n    const cosHorizonAngleFromZenith = -cosHorizonAngleFromNadir;\r\n    return cosHorizonAngleFromZenith;\r\n};\r\n","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { IAtmospherePhysicalPropertiesOptions } from \"./atmospherePhysicalPropertiesOptions\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\n\r\nconst DefaultPlanetRadius = 6360.0;\r\nconst DefaultPlanetRadiusOffset = 0.01;\r\nconst DefaultAtmosphereThickness = 100.0;\r\n\r\n// The scattering and absorption values are per kilometer measured at sea level.\r\nconst DefaultPeakRayleighScattering = new Vector3(0.005802, 0.013558, 0.0331);\r\nconst DefaultPeakMieScattering = new Vector3(0.003996, 0.003996, 0.003996);\r\nconst DefaultPeakMieAbsorption = new Vector3(0.000444, 0.000444, 0.000444);\r\nconst DefaultPeakOzoneAbsorption = new Vector3(0.00065, 0.001881, 0.000085);\r\n\r\n/**\r\n * Describes the physical properties of the atmosphere. Assumes a spherical planet.\r\n * - \"radius\" values describe a distance from the planet's center.\r\n * - \"height\" values describe a distance from the planet's surface.\r\n * - Distances are in kilometers unless otherwise specified. Angles are in radians.\r\n */\r\nexport class AtmospherePhysicalProperties {\r\n    /**\r\n     * Notification for when properties of the {@link AtmospherePhysicalProperties} are changed.\r\n     */\r\n    public readonly onChangedObservable = new Observable<AtmospherePhysicalProperties>();\r\n\r\n    private _planetRadius: number;\r\n    private _planetRadiusOffset: number;\r\n    private _atmosphereThickness: number;\r\n    private _rayleighScatteringScale: number;\r\n    private _peakRayleighScattering = new Vector3();\r\n    private _mieScatteringScale: number;\r\n    private _peakMieScattering = new Vector3();\r\n    private _mieAbsorptionScale: number;\r\n    private _peakMieAbsorption = new Vector3();\r\n    private _ozoneAbsorptionScale: number;\r\n    private _peakOzoneAbsorption = new Vector3();\r\n\r\n    // Inferred values.\r\n    private _planetRadiusWithOffset = 0;\r\n    private _planetRadiusSquared = 0;\r\n    private _atmosphereRadius = 0;\r\n    private _atmosphereRadiusSquared = 0;\r\n    private _horizonDistanceToAtmosphereEdge = 0;\r\n    private _horizonDistanceToAtmosphereEdgeSquared = 0;\r\n    private _rayleighScattering = new Vector3();\r\n    private _mieScattering = new Vector3();\r\n    private _mieAbsorption = new Vector3();\r\n    private _mieExtinction = new Vector3();\r\n    private _ozoneAbsorption = new Vector3();\r\n\r\n    /**\r\n     * The radius of the planet in kilometers.\r\n     */\r\n    public get planetRadius(): number {\r\n        return this._planetRadius;\r\n    }\r\n    public set planetRadius(value: number) {\r\n        if (this._planetRadius !== value) {\r\n            this._planetRadius = value;\r\n            this._recomputeDimensionalParameters();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The squared radius of the planet in kilometers.\r\n     */\r\n    public get planetRadiusSquared(): number {\r\n        return this._planetRadiusSquared;\r\n    }\r\n\r\n    /**\r\n     * Offset applied to view points near the planet's surface. This should be greater than 0.\r\n     * It prevents rendering issues close to the planet's surface.\r\n     */\r\n    public get planetRadiusOffset(): number {\r\n        return this._planetRadiusOffset;\r\n    }\r\n    public set planetRadiusOffset(value: number) {\r\n        if (this._planetRadiusOffset !== value) {\r\n            this._planetRadiusOffset = value;\r\n            this._recomputeDimensionalParameters();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This is the {@link planetRadius} with the additional {@link planetRadiusOffset}, in kilometers.\r\n     */\r\n    public get planetRadiusWithOffset(): number {\r\n        return this._planetRadiusWithOffset;\r\n    }\r\n\r\n    /**\r\n     * The thickness of the atmosphere measured in kilometers.\r\n     */\r\n    public get atmosphereThickness(): number {\r\n        return this._atmosphereThickness;\r\n    }\r\n    public set atmosphereThickness(value: number) {\r\n        if (this._atmosphereThickness !== value) {\r\n            this._atmosphereThickness = value;\r\n            this._recomputeDimensionalParameters();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The combined planet radius and atmosphere thickness in kilometers.\r\n     */\r\n    public get atmosphereRadius(): number {\r\n        return this._atmosphereRadius;\r\n    }\r\n\r\n    /**\r\n     * The atmosphere radius squared in kilometers.\r\n     */\r\n    public get atmosphereRadiusSquared(): number {\r\n        return this._atmosphereRadiusSquared;\r\n    }\r\n\r\n    /**\r\n     * Horizon distance from the planet's surface to the outer edge of the atmosphere in kilometers.\r\n     */\r\n    public get horizonDistanceToAtmosphereEdge(): number {\r\n        return this._horizonDistanceToAtmosphereEdge;\r\n    }\r\n\r\n    /**\r\n     * Horizon distance from the planet's surface to the outer edge of the atmosphere, squared, in kilometers.\r\n     */\r\n    public get horizonDistanceToAtmosphereEdgeSquared(): number {\r\n        return this._horizonDistanceToAtmosphereEdgeSquared;\r\n    }\r\n\r\n    /**\r\n     * The scale applied to {@link peakRayleighScattering}.\r\n     */\r\n    public get rayleighScatteringScale(): number {\r\n        return this._rayleighScatteringScale;\r\n    }\r\n    public set rayleighScatteringScale(value: number) {\r\n        if (this._rayleighScatteringScale !== value) {\r\n            this._rayleighScatteringScale = value;\r\n            this._recomputeRayleighScattering();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Rayleigh scattering per kilometer at sea level for red, green, and blue wavelengths.\r\n     */\r\n    public get peakRayleighScattering(): Vector3 {\r\n        return this._peakRayleighScattering;\r\n    }\r\n    public set peakRayleighScattering(value: Vector3) {\r\n        if (!this._peakRayleighScattering.equals(value)) {\r\n            this._peakRayleighScattering.copyFrom(value);\r\n            this._recomputeRayleighScattering();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Rayleigh scattering per kilometer at sea level for red, green, and blue wavelengths.\r\n     * This value cannot be set directly. It is inferred by scaling {@link peakRayleighScattering} by {@link rayleighScatteringScale}.\r\n     */\r\n    public get rayleighScattering(): Vector3 {\r\n        return this._rayleighScattering;\r\n    }\r\n\r\n    /**\r\n     * The scale applied to {@link peakMieScattering}.\r\n     */\r\n    public get mieScatteringScale(): number {\r\n        return this._mieScatteringScale;\r\n    }\r\n    public set mieScatteringScale(value: number) {\r\n        if (this._mieScatteringScale !== value) {\r\n            this._mieScatteringScale = value;\r\n            this._recomputeMieScattering();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Mie scattering per kilometer at sea level for red, green, and blue wavelengths.\r\n     */\r\n    public get peakMieScattering(): Vector3 {\r\n        return this._peakMieScattering;\r\n    }\r\n    public set peakMieScattering(value: Vector3) {\r\n        if (!this._peakMieScattering.equals(value)) {\r\n            this._peakMieScattering.copyFrom(value);\r\n            this._recomputeMieScattering();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Mie scattering per kilometer at sea level for red, green, and blue wavelengths.\r\n     * This value cannot be set directly. It is inferred by scaling {@link mieScatteringScale} by {@link peakMieScattering}.\r\n     */\r\n    public get mieScattering(): Vector3 {\r\n        return this._mieScattering;\r\n    }\r\n\r\n    /**\r\n     * The scale applied to {@link peakMieAbsorption}.\r\n     */\r\n    public get mieAbsorptionScale(): number {\r\n        return this._mieAbsorptionScale;\r\n    }\r\n    public set mieAbsorptionScale(value: number) {\r\n        if (this._mieAbsorptionScale !== value) {\r\n            this._mieAbsorptionScale = value;\r\n            this._recomputeMieAbsorption();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Mie absorption per kilometer at sea level for red, green, and blue wavelengths.\r\n     */\r\n    public get peakMieAbsorption(): Vector3 {\r\n        return this._peakMieAbsorption;\r\n    }\r\n    public set peakMieAbsorption(value: Vector3) {\r\n        if (!this._peakMieAbsorption.equals(value)) {\r\n            this._peakMieAbsorption.copyFrom(value);\r\n            this._recomputeMieAbsorption();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The Mie absorption per kilometer at sea level for red, green, and blue wavelengths.\r\n     * This value cannot be set directly. It is inferred by scaling {@link mieAbsorptionScale} by {@link peakMieAbsorption}.\r\n     */\r\n    public get mieAbsorption(): Vector3 {\r\n        return this._mieAbsorption;\r\n    }\r\n\r\n    /**\r\n     * The Mie extinction per kilometer at sea level for red, green, and blue wavelengths.\r\n     * This value cannot be set directly. It is inferred by adding the {@link mieAbsorption} to the {@link mieScattering}.\r\n     */\r\n    public get mieExtinction(): Vector3 {\r\n        return this._mieExtinction;\r\n    }\r\n\r\n    /**\r\n     * The scale applied to {@link peakOzoneAbsorption}.\r\n     */\r\n    public get ozoneAbsorptionScale(): number {\r\n        return this._ozoneAbsorptionScale;\r\n    }\r\n    public set ozoneAbsorptionScale(value: number) {\r\n        if (this._ozoneAbsorptionScale !== value) {\r\n            this._ozoneAbsorptionScale = value;\r\n            this._recomputeOzoneAbsorption();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The ozone absorption per kilometer measured at a height corresponding to it's peak concentration,\r\n     * for red, green, and blue wavelengths.\r\n     */\r\n    public get peakOzoneAbsorption(): Vector3 {\r\n        return this._peakOzoneAbsorption;\r\n    }\r\n    public set peakOzoneAbsorption(value: Vector3) {\r\n        if (!this._peakOzoneAbsorption.equals(value)) {\r\n            this._peakOzoneAbsorption.copyFrom(value);\r\n            this._recomputeOzoneAbsorption();\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The ozone absorption per kilometer at sea level for red, green, and blue wavelengths.\r\n     * This value cannot be set directly. It is inferred by scaling {@link peakOzoneAbsorption} by {@link ozoneAbsorptionScale}.\r\n     */\r\n    public get ozoneAbsorption(): Vector3 {\r\n        return this._ozoneAbsorption;\r\n    }\r\n\r\n    /**\r\n     * Constructs the {@link AtmospherePhysicalProperties}.\r\n     * @param options - The options for the {@link AtmospherePhysicalProperties}.\r\n     */\r\n    constructor(options?: IAtmospherePhysicalPropertiesOptions) {\r\n        this._planetRadius = options?.planetRadius ?? DefaultPlanetRadius;\r\n        this._planetRadiusOffset = options?.planetRadiusOffset ?? DefaultPlanetRadiusOffset;\r\n        this._atmosphereThickness = options?.atmosphereThickness ?? DefaultAtmosphereThickness;\r\n        this._rayleighScatteringScale = options?.rayleighScatteringScale ?? 1.0;\r\n        this._peakRayleighScattering.copyFrom(options?.peakRayleighScattering ?? DefaultPeakRayleighScattering);\r\n        this._mieScatteringScale = options?.mieScatteringScale ?? 1.0;\r\n        this._peakMieScattering.copyFrom(options?.peakMieScattering ?? DefaultPeakMieScattering);\r\n        this._mieAbsorptionScale = options?.mieAbsorptionScale ?? 1.0;\r\n        this._peakMieAbsorption.copyFrom(options?.peakMieAbsorption ?? DefaultPeakMieAbsorption);\r\n        this._ozoneAbsorptionScale = options?.ozoneAbsorptionScale ?? 1.0;\r\n        this._peakOzoneAbsorption.copyFrom(options?.peakOzoneAbsorption ?? DefaultPeakOzoneAbsorption);\r\n\r\n        // Compute inferred values.\r\n        this._recomputeDimensionalParameters();\r\n        this._recomputeRayleighScattering();\r\n        this._recomputeMieScattering();\r\n        this._recomputeMieAbsorption();\r\n        this._recomputeOzoneAbsorption();\r\n    }\r\n\r\n    private _recomputeDimensionalParameters(): void {\r\n        this._planetRadiusWithOffset = this._planetRadius + this._planetRadiusOffset;\r\n        this._planetRadiusSquared = this._planetRadius * this._planetRadius;\r\n        this._atmosphereRadius = this._planetRadius + this._atmosphereThickness;\r\n        this._atmosphereRadiusSquared = this._atmosphereRadius * this._atmosphereRadius;\r\n        this._horizonDistanceToAtmosphereEdgeSquared = this._atmosphereRadiusSquared - this._planetRadiusSquared;\r\n        this._horizonDistanceToAtmosphereEdge = Math.sqrt(this._horizonDistanceToAtmosphereEdgeSquared);\r\n    }\r\n\r\n    private _recomputeRayleighScattering(): void {\r\n        this._peakRayleighScattering.scaleToRef(this._rayleighScatteringScale, this._rayleighScattering);\r\n    }\r\n\r\n    private _recomputeMieScattering(): void {\r\n        this._peakMieScattering.scaleToRef(this._mieScatteringScale, this._mieScattering);\r\n        this._recomputeMieExtinction();\r\n    }\r\n\r\n    private _recomputeMieAbsorption(): void {\r\n        this._peakMieAbsorption.scaleToRef(this._mieAbsorptionScale, this._mieAbsorption);\r\n        this._recomputeMieExtinction();\r\n    }\r\n\r\n    private _recomputeMieExtinction(): void {\r\n        this._mieAbsorption.addToRef(this._mieScattering, this._mieExtinction);\r\n    }\r\n\r\n    private _recomputeOzoneAbsorption(): void {\r\n        this._peakOzoneAbsorption.scaleToRef(this._ozoneAbsorptionScale, this._ozoneAbsorption);\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport { Clamp } from \"core/Maths/math.scalar.functions\";\r\nimport type { IColor4Like } from \"core/Maths/math.like\";\r\n\r\nconst MakeTempColor4Like = (): IColor4Like => {\r\n    return {\r\n        r: Number.NaN,\r\n        g: Number.NaN,\r\n        b: Number.NaN,\r\n        a: Number.NaN,\r\n    };\r\n};\r\n\r\nconst TmpColor1 = MakeTempColor4Like();\r\nconst TmpColor2 = MakeTempColor4Like();\r\nconst TmpColor3 = MakeTempColor4Like();\r\nconst TmpColor4 = MakeTempColor4Like();\r\n\r\n/**\r\n * Samples the texture data at the given uv coordinate using bilinear interpolation.\r\n * Note this will not match GPU sampling behavior exactly.\r\n * Currently assumes clamping behavior.\r\n * @param u - The u coordinate to sample.\r\n * @param v - The v coordinate to sample.\r\n * @param widthPx - The width of the texture in texels.\r\n * @param heightPx - The height of the texture in texels.\r\n * @param data - The texture data to sample.\r\n * @param result - The color to store the sample.\r\n * @param normalizeFunc - The function to normalize the texel values. Default is to divide by 255.\r\n * @returns The result color.\r\n */\r\nexport function Sample2DRgbaToRef<T extends IColor4Like>(\r\n    u: number,\r\n    v: number,\r\n    widthPx: number,\r\n    heightPx: number,\r\n    data: Uint8Array | Uint16Array | Float32Array,\r\n    result: T,\r\n    normalizeFunc = (value: number) => value / 255.0\r\n): T {\r\n    if (widthPx <= 0 || heightPx <= 0) {\r\n        throw new Error(\"Sample2DRgbaToRef: widthPx and heightPx must be positive.\");\r\n    }\r\n\r\n    const expectedLength = widthPx * heightPx * 4;\r\n    if (data.length < expectedLength) {\r\n        throw new Error(`Sample2DRgbaToRef: data length (${data.length}) is less than required (${expectedLength}).`);\r\n    }\r\n\r\n    // Default to clamping behavior, but could support others.\r\n    u = Clamp(u);\r\n    v = Clamp(v);\r\n\r\n    // Compute 4 nearest neighbor texels.\r\n    const fractionalTexelX = Math.max(u * widthPx - 0.5, 0);\r\n    const fractionalTexelY = Math.max(v * heightPx - 0.5, 0);\r\n    const xLeft = Math.floor(fractionalTexelX);\r\n    const xRight = Math.min(xLeft + 1, widthPx - 1);\r\n    const yBottom = Math.floor(fractionalTexelY);\r\n    const yTop = Math.min(yBottom + 1, heightPx - 1);\r\n\r\n    // Sample nearest neighbor texels.\r\n    const lowerLeftColor = TexelFetch2DRgbaToRef(xLeft, yBottom, widthPx, heightPx, data, TmpColor1, normalizeFunc);\r\n    const upperLeftColor = TexelFetch2DRgbaToRef(xLeft, yTop, widthPx, heightPx, data, TmpColor2, normalizeFunc);\r\n    const lowerRightColor = TexelFetch2DRgbaToRef(xRight, yBottom, widthPx, heightPx, data, TmpColor3, normalizeFunc);\r\n    const upperRightColor = TexelFetch2DRgbaToRef(xRight, yTop, widthPx, heightPx, data, TmpColor4, normalizeFunc);\r\n\r\n    // Compute weights.\r\n    const tX = fractionalTexelX - xLeft;\r\n    const tY = fractionalTexelY - yBottom;\r\n    const oneMinusTX = 1.0 - tX;\r\n    const oneMinusTY = 1.0 - tY;\r\n    const w0 = oneMinusTX * oneMinusTY;\r\n    const w1 = tX * oneMinusTY;\r\n    const w2 = oneMinusTX * tY;\r\n    const w3 = tX * tY;\r\n\r\n    // Compute the result.\r\n    result.r = lowerLeftColor.r * w0 + lowerRightColor.r * w1 + upperLeftColor.r * w2 + upperRightColor.r * w3;\r\n    result.g = lowerLeftColor.g * w0 + lowerRightColor.g * w1 + upperLeftColor.g * w2 + upperRightColor.g * w3;\r\n    result.b = lowerLeftColor.b * w0 + lowerRightColor.b * w1 + upperLeftColor.b * w2 + upperRightColor.b * w3;\r\n    result.a = lowerLeftColor.a * w0 + lowerRightColor.a * w1 + upperLeftColor.a * w2 + upperRightColor.a * w3;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Fetches a texel from a 2D texture and stores the result in the given color.\r\n * @param x - The x coordinate in texels.\r\n * @param y - The y coordinate in texels.\r\n * @param width - The width of the texture in texels.\r\n * @param height - The height of the texture in texels.\r\n * @param data - The texture data to sample from.\r\n * @param result - The color to store the sampled color in.\r\n * @param normalizeFunc - The function to normalize the texel values. Default is to divide by 255.\r\n * @returns The result color.\r\n */\r\nconst TexelFetch2DRgbaToRef = <T extends IColor4Like>(\r\n    x: number,\r\n    y: number,\r\n    width: number,\r\n    height: number,\r\n    data: Uint8Array | Uint16Array | Float32Array,\r\n    result: T,\r\n    normalizeFunc = (value: number) => value / 255.0\r\n): T => {\r\n    const clampedTexelX = Clamp(x, 0, width - 1);\r\n    const clampedTexelY = Clamp(y, 0, height - 1);\r\n    const index = 4 * (clampedTexelY * width + clampedTexelX);\r\n    result.r = normalizeFunc(data[index]);\r\n    result.g = normalizeFunc(data[index + 1]);\r\n    result.b = normalizeFunc(data[index + 2]);\r\n    result.a = normalizeFunc(data[index + 3]);\r\n    return result;\r\n};\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"atmosphereFragmentDeclaration\";\nconst shader = `uniform vec3 peakRayleighScattering;uniform float planetRadius;uniform vec3 peakMieScattering;uniform float atmosphereThickness;uniform vec3 peakMieAbsorption;uniform float planetRadiusSquared;uniform vec3 peakMieExtinction;uniform float atmosphereRadius;uniform vec3 peakOzoneAbsorption;uniform float atmosphereRadiusSquared;uniform float horizonDistanceToAtmosphereEdge;uniform float horizonDistanceToAtmosphereEdgeSquared;uniform float planetRadiusWithOffset;uniform float planetRadiusOffset;uniform float atmosphereExposure;uniform float aerialPerspectiveRadianceBias;uniform float inverseAtmosphereThickness;uniform float aerialPerspectiveTransmittanceScale;uniform mat4 inverseViewProjectionWithoutTranslation;uniform vec3 directionToLight;uniform float multiScatteringIntensity;uniform vec3 directionToLightRelativeToCameraGeocentricNormal;uniform float cameraRadius;uniform vec3 lightRadianceAtCamera;uniform float diffuseSkyIrradianceDesaturationFactor;uniform vec3 groundAlbedo;uniform float aerialPerspectiveSaturation;uniform vec3 minMultiScattering;uniform float diffuseSkyIrradianceIntensity;uniform vec3 cameraPositionGlobal;uniform float lightIntensity;uniform vec3 clampedCameraPositionGlobal;uniform float aerialPerspectiveIntensity;uniform vec3 cameraGeocentricNormal;uniform float clampedCameraRadius;uniform vec3 cameraForward;uniform float clampedCameraHeight;uniform vec3 cameraPosition;uniform float cosCameraHorizonAngleFromZenith;uniform vec4 viewport;uniform vec3 additionalDiffuseSkyIrradiance;uniform float cameraHeight;uniform float cameraNearPlane;uniform float originHeight;uniform float sinCameraAtmosphereHorizonAngleFromNadir;\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const atmosphereFragmentDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"atmosphereUboDeclaration\";\nconst shader = `layout(std140,column_major) uniform;uniform Atmosphere {vec3 peakRayleighScattering;float planetRadius;vec3 peakMieScattering;float atmosphereThickness;vec3 peakMieAbsorption;float planetRadiusSquared;vec3 peakMieExtinction;float atmosphereRadius;vec3 peakOzoneAbsorption;float atmosphereRadiusSquared;float horizonDistanceToAtmosphereEdge;float horizonDistanceToAtmosphereEdgeSquared;float planetRadiusWithOffset;float planetRadiusOffset;float atmosphereExposure;float aerialPerspectiveRadianceBias;float inverseAtmosphereThickness;float aerialPerspectiveTransmittanceScale;mat4 inverseViewProjectionWithoutTranslation;vec3 directionToLight;float multiScatteringIntensity;vec3 directionToLightRelativeToCameraGeocentricNormal;float cameraRadius;vec3 lightRadianceAtCamera;float diffuseSkyIrradianceDesaturationFactor;vec3 groundAlbedo;float aerialPerspectiveSaturation;vec3 minMultiScattering;float diffuseSkyIrradianceIntensity;vec3 cameraPositionGlobal;float lightIntensity;vec3 clampedCameraPositionGlobal;float aerialPerspectiveIntensity;vec3 cameraGeocentricNormal;float clampedCameraRadius;vec3 cameraForward;float clampedCameraHeight;vec3 cameraPosition;float cosCameraHorizonAngleFromZenith;vec4 viewport;vec3 additionalDiffuseSkyIrradiance;float cameraHeight;float cameraNearPlane;float originHeight;float sinCameraAtmosphereHorizonAngleFromNadir;};\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const atmosphereUboDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"depthFunctions\";\nconst shader = `float reconstructDistanceFromCameraPlane(float depth,float cameraNearPlane) {return cameraNearPlane/(1.0-depth);}\nfloat sampleDistanceFromCameraPlane(sampler2D depthTexture,vec2 uv,float cameraNearPlane) {float depth=textureLod(depthTexture,uv,0.).r;return depth>=1. ? 0. : reconstructDistanceFromCameraPlane(depth,cameraNearPlane);}\nfloat reconstructDistanceFromCamera(float depth,vec3 cameraRayDirection,vec3 cameraForward,float cameraNearPlane) {float distanceFromCameraPlane=reconstructDistanceFromCameraPlane(depth,cameraNearPlane);return distanceFromCameraPlane/max(0.00001,dot(cameraForward,cameraRayDirection));}\nfloat reconstructDistanceFromCamera(\nsampler2D depthTexture,\nvec2 uv,\nvec3 cameraRayDirection,\nvec3 cameraForward,\nfloat cameraNearPlane) {float depth=textureLod(depthTexture,uv,0.).r;return depth>=1. ? 0. : reconstructDistanceFromCamera(depth,cameraRayDirection,cameraForward,cameraNearPlane);}`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const depthFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"core/Shaders/ShadersInclude/intersectionFunctions\";\n\nconst name = \"atmosphereFunctions\";\nconst shader = `#include<intersectionFunctions>\nconst vec2 MultiScatteringLutSize=vec2(32.0,32.0);const vec2 MultiScatteringLutDomainInUVSpace=(MultiScatteringLutSize-vec2(1.0))/MultiScatteringLutSize;const vec2 MultiScatteringLutHalfTexelSize=vec2(0.5)/MultiScatteringLutSize;const float NumAerialPerspectiveLutLayers=32.0;const vec3 AerialPerspectiveLutSize=vec3(16.0,64.0,NumAerialPerspectiveLutLayers);const vec2 DiffuseSkyIrradianceLutSize=vec2(64.0,16.0);const vec2 DiffuseSkyIrradianceLutDomainInUVSpace=(DiffuseSkyIrradianceLutSize-vec2(1.0))/DiffuseSkyIrradianceLutSize;const vec2 DiffuseSkyIrradianceLutHalfTexelSize=vec2(0.5)/DiffuseSkyIrradianceLutSize;const vec2 SkyViewLutSize=vec2(128.0,128.0);const vec2 SkyViewLutDomainInUVSpace=(SkyViewLutSize-vec2(1.0))/SkyViewLutSize;const vec2 SkyViewLutHalfTexelSize=vec2(0.5)/SkyViewLutSize;const float AerialPerspectiveLutKMPerSlice=4.0;const float AerialPerspectiveLutRangeKM=AerialPerspectiveLutKMPerSlice*NumAerialPerspectiveLutLayers;const float TransmittanceSampleCount=128.0;const float SkyViewLutSampleCount=30.0;const vec2 TransmittanceLutSize=vec2(256.,64.);const vec2 TransmittanceLutDomainInUVSpace=(TransmittanceLutSize-vec2(1.))/TransmittanceLutSize;const vec2 TransmittanceLutHalfTexelSize=vec2(0.5)/TransmittanceLutSize;const float TransmittanceHorizonRange=2.*TransmittanceLutHalfTexelSize.x;const float TransmittanceMaxUnoccludedU=1.-0.5*TransmittanceHorizonRange;const float TransmittanceMinOccludedU=1.+0.5*TransmittanceHorizonRange;vec2 uvToUnit(vec2 uv,vec2 domainInUVSpace,vec2 halfTexelSize) {return (uv-halfTexelSize)/domainInUVSpace;}\nvec2 unitToUV(vec2 unit,vec2 domainInUVSpace,vec2 halfTexelSize) {return unit*domainInUVSpace+halfTexelSize;}\nfloat sphereIntersectNearest(vec3 rayOrigin,vec3 rayDirection,float sphereRadius) {vec2 result=sphereIntersectFromOrigin(rayOrigin,rayDirection,sphereRadius);float c=dot(rayOrigin,rayOrigin)-sphereRadius*sphereRadius;return c>=0.0 ?\nresult.y :\nresult.x;}\nvoid moveToTopAtmosphere(\nvec3 cameraPosition,\nfloat positionRadius,\nvec3 positionGeocentricNormal,\nvec3 rayDirection,\nout bool intersectsAtmosphere,\nout vec3 cameraPositionClampedToTopOfAtmosphere) {intersectsAtmosphere=true;cameraPositionClampedToTopOfAtmosphere=cameraPosition;if (positionRadius>atmosphereRadius) {float tTop=sphereIntersectNearest(cameraPosition,rayDirection,atmosphereRadius);if (tTop>=0.0) {vec3 upOffset=-planetRadiusOffset*positionGeocentricNormal;cameraPositionClampedToTopOfAtmosphere=cameraPosition+rayDirection*tTop+upOffset;} else {intersectsAtmosphere=false;}}}\nvoid getSkyViewUVFromParameters(\nbool intersectsGround,\nfloat cosHorizonAngleFromZenith,\nfloat cosAngleBetweenViewAndZenith,\nfloat cosAngleBetweenViewAndLightOnPlane,\nout vec2 uv)\n{vec2 unit=vec2(0.0);if (intersectsGround) {float coord=(cosAngleBetweenViewAndZenith+1.0)/(cosHorizonAngleFromZenith+1.0);coord=sqrtClamped(coord); \nunit.y=0.5*coord; } else {float coord=(cosAngleBetweenViewAndZenith-cosHorizonAngleFromZenith)/(1.0-cosHorizonAngleFromZenith);coord=sqrtClamped(coord); \nunit.y=0.5*coord+0.5; }\n{float coord=0.5-0.5*cosAngleBetweenViewAndLightOnPlane;unit.x=coord;}\nuv=unitToUV(unit,SkyViewLutDomainInUVSpace,SkyViewLutHalfTexelSize);}\n#if USE_SKY_VIEW_LUT && SAMPLE_SKY_VIEW_LUT\n#define inline\nvec4 sampleSkyViewLut(\nsampler2D skyViewLut,\nfloat positionRadius,\nvec3 geocentricNormal,\nvec3 rayDirection,\nvec3 directionToLight,\nfloat cosHorizonAngleFromZenith,\nout float cosAngleBetweenViewAndZenith,\nout bool isRayIntersectingGround) {cosAngleBetweenViewAndZenith=dot(rayDirection,geocentricNormal);if (positionRadius>atmosphereRadius) {float sinAngleBetweenViewAndNadir=sqrtClamped(1.-cosAngleBetweenViewAndZenith*cosAngleBetweenViewAndZenith);if (sinAngleBetweenViewAndNadir>sinCameraAtmosphereHorizonAngleFromNadir) {isRayIntersectingGround=false;return vec4(0.);}}\nvec3 sideVector=normalize(cross(geocentricNormal,rayDirection));vec3 forwardVector=normalize(cross(sideVector,geocentricNormal));vec2 lightOnPlane=normalize(vec2(dot(directionToLight,forwardVector),dot(directionToLight,sideVector)));float cosAngleBetweenViewAndLightOnPlane=lightOnPlane.x;float rayIntersectionScale=mix(0.95,1.,saturate((positionRadius-planetRadius)/atmosphereThickness));isRayIntersectingGround =\npositionRadius>planetRadius &&\n(rayIntersectionScale*cosAngleBetweenViewAndZenith)<=cosHorizonAngleFromZenith;vec2 uv;getSkyViewUVFromParameters(\nisRayIntersectingGround,\ncosHorizonAngleFromZenith,\ncosAngleBetweenViewAndZenith,\ncosAngleBetweenViewAndLightOnPlane,\nuv);return textureLod(skyViewLut,uv,0.);}\n#endif\nfloat computeRayleighPhase(float onePlusCosThetaSq) {return 0.0596831037*onePlusCosThetaSq;}\nfloat computeMiePhaseCornetteShanks(float cosTheta,float onePlusCosThetaSq) {const float g=0.8;const float gSquared=g*g;const float oneMinusGSquared=1.-gSquared;const float onePlusGSquared=1.+gSquared;const float twoPlusGSquared=2.+gSquared;const float twoG=2.*g;const float threeOverEightPi=3./(8.*PI);return threeOverEightPi*oneMinusGSquared*onePlusCosThetaSq/(twoPlusGSquared*pow(onePlusGSquared-twoG*cosTheta,1.5));}\nfloat computeOzoneDensity(float normalizedViewHeight) {const float MinOzoneDensity=0.135;const float OneMinusMinOzoneDensity=1.-MinOzoneDensity;const float OzoneStartHeight=.15; \nconst float PeakOzoneHeight=.25;const float MaxOzoneHeight=0.6;const float InverseRampupDistance=1./(PeakOzoneHeight-OzoneStartHeight);const float InverseRampdownDistance=1./(MaxOzoneHeight-PeakOzoneHeight);float lowerAtmosphereDensity=MinOzoneDensity+OneMinusMinOzoneDensity*max(0.,normalizedViewHeight-OzoneStartHeight)*InverseRampupDistance;float sqrtUpperAtmosphereDensity=max(0.,1.-(normalizedViewHeight-PeakOzoneHeight)*InverseRampdownDistance);float upperAtmosphereDensity=sqrtUpperAtmosphereDensity*sqrtUpperAtmosphereDensity;float densityOzone=normalizedViewHeight<PeakOzoneHeight ? lowerAtmosphereDensity : upperAtmosphereDensity;return densityOzone;}\nvoid sampleMediumRGB(\nfloat viewHeight,\nout vec3 scatteringRayleigh,\nout vec3 scatteringMie,\nout vec3 extinction,\nout vec3 scattering) {float normalizedViewHeight=saturate(viewHeight*inverseAtmosphereThickness);float densityMie=exp(-83.333*normalizedViewHeight);float densityRayleigh=exp(-12.5*normalizedViewHeight);float densityOzone=computeOzoneDensity(normalizedViewHeight);scatteringRayleigh=densityRayleigh*peakRayleighScattering;scatteringMie=densityMie*peakMieScattering;scattering=scatteringMie+scatteringRayleigh;vec3 extinctionRayleigh=scatteringRayleigh;vec3 extinctionMie=densityMie*peakMieExtinction;vec3 extinctionOzone=densityOzone*peakOzoneAbsorption;extinction=extinctionRayleigh+extinctionMie+extinctionOzone;}\nvec3 computeTransmittance(vec3 rayOriginGlobal,vec3 rayDirection,float tMax,float sampleCount) {vec3 opticalDepth=vec3(0.);float t=0.;float sampleSegmentWeight=tMax/sampleCount;const float sampleSegmentT=0.3;for (float s=0.; s<sampleCount; s+=1.) {float newT=sampleSegmentWeight*(s+sampleSegmentT);float dt=newT-t;t=newT;vec3 scatteringRayleigh,scatteringMie,extinction,scattering;vec3 samplePositionGlobal=rayOriginGlobal+t*rayDirection;sampleMediumRGB(length(samplePositionGlobal)-planetRadius,scatteringRayleigh,scatteringMie,extinction,scattering);opticalDepth+=extinction*dt;}\nreturn exp(-opticalDepth);}\n#if defined(SAMPLE_TRANSMITTANCE_LUT) || !defined(EXCLUDE_RAY_MARCHING_FUNCTIONS)\nvec2 getTransmittanceUV(float radius,float cosAngleLightToZenith,out float distanceToHorizon) {float radiusSquared=radius*radius;distanceToHorizon=sqrtClamped(radiusSquared-planetRadiusSquared);float cosAngleLightToZenithSquared=cosAngleLightToZenith*cosAngleLightToZenith;float discriminant=radiusSquared*(cosAngleLightToZenithSquared-1.)+atmosphereRadiusSquared;float distanceToAtmosphereEdge=max(0.,-radius*cosAngleLightToZenith+sqrtClamped(discriminant));float minDistanceToAtmosphereEdge=max(0.,atmosphereRadius-radius);float maxDistanceToAtmosphereEdge=distanceToHorizon+horizonDistanceToAtmosphereEdge;float cosAngleLightToZenithCoordinate=(distanceToAtmosphereEdge-minDistanceToAtmosphereEdge)/max(0.000001,maxDistanceToAtmosphereEdge-minDistanceToAtmosphereEdge);float distanceToHorizonCoordinate=distanceToHorizon/max(0.000001,horizonDistanceToAtmosphereEdge);vec2 unit=vec2(cosAngleLightToZenithCoordinate,distanceToHorizonCoordinate);return unit*TransmittanceLutDomainInUVSpace+TransmittanceLutHalfTexelSize; }\n#define inline\nvec4 sampleTransmittanceLut(sampler2D transmittanceLut,float positionRadius,float cosAngleLightToZenith) {float distanceToHorizon;vec2 uv=getTransmittanceUV(positionRadius,cosAngleLightToZenith,distanceToHorizon);float weight=smoothstep(TransmittanceMinOccludedU,TransmittanceMaxUnoccludedU,uv.x);return weight*textureLod(transmittanceLut,uv,0.);}\n#endif\n#ifndef EXCLUDE_RAY_MARCHING_FUNCTIONS\n#define inline\nvec3 sampleMultiScatteringLut(sampler2D multiScatteringLut,float radius,float cosAngleLightToZenith) {vec2 unit=vec2(0.5+0.5*cosAngleLightToZenith,(radius-planetRadius)/atmosphereThickness);vec2 uv=unitToUV(unit,MultiScatteringLutDomainInUVSpace,MultiScatteringLutHalfTexelSize);vec3 multiScattering=textureLod(multiScatteringLut,uv,0.).rgb;return max(minMultiScattering,multiScattering);}\nconst float uniformPhase=RECIPROCAL_PI4;\n#define inline\nvoid integrateScatteredRadiance(\nbool isAerialPerspectiveLut,\nfloat lightIntensity,\nsampler2D transmittanceLut,\n#ifndef COMPUTE_MULTI_SCATTERING\nsampler2D multiScatteringLut,\nfloat multiScatteringIntensity,\n#endif\nvec3 rayOriginGlobal,\nvec3 rayDirection,\nvec3 directionToLight,\nfloat tMaxMax,\nfloat sampleCount,\nfloat distanceToSurface,\nout vec3 radiance,\nout vec3 transmittance\n#if COMPUTE_MULTI_SCATTERING\n,out vec3 multiScattering\n#endif\n) {radiance=vec3(0.);transmittance=vec3(1.);\n#if COMPUTE_MULTI_SCATTERING\nmultiScattering=vec3(0.);\n#endif\nfloat tBottom=sphereIntersectNearest(rayOriginGlobal,rayDirection,planetRadius);float tTop=sphereIntersectNearest(rayOriginGlobal,rayDirection,atmosphereRadius);float tMax=0.;if (tBottom<0.) {if (tTop<0.) {return;} else {tMax=tTop;}} else {if (tTop>0.) {if (isAerialPerspectiveLut) {tMax=tTop;} else {tMax=min(tBottom,tTop);}}}\nif (distanceToSurface>0. && distanceToSurface<tMax) {tMax=distanceToSurface;}\ntMax=min(tMax,tMaxMax);\n#ifndef COMPUTE_MULTI_SCATTERING\nfloat cosTheta=dot(rayDirection,directionToLight);float onePlusCosThetaSq=1.+cosTheta*cosTheta;float rayleighPhase=computeRayleighPhase(onePlusCosThetaSq);float miePhase=computeMiePhaseCornetteShanks(cosTheta,onePlusCosThetaSq);\n#endif\nfloat transmittanceScale=isAerialPerspectiveLut ? aerialPerspectiveTransmittanceScale : 1.;float t=0.;float sampleSegmentWeight=tMax/sampleCount;const float sampleSegmentT=0.3;for (float s=0.; s<sampleCount; s+=1.) {float newT=sampleSegmentWeight*(s+sampleSegmentT);float dt=newT-t;t=newT;vec3 samplePositionGlobal=rayOriginGlobal+t*rayDirection;float sampleRadiusGlobal=length(samplePositionGlobal);vec3 sampleGeocentricNormal=samplePositionGlobal/sampleRadiusGlobal;float sampleCosAngleLightToZenith=dot(directionToLight,sampleGeocentricNormal);vec3 scatteringRayleigh,scatteringMie,extinction,scattering;sampleMediumRGB(sampleRadiusGlobal-planetRadius,scatteringRayleigh,scatteringMie,extinction,scattering);vec3 transmittanceToLight=sampleTransmittanceLut(transmittanceLut,sampleRadiusGlobal,sampleCosAngleLightToZenith).rgb;\n#if COMPUTE_MULTI_SCATTERING\nvec3 phaseTimesScattering=uniformPhase*scattering;vec3 S=transmittanceToLight*phaseTimesScattering;\n#else\nvec3 phaseTimesScattering=scatteringMie*miePhase+scatteringRayleigh*rayleighPhase;vec3 multiScatteredRadiance=sampleMultiScatteringLut(multiScatteringLut,sampleRadiusGlobal,sampleCosAngleLightToZenith);vec3 S=transmittanceScale*transmittanceToLight*phaseTimesScattering+multiScatteringIntensity*multiScatteredRadiance*scattering;\n#endif\nvec3 sampleOpticalDepth=extinction*dt;vec3 sampleTransmittance=exp(-sampleOpticalDepth);vec3 clampedExtinction=max(vec3(0.0000001),extinction);vec3 SInt=(S-S*sampleTransmittance)/clampedExtinction;radiance+=transmittance*SInt;\n#if COMPUTE_MULTI_SCATTERING\nvec3 MSInt=(scattering-scattering*sampleTransmittance)/clampedExtinction;multiScattering+=transmittance*MSInt;\n#endif\ntransmittance*=sampleTransmittance;}\n#if USE_GROUND_ALBEDO\nif (tMax==tBottom && tBottom>0.) {vec3 planetPos=rayOriginGlobal+tBottom*rayDirection;float planetPosRadius=length(planetPos);vec3 planetPosGeocentricNormal=planetPos/planetPosRadius;float nDotL=dot(directionToLight,planetPosGeocentricNormal);vec3 lightTransmittance=sampleTransmittanceLut(transmittanceLut,planetPosRadius,nDotL).rgb;const float diffuseBrdf=RECIPROCAL_PI;radiance+=lightTransmittance*transmittance*groundAlbedo*(nDotL*diffuseBrdf);}\n#endif\nradiance*=lightIntensity;}\n#endif\nfloat layerIdxToAerialPerspectiveLayer(float layerIdx) {float layer=(layerIdx+1.)/NumAerialPerspectiveLutLayers;layer*=layer; \nlayer*=NumAerialPerspectiveLutLayers;return layer;}\nfloat toAerialPerspectiveDepth(float layer) {return layer*AerialPerspectiveLutKMPerSlice;}\nfloat toAerialPerspectiveLayer(float distance,float aerialPerspectiveLutDistancePerSlice) {return distance/aerialPerspectiveLutDistancePerSlice;}\nvec4 applyAerialPerspectiveSaturation(vec4 aerialPerspective) {float previousRadiance=getLuminance(aerialPerspective.rgb);aerialPerspective.rgb=mix(vec3(previousRadiance),aerialPerspective.rgb,aerialPerspectiveSaturation);return aerialPerspective;}\nvec4 applyAerialPerspectiveIntensity(vec4 aerialPerspective) {\n#if APPLY_AERIAL_PERSPECTIVE_INTENSITY\nif (aerialPerspectiveIntensity==0.) {aerialPerspective=vec4(0.);} else {float previousAlpha=aerialPerspective.a;aerialPerspective/=max(0.00001,previousAlpha);aerialPerspective*=pow(previousAlpha,1./aerialPerspectiveIntensity);}\n#endif\nreturn aerialPerspective;}\nvec4 applyAerialPerspectiveRadianceBias(vec4 aerialPerspective) {\n#if APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS\nfloat originalRadiance=dot(aerialPerspective.rgb,LuminanceEncodeApprox);float targetRadiance=originalRadiance+aerialPerspectiveRadianceBias;if (originalRadiance>0.) {aerialPerspective*=max(0.,targetRadiance/originalRadiance);} else {aerialPerspective=max(vec4(0.),vec4(aerialPerspectiveRadianceBias));}\naerialPerspective.a=min(aerialPerspective.a,1.);\n#endif\nreturn aerialPerspective;}\nbool sampleAerialPerspectiveLut(\nvec2 screenUV,\nbool clampToLutRange,\nfloat distanceFromCamera,\nfloat numAerialPerspectiveLutLayers,\nfloat aerialPerspectiveLutKMPerSlice,\nfloat aerialPerspectiveLutRangeKM,\nout vec4 aerialPerspective) {aerialPerspective=vec4(0.);\n#if USE_AERIAL_PERSPECTIVE_LUT\nif (distanceFromCamera>0. &&\n(clampToLutRange || distanceFromCamera<aerialPerspectiveLutRangeKM) &&\nclampedCameraRadius<=atmosphereRadius) {float layer=toAerialPerspectiveLayer(distanceFromCamera,aerialPerspectiveLutKMPerSlice);float normalizedLayer=sqrt(layer/numAerialPerspectiveLutLayers); \nlayer=min(normalizedLayer*numAerialPerspectiveLutLayers,numAerialPerspectiveLutLayers);float weight=min(layer,1.);float layerIdx=max(0.,layer-1.);float floorLayerIdx=floor(layerIdx);vec4 aerialPerspectiveLayer0=textureLod(aerialPerspectiveLut,vec3(screenUV,floorLayerIdx),0.);vec4 aerialPerspectiveLayer1=textureLod(aerialPerspectiveLut,vec3(screenUV,floorLayerIdx+1.),0.);aerialPerspective=mix(aerialPerspectiveLayer0,aerialPerspectiveLayer1,layerIdx-floorLayerIdx);aerialPerspective.rgb*=atmosphereExposure;aerialPerspective=applyAerialPerspectiveSaturation(aerialPerspective);aerialPerspective=weight*applyAerialPerspectiveIntensity(aerialPerspective);aerialPerspective=applyAerialPerspectiveRadianceBias(aerialPerspective);return true;}\n#endif\nreturn false;}\n#if RENDER_TRANSMITTANCE\nvoid getTransmittanceParameters(vec2 uv,out float radius,out float cosAngleLightToZenith,out float distanceToAtmosphereEdge) {vec2 unit=uvToUnit(uv,TransmittanceLutDomainInUVSpace,TransmittanceLutHalfTexelSize);float distanceToHorizon=unit.y*horizonDistanceToAtmosphereEdge;float distanceToHorizonSquared=distanceToHorizon*distanceToHorizon;radius=sqrtClamped(distanceToHorizonSquared+planetRadiusSquared);float minDistanceToAtmosphereEdge=atmosphereRadius-radius;float maxDistanceToAtmosphereEdge=distanceToHorizon+horizonDistanceToAtmosphereEdge;distanceToAtmosphereEdge=minDistanceToAtmosphereEdge+unit.x*(maxDistanceToAtmosphereEdge-minDistanceToAtmosphereEdge);float distanceToAtmosphereEdgeSquared=distanceToAtmosphereEdge*distanceToAtmosphereEdge;cosAngleLightToZenith =\ndistanceToAtmosphereEdge<=0. ?\n1. :\n(horizonDistanceToAtmosphereEdgeSquared-distanceToAtmosphereEdgeSquared-distanceToHorizonSquared)/(2.*radius*distanceToAtmosphereEdge);cosAngleLightToZenith=clamp(cosAngleLightToZenith,-1.,1.);}\nvec4 renderTransmittance(vec2 uv) {float radius,cosAngleLightToZenith,distanceToAtmosphereEdgeAlongAngle;getTransmittanceParameters(uv,radius,cosAngleLightToZenith,distanceToAtmosphereEdgeAlongAngle);float sinAngleLightToZenith=sqrtClamped(1.-cosAngleLightToZenith*cosAngleLightToZenith);vec3 directionToLight=normalize(vec3(0.,cosAngleLightToZenith,sinAngleLightToZenith));vec3 transmittance=computeTransmittance(vec3(0.,radius,0.),directionToLight,distanceToAtmosphereEdgeAlongAngle,TransmittanceSampleCount);return vec4(transmittance,avg(transmittance));}\n#endif\n#if RENDER_MULTI_SCATTERING\nvec3 getSphereSample(float azimuth,float inclination,out float sinInclination) {sinInclination=sin(inclination);return vec3(sinInclination*sin(azimuth),cos(inclination),sinInclination*cos(azimuth));}\nconst float MultiScatteringInclinationSampleCount=8.;const float MultiScatteringAzimuthSampleCount=2.*MultiScatteringInclinationSampleCount;const float MultiScatteringLutSampleCount=64.;const float MultiScatteringAzimuthIterationAngle=TWO_PI/MultiScatteringAzimuthSampleCount;const float MultiScatteringInclinationIterationAngle=PI/MultiScatteringInclinationSampleCount;const float MultiScatteringAngleStepProduct=MultiScatteringAzimuthIterationAngle*MultiScatteringInclinationIterationAngle;\n#define inline\nvec4 renderMultiScattering(vec2 uv,sampler2D transmittanceLut) {vec2 unit=uvToUnit(uv,MultiScatteringLutDomainInUVSpace,MultiScatteringLutHalfTexelSize);float cosAngleLightToZenith=2.*unit.x-1.;float sinAngleLightToZenith=sqrtClamped(1.-cosAngleLightToZenith*cosAngleLightToZenith);vec3 directionToLight=normalize(vec3(0.,cosAngleLightToZenith,sinAngleLightToZenith));float rayOriginRadius=planetRadius+max(unit.y,0.001)*atmosphereThickness;vec3 rayOrigin=vec3(0.,rayOriginRadius,0.);vec3 inscattered=vec3(0.);vec3 multiScatteringTotal=vec3(0.);for (float i=0.5; i<MultiScatteringAzimuthSampleCount; ++i) {float azimuth=MultiScatteringAzimuthIterationAngle*i;for (float j=0.5; j<MultiScatteringInclinationSampleCount; ++j) {float inclination=MultiScatteringInclinationIterationAngle*j;float sinInclination;vec3 rayDirection=getSphereSample(azimuth,inclination,sinInclination);vec3 radiance;vec3 transmittance;vec3 multiScattering;integrateScatteredRadiance(\nfalse,\n1.,\ntransmittanceLut,\nrayOrigin,\nrayDirection,\ndirectionToLight,\n100000000.,\nMultiScatteringLutSampleCount,\n-1.,\nradiance,\ntransmittance,\nmultiScattering);float weight=RECIPROCAL_PI4*abs(sinInclination)*MultiScatteringAngleStepProduct;multiScatteringTotal+=multiScattering*weight;inscattered+=radiance*weight;}}\nvec3 multiScattering=inscattered/max(vec3(0.000001),vec3(1.)-multiScatteringTotal);return vec4(multiScattering,1.);}\n#endif\nfloat computeCosHorizonAngleFromZenith(float radius) {float sinAngleBetweenHorizonAndNadir=min(1.,planetRadius/radius);float cosHorizonAngleFromNadir=sqrt(1.-sinAngleBetweenHorizonAndNadir*sinAngleBetweenHorizonAndNadir);float cosHorizonAngleFromZenith=-cosHorizonAngleFromNadir;return cosHorizonAngleFromZenith;}\n#if RENDER_SKY_VIEW\nvoid getSkyViewParametersFromUV(\nfloat radius,\nvec2 uv,\nout float cosAngleBetweenViewAndZenith,\nout float cosAngleBetweenViewAndLightOnPlane) {vec2 unit=uvToUnit(uv,SkyViewLutDomainInUVSpace,SkyViewLutHalfTexelSize);float cosHorizonAngleFromZenith=computeCosHorizonAngleFromZenith(radius);if (unit.y<0.5) {float coord=2.*unit.y; \ncoord*=coord; \ncosAngleBetweenViewAndZenith=mix(-1.,cosHorizonAngleFromZenith,coord); } else {float coord=2.*unit.y-1.; \ncoord*=coord; \ncosAngleBetweenViewAndZenith=mix(cosHorizonAngleFromZenith,1.,coord); }\n{float coord=unit.x;cosAngleBetweenViewAndLightOnPlane=1.-2.*coord;}}\n#define inline\nvec4 renderSkyView(vec2 uv,sampler2D transmittanceLut,sampler2D multiScatteringLut) {float cosAngleBetweenViewAndZenith;float cosAngleBetweenViewAndLightOnPlane;getSkyViewParametersFromUV(clampedCameraRadius,uv,cosAngleBetweenViewAndZenith,cosAngleBetweenViewAndLightOnPlane);float sinAngleBetweenViewAndZenith=sqrtClamped(1.-cosAngleBetweenViewAndZenith*cosAngleBetweenViewAndZenith);float sinAngleBetweenViewAndLightOnPlane=sqrtClamped(1.-cosAngleBetweenViewAndLightOnPlane*cosAngleBetweenViewAndLightOnPlane);vec3 rayDirection =\nvec3(\nsinAngleBetweenViewAndZenith*cosAngleBetweenViewAndLightOnPlane,\ncosAngleBetweenViewAndZenith,\nsinAngleBetweenViewAndZenith*sinAngleBetweenViewAndLightOnPlane);bool intersectsAtmosphere=false;vec3 cameraPositionGlobalClampedToTopOfAtmosphere=vec3(0.);moveToTopAtmosphere(\nvec3(0.,clampedCameraRadius,0.),\nclampedCameraRadius,\nvec3(0.,1.,0.),\nrayDirection,\nintersectsAtmosphere,\ncameraPositionGlobalClampedToTopOfAtmosphere);if (!intersectsAtmosphere) {return vec4(0.);}\nvec3 transmittance;vec3 radiance;integrateScatteredRadiance(\nfalse,\natmosphereExposure*lightIntensity,\ntransmittanceLut,\nmultiScatteringLut,\nmultiScatteringIntensity,\ncameraPositionGlobalClampedToTopOfAtmosphere,\nrayDirection,\ndirectionToLightRelativeToCameraGeocentricNormal,\n100000000.,\nSkyViewLutSampleCount,\n-1.,\nradiance,\ntransmittance);float transparency=1.-avg(transmittance);return vec4(radiance,transparency);}\n#endif\n#if RENDER_CAMERA_VOLUME\n#define inline\nvec4 renderCameraVolume(\nvec3 positionOnNearPlane,\nfloat layerIdx,\nsampler2D transmittanceLut,\nsampler2D multiScatteringLut) {vec4 result=vec4(0.);vec3 rayDirection=normalize(positionOnNearPlane);float layer=layerIdxToAerialPerspectiveLayer(layerIdx);float tMax=toAerialPerspectiveDepth(layer);float tMaxMax=tMax;vec3 cameraPositionGlobalClampedToTopOfAtmosphere=clampedCameraPositionGlobal;if (clampedCameraRadius>=atmosphereRadius) {bool intersectsAtmosphere=false;moveToTopAtmosphere(\nclampedCameraPositionGlobal,\nclampedCameraRadius,\ncameraGeocentricNormal,\nrayDirection,\nintersectsAtmosphere,\ncameraPositionGlobalClampedToTopOfAtmosphere);if (!intersectsAtmosphere) {return result;}\nfloat distanceToAtmosphere=distance(clampedCameraPositionGlobal,cameraPositionGlobalClampedToTopOfAtmosphere);if (tMaxMax<distanceToAtmosphere) {return result;}\ntMaxMax=max(0.,tMaxMax-distanceToAtmosphere);}\nfloat sampleCount=min(SkyViewLutSampleCount,2.*layer+2.);vec3 transmittance;vec3 radiance;integrateScatteredRadiance(\ntrue,\nlightIntensity,\ntransmittanceLut,\nmultiScatteringLut,\nmultiScatteringIntensity,\ncameraPositionGlobalClampedToTopOfAtmosphere,\nrayDirection,\ndirectionToLight,\ntMaxMax,\nsampleCount,\n-1.,\nradiance,\ntransmittance);float transparency=1.-avg(transmittance);result=vec4(radiance,transparency);return result;}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const atmosphereFunctions = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"../Shaders/ShadersInclude/depthFunctions\";\nimport \"../Shaders/ShadersInclude/atmosphereFunctions\";\nimport \"core/Shaders/ShadersInclude/importanceSampling\";\nimport \"core/Shaders/ShadersInclude/pbrBRDFFunctions\";\nimport \"core/Shaders/ShadersInclude/hdrFilteringFunctions\";\n\nconst name = \"diffuseSkyIrradiancePixelShader\";\nconst shader = `precision highp float;const float DiffuseSkyIrradianceLutSampleCount=32.0;\n#include<__decl__atmosphereFragment>\nuniform sampler2D transmittanceLut;uniform sampler2D multiScatteringLut;\n#include<helperFunctions>\n#include<depthFunctions>\n#include<atmosphereFunctions>\nvec3 integrateForIrradiance(vec3 directionToLight,vec3 rayDirection,vec3 rayOrigin) {vec3 radiance;vec3 transmittance;integrateScatteredRadiance(\nfalse,\n1.,\ntransmittanceLut,\nmultiScatteringLut,\nmultiScatteringIntensity,\nrayOrigin,\nrayDirection.xzy,\ndirectionToLight.xzy,\n100000000.,\nDiffuseSkyIrradianceLutSampleCount,\n-1.,\nradiance,\ntransmittance);return radiance;}\n#include<importanceSampling>\n#include<pbrBRDFFunctions>\n#include<hdrFilteringFunctions>\nvarying vec2 uv;void main() {vec2 unit=uvToUnit(uv,DiffuseSkyIrradianceLutDomainInUVSpace,DiffuseSkyIrradianceLutHalfTexelSize);float cosLightInclination=2.*unit.x-1.;float sinLightInclination=sqrtClamped(1.-cosLightInclination*cosLightInclination);vec3 directionToLight=normalize(vec3(0.,cosLightInclination,sinLightInclination));float radius=max(planetRadiusWithOffset,unit.y*atmosphereThickness+planetRadius);vec3 swappedDirectionToLight=vec3(directionToLight.x,directionToLight.z,directionToLight.y); \nvec3 irradiance=PI*irradiance(\nswappedDirectionToLight,\nvec2(radius,0.),\n1.,\nvec3(1.),\nvec3(1.));float averageIrradiance=getLuminance(irradiance);vec3 newIrradiance=mix(irradiance,vec3(averageIrradiance),diffuseSkyIrradianceDesaturationFactor);float newIrradianceScale=getLuminance(newIrradiance);float rescaling=averageIrradiance/max(0.000001,newIrradianceScale);irradiance=newIrradiance*rescaling;gl_FragColor=vec4(irradiance,1.);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const diffuseSkyIrradiancePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\n\nconst name = \"fullscreenTriangleVertexShader\";\nconst shader = `precision highp float;\n#include<__decl__atmosphereFragment>\n#if POSITION_VEC2\nattribute vec2 position;\n#else\nattribute vec3 position;\n#endif\nuniform float depth;varying vec2 uv;\n#if COMPUTE_WORLD_RAY\nvarying vec3 positionOnNearPlane;\n#endif\n#if COMPUTE_WORLD_RAY\nconst float nearPlaneNDC=-1.;\n#endif\nvoid main() {gl_Position=vec4(position.xy,depth,1.);uv=0.5*position.xy+vec2(0.5);\n#if COMPUTE_WORLD_RAY\npositionOnNearPlane=(inverseViewProjectionWithoutTranslation*vec4(position.xy,nearPlaneNDC,1.)).xyz;\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const fullscreenTriangleVertexShader = { name, shader };\n","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { Atmosphere } from \"./atmosphere\";\r\nimport type { AtmospherePhysicalProperties } from \"./atmospherePhysicalProperties\";\r\nimport { Clamp } from \"core/Maths/math.scalar.functions\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { EffectRenderer, EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport { FromHalfFloat } from \"core/Misc/textureTools\";\r\nimport type { IColor3Like, IColor4Like, IVector2Like, IVector3Like } from \"core/Maths/math.like\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport { Sample2DRgbaToRef } from \"./sampling\";\r\nimport { Vector3Dot } from \"core/Maths/math.vector.functions\";\r\nimport \"./Shaders/diffuseSkyIrradiance.fragment\";\r\nimport \"./Shaders/fullscreenTriangle.vertex\";\r\n\r\nconst RaySamples = 128;\r\nconst LutWidthPx = 64;\r\nconst LutHeightPx = 16;\r\nconst HalfTexelSize = { x: 0.5 / LutWidthPx, y: 0.5 / LutHeightPx };\r\nconst UnitToUVScale = { x: (LutWidthPx - 1.0) / LutWidthPx, y: (LutHeightPx - 1.0) / LutHeightPx };\r\nconst UvTemp = { x: Number.NaN, y: Number.NaN };\r\nconst Color4Temp = { r: Number.NaN, g: Number.NaN, b: Number.NaN, a: Number.NaN } as IColor4Like;\r\n\r\nconst ComputeLutUVToRef = (properties: AtmospherePhysicalProperties, radius: number, cosAngleLightToZenith: number, result: IVector2Like): void => {\r\n    const unitX = Clamp(0.5 + 0.5 * cosAngleLightToZenith);\r\n    const unitY = Clamp((radius - properties.planetRadius) / properties.atmosphereThickness);\r\n    result.x = unitX * UnitToUVScale.x + HalfTexelSize.x;\r\n    result.y = unitY * UnitToUVScale.y + HalfTexelSize.y;\r\n};\r\n\r\n/**\r\n * The diffuse sky irradiance LUT is used to query the diffuse irradiance at a specified position.\r\n */\r\nexport class DiffuseSkyIrradianceLut {\r\n    private readonly _atmosphere: Atmosphere;\r\n    private _renderTarget: Nullable<RenderTargetTexture> = null;\r\n    private _effectWrapper: Nullable<EffectWrapper> = null;\r\n    private _effectRenderer: Nullable<EffectRenderer> = null;\r\n    private _isDirty = true;\r\n    private _isDisposed = false;\r\n    private _lutData: Uint8Array | Uint16Array = new Uint16Array(0);\r\n\r\n    /**\r\n     * True if the LUT needs to be rendered.\r\n     */\r\n    public get isDirty() {\r\n        return this._isDirty;\r\n    }\r\n\r\n    /**\r\n     * True if the LUT has been disposed.\r\n     */\r\n    public get isDisposed(): boolean {\r\n        return this._isDisposed;\r\n    }\r\n\r\n    /**\r\n     * The render target used for this LUT.\r\n     * @throws if the LUT has been disposed.\r\n     */\r\n    public get renderTarget(): RenderTargetTexture {\r\n        if (this._isDisposed || this._renderTarget === null) {\r\n            throw new Error();\r\n        }\r\n        return this._renderTarget;\r\n    }\r\n\r\n    /**\r\n     * True if the LUT data has been read back from the GPU.\r\n     */\r\n    public get hasLutData(): boolean {\r\n        return this._lutData[0] !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Constructs the {@link DiffuseSkyIrradianceLut}.\r\n     * @param atmosphere - The atmosphere to use.\r\n     */\r\n    constructor(atmosphere: Atmosphere) {\r\n        this._atmosphere = atmosphere;\r\n        const scene = atmosphere.scene;\r\n        const engine = scene.getEngine();\r\n\r\n        const name = \"atmo-diffuseSkyIrradiance\";\r\n        const caps = engine.getCaps();\r\n        const textureType = caps.textureHalfFloatRender ? Constants.TEXTURETYPE_HALF_FLOAT : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        const renderTarget = (this._renderTarget = new RenderTargetTexture(name, { width: LutWidthPx, height: LutHeightPx }, scene, {\r\n            generateMipMaps: false,\r\n            type: textureType,\r\n            samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n            generateDepthBuffer: false,\r\n            gammaSpace: false,\r\n        }));\r\n        renderTarget.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        renderTarget.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        renderTarget.anisotropicFilteringLevel = 1;\r\n        renderTarget.skipInitialClear = true;\r\n\r\n        const atmosphereUbo = atmosphere.uniformBuffer;\r\n        const useUbo = atmosphereUbo.useUbo;\r\n\r\n        const heightParam = engine.isWebGPU ? \"radius\" : \"filteringInfo.x\";\r\n        this._effectWrapper = new EffectWrapper({\r\n            engine,\r\n            name,\r\n            vertexShader: \"fullscreenTriangle\",\r\n            fragmentShader: \"diffuseSkyIrradiance\",\r\n            attributeNames: [\"position\"],\r\n            uniformNames: [\"depth\", ...(useUbo ? [] : atmosphereUbo.getUniformNames())],\r\n            uniformBuffers: useUbo ? [atmosphereUbo.name] : [],\r\n            defines: [\r\n                \"#define POSITION_VEC2\",\r\n                `#define NUM_SAMPLES ${RaySamples}u`,\r\n                \"#define CUSTOM_IRRADIANCE_FILTERING_INPUT /* empty */\", // empty, no input texture needed as the radiance is procedurally generated from ray marching.\r\n                // The following ray marches the atmosphere to get the radiance.\r\n                `#define CUSTOM_IRRADIANCE_FILTERING_FUNCTION vec3 c = integrateForIrradiance(n, Ls, vec3(0., ${heightParam}, 0.));`,\r\n            ],\r\n            samplers: [\"transmittanceLut\", \"multiScatteringLut\"],\r\n            useShaderStore: true,\r\n        });\r\n\r\n        this._effectRenderer = new EffectRenderer(engine, {\r\n            // Full screen triangle.\r\n            indices: [0, 2, 1],\r\n            positions: [-1, -1, -1, 3, 3, -1],\r\n        });\r\n\r\n        // The sky irradiance will also be used for the environment texture.\r\n        scene.environmentTexture = renderTarget;\r\n        scene.environmentTexture.irradianceTexture = renderTarget;\r\n        scene.environmentIntensity = 1.0;\r\n\r\n        // Prevent the irradiance LUT from being rendered redundantly at the beginning of the frame.\r\n        scene.environmentTexture.isRenderTarget = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the diffuse sky irradiance for a surface oriented along the geocentric normal.\r\n     * Resulting color is always in linear space.\r\n     * @param directionToLight - The direction to the light in world space.\r\n     * @param radius - The position's distance to the planet origin.\r\n     * @param cameraGeocentricNormal - The geocentric normal of the camera.\r\n     * @param lightIrradiance - The irradiance of the light.\r\n     * @param result - The color to store the result in.\r\n     * @returns The result color.\r\n     */\r\n    public getDiffuseSkyIrradianceToRef<T extends IColor3Like>(\r\n        directionToLight: IVector3Like,\r\n        radius: number,\r\n        cameraGeocentricNormal: IVector3Like,\r\n        lightIrradiance: number,\r\n        result: T\r\n    ): T {\r\n        const atmosphere = this._atmosphere;\r\n        const additionalDiffuseSkyIrradiance = atmosphere.additionalDiffuseSkyIrradiance;\r\n\r\n        const properties = atmosphere.physicalProperties;\r\n        if (this._lutData[0] === undefined || radius > properties.atmosphereRadius) {\r\n            result.r = additionalDiffuseSkyIrradiance.r;\r\n            result.g = additionalDiffuseSkyIrradiance.g;\r\n            result.b = additionalDiffuseSkyIrradiance.b;\r\n            return result;\r\n        }\r\n\r\n        const cosAngleLightToZenith = Vector3Dot(directionToLight, cameraGeocentricNormal);\r\n        ComputeLutUVToRef(properties, radius, cosAngleLightToZenith, UvTemp);\r\n        Sample2DRgbaToRef(UvTemp.x, UvTemp.y, LutWidthPx, LutHeightPx, this._lutData, Color4Temp, FromHalfFloat);\r\n\r\n        const intensity = atmosphere.diffuseSkyIrradianceIntensity;\r\n        result.r = intensity * (lightIrradiance * Color4Temp.r + additionalDiffuseSkyIrradiance.r);\r\n        result.g = intensity * (lightIrradiance * Color4Temp.g + additionalDiffuseSkyIrradiance.g);\r\n        result.b = intensity * (lightIrradiance * Color4Temp.b + additionalDiffuseSkyIrradiance.b);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Renders the LUT.\r\n     * @returns True if the LUT was rendered.\r\n     */\r\n    public render(): boolean {\r\n        // Only need to render the LUT once.\r\n        const effectWrapper = this._effectWrapper;\r\n        if (!this._isDirty || !effectWrapper?.isReady() || !this._renderTarget?.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._atmosphere.scene.getEngine();\r\n\r\n        engine.bindFramebuffer(this.renderTarget.renderTarget!, undefined, undefined, undefined, true);\r\n\r\n        const effectRenderer = this._effectRenderer!;\r\n        effectRenderer.applyEffectWrapper(effectWrapper);\r\n\r\n        effectRenderer.saveStates();\r\n        effectRenderer.setViewport();\r\n\r\n        const effect = effectWrapper.effect;\r\n        effectRenderer.bindBuffers(effect);\r\n\r\n        effect.setTexture(\"transmittanceLut\", this._atmosphere.transmittanceLut!.renderTarget);\r\n        effect.setTexture(\"multiScatteringLut\", this._atmosphere.multiScatteringLutRenderTarget);\r\n\r\n        this._atmosphere.bindUniformBufferToEffect(effect);\r\n\r\n        effect.setFloat(\"depth\", 0.0);\r\n\r\n        effectRenderer.draw();\r\n\r\n        effectRenderer.restoreStates();\r\n        engine.restoreDefaultFramebuffer();\r\n\r\n        this._isDirty = false;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        void this.renderTarget.readPixels(0, 0, undefined, undefined, true /* noDataConversion */)?.then((value: ArrayBufferView) => {\r\n            if (this._isDisposed) {\r\n                return;\r\n            }\r\n            this._lutData = value as Uint8Array | Uint16Array;\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Marks the LUT as needing to be rendered.\r\n     */\r\n    public markDirty(): void {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the LUT.\r\n     */\r\n    public dispose() {\r\n        if (this._renderTarget) {\r\n            this._renderTarget.irradianceTexture = null;\r\n            this._renderTarget.dispose();\r\n        }\r\n        this._renderTarget = null;\r\n        this._effectWrapper?.dispose();\r\n        this._effectWrapper = null;\r\n        this._effectRenderer?.dispose();\r\n        this._effectRenderer = null;\r\n        this._isDisposed = true;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"../Shaders/ShadersInclude/atmosphereFunctions\";\n\nconst name = \"transmittancePixelShader\";\nconst shader = `#define RENDER_TRANSMITTANCE\n#define EXCLUDE_RAY_MARCHING_FUNCTIONS\nprecision highp float;\n#include<__decl__atmosphereFragment>\n#include<helperFunctions>\n#include<atmosphereFunctions>\nvarying vec2 uv;void main() {gl_FragColor=renderTransmittance(uv);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const transmittancePixelShader = { name, shader };\n","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { Atmosphere } from \"./atmosphere\";\r\nimport type { AtmospherePhysicalProperties } from \"./atmospherePhysicalProperties\";\r\nimport { Clamp, SmoothStep } from \"core/Maths/math.scalar.functions\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { EffectRenderer, EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport { FromHalfFloat } from \"core/Misc/textureTools\";\r\nimport type { IColor3Like, IColor4Like, IVector2Like, IVector3Like } from \"core/Maths/math.like\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport { Sample2DRgbaToRef } from \"./sampling\";\r\nimport { Vector3Dot } from \"core/Maths/math.vector.functions\";\r\nimport \"./Shaders/fullscreenTriangle.vertex\";\r\nimport \"./Shaders/transmittance.fragment\";\r\n\r\nconst LutWidthPx = 256;\r\nconst LutHeightPx = 64;\r\nconst EffectiveDomainInUVSpace = { x: (LutWidthPx - 1.0) / LutWidthPx, y: (LutHeightPx - 1.0) / LutHeightPx };\r\nconst HalfTexelSize = { x: 0.5 / LutWidthPx, y: 0.5 / LutHeightPx };\r\nconst TransmittanceHorizonRange = 2.0 * HalfTexelSize.x;\r\nconst TransmittanceMaxUnoccludedU = 1.0 - 0.5 * TransmittanceHorizonRange;\r\n\r\nconst UseHalfFloat = false;\r\n\r\n// Temporary storage.\r\nconst Uv = { x: Number.NaN, y: Number.NaN } as IVector2Like;\r\nconst LightColorTemp = { r: Number.NaN, g: Number.NaN, b: Number.NaN } as IColor3Like;\r\nconst DirectionToLightTemp = { x: Number.NaN, y: Number.NaN, z: Number.NaN } as IVector3Like;\r\nconst Color4Temp = { r: Number.NaN, g: Number.NaN, b: Number.NaN, a: Number.NaN } as IColor4Like;\r\n\r\nconst ComputeLutUVToRef = (properties: AtmospherePhysicalProperties, radius: number, cosAngleLightToZenith: number, uv: IVector2Like): void => {\r\n    const radiusSquared = radius * radius;\r\n    const distanceToHorizon = Math.sqrt(Math.max(0.0, radiusSquared - properties.planetRadiusSquared));\r\n\r\n    const cosAngleLightToZenithSq = cosAngleLightToZenith * cosAngleLightToZenith;\r\n    const discriminant = radiusSquared * (cosAngleLightToZenithSq - 1.0) + properties.atmosphereRadiusSquared;\r\n    const distanceToAtmosphereEdge = Math.max(0.0, -radius * cosAngleLightToZenith + Math.sqrt(Math.max(0.0, discriminant)));\r\n\r\n    const minDistanceToAtmosphereEdge = Math.max(0.0, properties.atmosphereRadius - radius);\r\n    const maxDistanceToAtmosphereEdge = distanceToHorizon + properties.horizonDistanceToAtmosphereEdge;\r\n    const cosAngleLightToZenithCoordinate =\r\n        (distanceToAtmosphereEdge - minDistanceToAtmosphereEdge) / Math.max(0.000001, maxDistanceToAtmosphereEdge - minDistanceToAtmosphereEdge);\r\n    const distanceToHorizonCoordinate = distanceToHorizon / Math.max(0.000001, properties.horizonDistanceToAtmosphereEdge);\r\n\r\n    // Unit to UV.\r\n    uv.x = EffectiveDomainInUVSpace.x * cosAngleLightToZenithCoordinate + HalfTexelSize.x;\r\n    uv.y = EffectiveDomainInUVSpace.y * distanceToHorizonCoordinate + HalfTexelSize.y;\r\n};\r\n\r\nconst SampleLutToRef = (\r\n    properties: AtmospherePhysicalProperties,\r\n    lutData: Uint8Array | Uint16Array,\r\n    positionDistanceToOrigin: number,\r\n    cosAngleLightToZenith: number,\r\n    result: IColor4Like\r\n): void => {\r\n    if (positionDistanceToOrigin > properties.atmosphereRadius) {\r\n        result.r = result.g = result.b = result.a = 1.0;\r\n        return;\r\n    }\r\n\r\n    ComputeLutUVToRef(properties, positionDistanceToOrigin, cosAngleLightToZenith, Uv);\r\n    Sample2DRgbaToRef(Uv.x, Uv.y, LutWidthPx, LutHeightPx, lutData, result, UseHalfFloat ? FromHalfFloat : (value) => value / 255.0);\r\n\r\n    const weight = Clamp(SmoothStep(1.0, 0.0, Clamp((Uv.x - TransmittanceMaxUnoccludedU) / TransmittanceHorizonRange)));\r\n    result.r *= weight;\r\n    result.g *= weight;\r\n    result.b *= weight;\r\n    result.a *= weight;\r\n};\r\n\r\n/**\r\n * The transmittance LUT can be used to get the radiance from an external light source arriving a given point, accounting for atmospheric scattering.\r\n */\r\nexport class TransmittanceLut {\r\n    /**\r\n     * Listen to this observer to know when the LUT data has been updated.\r\n     * This is typically infrequent (once at startup), but also happens whenever the atmosphere's properties change.\r\n     */\r\n    public readonly onUpdatedObservable = new Observable<void>();\r\n\r\n    private readonly _atmosphere: Atmosphere;\r\n    private _lutData: Uint8Array | Uint16Array = new Uint8Array(0);\r\n    private _renderTarget: Nullable<RenderTargetTexture>;\r\n    private _effectWrapper: Nullable<EffectWrapper>;\r\n    private _effectRenderer: Nullable<EffectRenderer>;\r\n    private _isDirty = true;\r\n    private _isDisposed = false;\r\n\r\n    /**\r\n     * True if the LUT has been rendered.\r\n     */\r\n    public get isDirty(): boolean {\r\n        return this._isDirty;\r\n    }\r\n\r\n    /**\r\n     * The render target that contains the transmittance LUT.\r\n     * @throws if the LUT has been disposed.\r\n     */\r\n    public get renderTarget(): RenderTargetTexture {\r\n        if (this._isDisposed || this._renderTarget === null) {\r\n            throw new Error();\r\n        }\r\n        return this._renderTarget;\r\n    }\r\n\r\n    /**\r\n     * Constructs the {@link TransmittanceLut}.\r\n     * @param atmosphere - The atmosphere that owns this LUT.\r\n     */\r\n    constructor(atmosphere: Atmosphere) {\r\n        this._atmosphere = atmosphere;\r\n\r\n        const scene = this._atmosphere.scene;\r\n        const engine = scene.getEngine();\r\n        const useHalfFloat = UseHalfFloat && engine.getCaps().textureHalfFloatRender;\r\n\r\n        const name = \"atmo-transmittance\";\r\n        const renderTarget = (this._renderTarget = new RenderTargetTexture(name, { width: LutWidthPx, height: LutHeightPx }, scene, {\r\n            type: useHalfFloat ? Constants.TEXTURETYPE_HALF_FLOAT : Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n            samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n            generateDepthBuffer: false,\r\n            gammaSpace: false,\r\n        }));\r\n        renderTarget.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        renderTarget.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        renderTarget.anisotropicFilteringLevel = 1;\r\n        renderTarget.skipInitialClear = true;\r\n\r\n        const atmosphereUbo = atmosphere.uniformBuffer;\r\n        const useUbo = atmosphereUbo.useUbo;\r\n        this._effectWrapper = new EffectWrapper({\r\n            engine,\r\n            name,\r\n            vertexShader: \"fullscreenTriangle\",\r\n            fragmentShader: \"transmittance\",\r\n            attributeNames: [\"position\"],\r\n            uniformNames: [\"depth\", ...(useUbo ? [] : atmosphereUbo.getUniformNames())],\r\n            uniformBuffers: useUbo ? [atmosphereUbo.name] : [],\r\n            defines: [\"#define POSITION_VEC2\"],\r\n            useShaderStore: true,\r\n        });\r\n\r\n        this._effectRenderer = new EffectRenderer(engine, {\r\n            // Full screen triangle.\r\n            indices: [0, 2, 1],\r\n            positions: [-1, -1, -1, 3, 3, -1],\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the transmittance of an external light through the atmosphere to a point specified by its distance to the planet center and its geocentric normal.\r\n     * The result is always a linear space color.\r\n     * @param directionToLight - The direction to the light source.\r\n     * @param pointRadius - The distance from the origin to the point.\r\n     * @param pointGeocentricNormal - The normal of the point.\r\n     * @param result - The color to write the result to.\r\n     * @returns The result color.\r\n     */\r\n    public getTransmittedColorToRef<T extends IColor3Like>(directionToLight: IVector3Like, pointRadius: number, pointGeocentricNormal: IVector3Like, result: T): T {\r\n        if (this._lutData[0] !== undefined) {\r\n            const cosAngleLightToZenith = Vector3Dot(directionToLight, pointGeocentricNormal);\r\n            SampleLutToRef(this._atmosphere.physicalProperties, this._lutData, pointRadius, cosAngleLightToZenith, Color4Temp);\r\n            result.r = Color4Temp.r;\r\n            result.g = Color4Temp.g;\r\n            result.b = Color4Temp.b;\r\n        } else {\r\n            // Fallback.\r\n            result.r = result.g = result.b = 1.0;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Derives light color from the transmittance at a point specified by its distance to the planet center and its geocentric normal.\r\n     * @param light - The light to update.\r\n     * @param pointRadius - The distance from the origin to the point.\r\n     * @param pointGeocentricNormal - The normal of the point.\r\n     */\r\n    public updateLightParameters(light: DirectionalLight, pointRadius: number, pointGeocentricNormal: IVector3Like): void {\r\n        const lightDirection = light.direction;\r\n        DirectionToLightTemp.x = -lightDirection.x;\r\n        DirectionToLightTemp.y = -lightDirection.y;\r\n        DirectionToLightTemp.z = -lightDirection.z;\r\n        this.getTransmittedColorToRef(DirectionToLightTemp, pointRadius, pointGeocentricNormal, LightColorTemp);\r\n\r\n        light.diffuse.copyFromFloats(LightColorTemp.r, LightColorTemp.g, LightColorTemp.b);\r\n        light.specular.copyFromFloats(LightColorTemp.r, LightColorTemp.g, LightColorTemp.b);\r\n    }\r\n\r\n    /**\r\n     * Renders the LUT if needed.\r\n     * @returns true if the LUT was rendered.\r\n     */\r\n    public render(): boolean {\r\n        // Only need to render the LUT once.\r\n        const effectWrapper = this._effectWrapper;\r\n        if (!this._isDirty || !effectWrapper?.isReady() || !this._renderTarget?.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        const engine = this._atmosphere.scene.getEngine();\r\n\r\n        engine.bindFramebuffer(this.renderTarget.renderTarget!, undefined, undefined, undefined, true);\r\n\r\n        const effectRenderer = this._effectRenderer!;\r\n        effectRenderer.applyEffectWrapper(effectWrapper);\r\n\r\n        effectRenderer.saveStates();\r\n        effectRenderer.setViewport();\r\n\r\n        const effect = effectWrapper.effect;\r\n        effectRenderer.bindBuffers(effect);\r\n\r\n        this._atmosphere.bindUniformBufferToEffect(effect);\r\n\r\n        effect.setFloat(\"depth\", 0);\r\n\r\n        effectRenderer.draw();\r\n\r\n        effectRenderer.restoreStates();\r\n        engine.restoreDefaultFramebuffer();\r\n\r\n        this._isDirty = false;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        void this.renderTarget.readPixels(0, 0, undefined, undefined, UseHalfFloat /* noDataConversion */)?.then((value: ArrayBufferView) => {\r\n            if (this._isDisposed) {\r\n                return;\r\n            }\r\n            this._lutData = value as Uint8Array | Uint16Array;\r\n            this.onUpdatedObservable.notifyObservers();\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Marks the LUT as needing to be rendered.\r\n     */\r\n    public markDirty(): void {\r\n        this._isDirty = true;\r\n    }\r\n\r\n    /**\r\n     * Disposes the LUT and its resources.\r\n     */\r\n    public dispose(): void {\r\n        this._renderTarget?.dispose();\r\n        this._renderTarget = null;\r\n        this._effectWrapper?.dispose();\r\n        this._effectWrapper = null;\r\n        this._effectRenderer?.dispose();\r\n        this._effectRenderer = null;\r\n        this._isDisposed = true;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"../Shaders/ShadersInclude/depthFunctions\";\nimport \"../Shaders/ShadersInclude/atmosphereFunctions\";\n\nconst name = \"compositeAerialPerspectivePixelShader\";\nconst shader = `precision highp float;precision highp sampler2D;precision highp sampler2DArray;\n#include<__decl__atmosphereFragment>\n#if USE_AERIAL_PERSPECTIVE_LUT\nuniform sampler2DArray aerialPerspectiveLut;\n#endif\nuniform sampler2D depthTexture;uniform sampler2D transmittanceLut;uniform sampler2D multiScatteringLut;\n#include<helperFunctions>\n#include<depthFunctions>\n#include<atmosphereFunctions>\nvarying vec2 uv;varying vec3 positionOnNearPlane;void main() {gl_FragColor=vec4(0.);float depth=textureLod(depthTexture,uv,0.).r;if (depth>=1.) {discard;}\nvec3 rayDirection=normalize(positionOnNearPlane);float distanceFromCamera =\nreconstructDistanceFromCamera(\ndepth,\nrayDirection,\ncameraForward,\ncameraNearPlane);float distanceToSurface=distanceFromCamera/1000.;vec4 aerialPerspective=vec4(0.);if (sampleAerialPerspectiveLut(\nuv,\nfalse,\ndistanceToSurface,\nNumAerialPerspectiveLutLayers,\nAerialPerspectiveLutKMPerSlice,\nAerialPerspectiveLutRangeKM,\naerialPerspective)) {\n#ifndef APPLY_TRANSMITTANCE_BLENDING\naerialPerspective.a=0.;\n#endif\ngl_FragColor=aerialPerspective;} else {bool intersectsAtmosphere=false;vec3 cameraPositionGlobalClampedToTopOfAtmosphere=vec3(0.);moveToTopAtmosphere(\nclampedCameraPositionGlobal,\nclampedCameraRadius,\ncameraGeocentricNormal,\nrayDirection,\nintersectsAtmosphere,\ncameraPositionGlobalClampedToTopOfAtmosphere);if (!intersectsAtmosphere) {gl_FragColor=vec4(0.);return;}\nvec3 transmittance;vec3 radiance;bool isAerialPerspectiveLut=clampedCameraRadius<atmosphereRadius;integrateScatteredRadiance(\nisAerialPerspectiveLut,\natmosphereExposure*lightIntensity,\ntransmittanceLut,\nmultiScatteringLut,\nmultiScatteringIntensity,\ncameraPositionGlobalClampedToTopOfAtmosphere,\nrayDirection,\ndirectionToLight,\n100000000.,\nSkyViewLutSampleCount,\ndistanceToSurface,\nradiance,\ntransmittance);float transparency=1.-avg(transmittance);gl_FragColor =\napplyAerialPerspectiveRadianceBias(\napplyAerialPerspectiveIntensity(\napplyAerialPerspectiveSaturation(vec4(radiance,transparency))));\n#ifndef APPLY_TRANSMITTANCE_BLENDING\ngl_FragColor.a=0.;\n#endif\n}\n#if OUTPUT_TO_SRGB\ngl_FragColor=toGammaSpace(gl_FragColor);\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const compositeAerialPerspectivePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"../Shaders/ShadersInclude/depthFunctions\";\nimport \"../Shaders/ShadersInclude/atmosphereFunctions\";\n\nconst name = \"compositeSkyPixelShader\";\nconst shader = `#define SAMPLE_SKY_VIEW_LUT\n#if USE_SKY_VIEW_LUT\n#define EXCLUDE_RAY_MARCHING_FUNCTIONS\n#endif\nprecision highp float;precision highp sampler2D;\n#include<__decl__atmosphereFragment>\n#if USE_SKY_VIEW_LUT\nuniform sampler2D skyViewLut;\n#else\nuniform sampler2D transmittanceLut;uniform sampler2D multiScatteringLut;\n#endif\n#include<helperFunctions>\n#include<depthFunctions>\n#include<atmosphereFunctions>\nvarying vec2 uv;varying vec3 positionOnNearPlane;void main() {gl_FragColor=vec4(0.);vec3 rayDirection=normalize(positionOnNearPlane);\n#if USE_SKY_VIEW_LUT\nfloat cosAngleBetweenViewAndZenith;bool isRayIntersectingGround;vec4 skyColor =\nsampleSkyViewLut(\nskyViewLut,\nclampedCameraRadius,\ncameraGeocentricNormal,\nrayDirection,\ndirectionToLight,\ncosCameraHorizonAngleFromZenith,\ncosAngleBetweenViewAndZenith,\nisRayIntersectingGround);\n#ifndef APPLY_TRANSMITTANCE_BLENDING\nskyColor.a=0.;\n#endif\ngl_FragColor=skyColor;gl_FragColor.a=isRayIntersectingGround ? 1. : gl_FragColor.a;\n#else\nbool intersectsAtmosphere=false;vec3 cameraPositionGlobalClampedToTopOfAtmosphere=vec3(0.);moveToTopAtmosphere(\nclampedCameraPositionGlobal,\nclampedCameraRadius,\ncameraGeocentricNormal,\nrayDirection,\nintersectsAtmosphere,\ncameraPositionGlobalClampedToTopOfAtmosphere);if (!intersectsAtmosphere) {return;}\nvec3 transmittance;vec3 radiance;integrateScatteredRadiance(\nfalse,\natmosphereExposure*lightIntensity,\ntransmittanceLut,\nmultiScatteringLut,\nmultiScatteringIntensity,\ncameraPositionGlobalClampedToTopOfAtmosphere,\nrayDirection,\ndirectionToLight,\n100000000.,\nSkyViewLutSampleCount,\n-1.,\nradiance,\ntransmittance);\n#if APPLY_TRANSMITTANCE_BLENDING\nfloat transparency=1.-avg(transmittance);\n#else\nfloat transparency=0.;\n#endif\ngl_FragColor=vec4(radiance,transparency);\n#endif\n#if OUTPUT_TO_SRGB\ngl_FragColor=toGammaSpace(gl_FragColor);\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const compositeSkyPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"../Shaders/ShadersInclude/depthFunctions\";\nimport \"../Shaders/ShadersInclude/atmosphereFunctions\";\n\nconst name = \"compositeGlobeAtmospherePixelShader\";\nconst shader = `#define SAMPLE_SKY_VIEW_LUT\n#if USE_SKY_VIEW_LUT\n#define EXCLUDE_RAY_MARCHING_FUNCTIONS\n#endif\nprecision highp float;precision highp sampler2D;\n#include<__decl__atmosphereFragment>\n#if HAS_DEPTH_TEXTURE\nuniform sampler2D depthTexture;\n#endif\n#if USE_SKY_VIEW_LUT\nuniform sampler2D skyViewLut;\n#else\nuniform sampler2D transmittanceLut;uniform sampler2D multiScatteringLut;\n#endif\n#include<helperFunctions>\n#include<depthFunctions>\n#include<atmosphereFunctions>\nvarying vec2 uv;varying vec3 positionOnNearPlane;void main() {gl_FragColor=vec4(0.);\n#if HAS_DEPTH_TEXTURE\nfloat depth=textureLod(depthTexture,uv,0.).r;\n#endif\nvec3 rayDirection=normalize(positionOnNearPlane);\n#if USE_SKY_VIEW_LUT\nfloat cosAngleBetweenViewAndZenith;bool isRayIntersectingGround;vec4 skyColor =\nsampleSkyViewLut(\nskyViewLut,\nclampedCameraRadius,\ncameraGeocentricNormal,\nrayDirection,\ndirectionToLight,\ncosCameraHorizonAngleFromZenith,\ncosAngleBetweenViewAndZenith,\nisRayIntersectingGround);gl_FragColor=skyColor;if (isRayIntersectingGround) {gl_FragColor =\napplyAerialPerspectiveRadianceBias(\napplyAerialPerspectiveIntensity(\napplyAerialPerspectiveSaturation(gl_FragColor)));\n#if HAS_DEPTH_TEXTURE\ngl_FragColor.a=depth>=1. ? 1. : gl_FragColor.a;\n#endif\n}\n#else\nbool intersectsAtmosphere=false;vec3 cameraPositionGlobalClampedToTopOfAtmosphere=vec3(0.);moveToTopAtmosphere(\nclampedCameraPositionGlobal,\nclampedCameraRadius,\ncameraGeocentricNormal,\nrayDirection,\nintersectsAtmosphere,\ncameraPositionGlobalClampedToTopOfAtmosphere);if (!intersectsAtmosphere) {return;}\n#if HAS_DEPTH_TEXTURE\nfloat distanceFromCamera =\nreconstructDistanceFromCamera(\ndepth,\nrayDirection,\ncameraForward,\ncameraNearPlane);float distanceToSurface=distanceFromCamera/1000.;\n#else\nfloat distanceToSurface=0.;\n#endif\nvec3 transmittance;vec3 radiance;integrateScatteredRadiance(\nfalse,\natmosphereExposure*lightIntensity,\ntransmittanceLut,\nmultiScatteringLut,\nmultiScatteringIntensity,\ncameraPositionGlobalClampedToTopOfAtmosphere,\nrayDirection,\ndirectionToLight,\n100000000.,\nSkyViewLutSampleCount,\ndistanceToSurface,\nradiance,\ntransmittance);float transparency=1.-avg(transmittance);gl_FragColor=vec4(radiance,transparency);if (distanceToSurface>0.) {gl_FragColor =\napplyAerialPerspectiveRadianceBias(\napplyAerialPerspectiveIntensity(\napplyAerialPerspectiveSaturation(gl_FragColor)));\n#if HAS_DEPTH_TEXTURE\ngl_FragColor.a=depth>=1. ? 1. : gl_FragColor.a;\n#endif\n}\n#endif\n#if OUTPUT_TO_SRGB\ngl_FragColor=toGammaSpace(gl_FragColor);\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const compositeGlobeAtmospherePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"../Shaders/ShadersInclude/atmosphereFunctions\";\n\nconst name = \"multiScatteringPixelShader\";\nconst shader = `#define RENDER_MULTI_SCATTERING\n#define COMPUTE_MULTI_SCATTERING\nprecision highp float;\n#include<__decl__atmosphereFragment>\nuniform sampler2D transmittanceLut;\n#include<helperFunctions>\n#include<atmosphereFunctions>\nvarying vec2 uv;void main() {gl_FragColor=renderMultiScattering(uv,transmittanceLut);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const multiScatteringPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"../Shaders/ShadersInclude/atmosphereFunctions\";\n\nconst name = \"skyViewPixelShader\";\nconst shader = `#define RENDER_SKY_VIEW\nprecision highp float;precision highp sampler2D;\n#include<__decl__atmosphereFragment>\nuniform sampler2D transmittanceLut;uniform sampler2D multiScatteringLut;\n#include<helperFunctions>\n#include<atmosphereFunctions>\nvarying vec2 uv;void main() {gl_FragColor=renderSkyView(uv,transmittanceLut,multiScatteringLut);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const skyViewPixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\nimport \"../Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\nimport \"../Shaders/ShadersInclude/atmosphereUboDeclaration\";\nimport \"core/Shaders/ShadersInclude/helperFunctions\";\nimport \"../Shaders/ShadersInclude/atmosphereFunctions\";\n\nconst name = \"aerialPerspectivePixelShader\";\nconst shader = `#define RENDER_CAMERA_VOLUME\nprecision highp float;\n#include<__decl__atmosphereFragment>\nuniform sampler2D transmittanceLut;uniform sampler2D multiScatteringLut;\n#include<helperFunctions>\n#include<atmosphereFunctions>\nvarying vec3 positionOnNearPlane;uniform float layerIdx;void main() {gl_FragColor=renderCameraVolume(\npositionOnNearPlane,\nlayerIdx,\ntransmittanceLut,\nmultiScatteringLut\n);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const aerialPerspectivePixelShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"core/Engines/shaderStore\";\n\nconst name = \"atmosphereVertexDeclaration\";\nconst shader = `uniform mat4 inverseViewProjectionWithoutTranslation;\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const atmosphereVertexDeclaration = { name, shader };\n","import type { IDisposable, Scene } from \"core/scene\";\r\nimport type { BMFontChar } from \"./sdf/bmFont\";\r\nimport type { SdfFont } from \"./sdf/font\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\n\r\nenum CharCode {\r\n    SPACE = 32,\r\n    TOFU = 0xfffc,\r\n}\r\n\r\n/**\r\n * Class representing a font asset for SDF (Signed Distance Field) rendering.\r\n */\r\nexport class FontAsset implements IDisposable {\r\n    private readonly _chars = new Map<number, BMFontChar>();\r\n    private readonly _charsRegex: RegExp;\r\n    private readonly _kernings = new Map<number, Map<number, number>>();\r\n\r\n    /** @internal */\r\n    public readonly _font: SdfFont;\r\n\r\n    /**\r\n     * Gets the font scale value\r\n     */\r\n    public readonly scale: number;\r\n\r\n    /**\r\n     * Gets the list of used textures\r\n     */\r\n    public readonly textures: Texture[];\r\n\r\n    /**\r\n     * Creates a new FontAsset instance.\r\n     * @param definitionData defines the font data in JSON format.\r\n     * @param textureUrl defines the url of the texture to use for the font.\r\n     * @param scene defines the hosting scene.\r\n     */\r\n    public constructor(definitionData: string, textureUrl: string, scene?: Scene) {\r\n        this._font = JSON.parse(definitionData) as SdfFont;\r\n        // So far we only consider one page\r\n        this._font.pages = [textureUrl];\r\n\r\n        this._font.chars.forEach((char) => this._chars.set(char.id, char));\r\n        this._font.kernings.forEach((kerning) => {\r\n            let submap = this._kernings.get(kerning.first);\r\n            if (!submap) {\r\n                submap = new Map();\r\n                this._kernings.set(kerning.first, submap);\r\n            }\r\n            submap.set(kerning.second, kerning.amount);\r\n        });\r\n        this._charsRegex = new RegExp(`[${this._font.chars.map((c) => c.char.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")).join(\"\")}]`, \"g\");\r\n\r\n        this._updateFallbacks();\r\n\r\n        this.scale = 1 / this._font.info.size;\r\n        this.textures = this._font.pages.map((page) => {\r\n            const texture = new Texture(page, scene, { noMipmap: false, invertY: false });\r\n            texture.anisotropicFilteringLevel = 16;\r\n            return texture;\r\n        });\r\n    }\r\n\r\n    dispose(): void {\r\n        for (const texture of this.textures) {\r\n            texture.dispose();\r\n        }\r\n        this.textures.length = 0;\r\n    }\r\n\r\n    private _updateFallbacks() {\r\n        if (!this._chars.has(CharCode.SPACE)) {\r\n            this._chars.set(CharCode.SPACE, {\r\n                id: CharCode.SPACE,\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0,\r\n                xoffset: 0,\r\n                yoffset: 0,\r\n                xadvance: this._font.info.size * 0.5,\r\n                page: -1,\r\n                chnl: -1,\r\n                index: -1,\r\n                char: \" \",\r\n            });\r\n        }\r\n\r\n        if (!this._chars.has(CharCode.TOFU)) {\r\n            this._chars.set(CharCode.TOFU, {\r\n                id: CharCode.TOFU,\r\n                x: 0,\r\n                y: 0,\r\n                width: this._font.info.size,\r\n                height: this._font.info.size,\r\n                xoffset: 0,\r\n                yoffset: 0,\r\n                xadvance: this._font.info.size * 0.5,\r\n                page: -1,\r\n                chnl: -1,\r\n                index: -1,\r\n                char: \"\",\r\n            });\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _getChar(charCode: number) {\r\n        return this._chars.get(charCode) || this._chars.get(CharCode.TOFU)!;\r\n    }\r\n\r\n    /** @internal */\r\n    public _getKerning(first: number, second: number) {\r\n        return this._kernings.get(first)?.get(second) || 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _unsupportedChars(text: string) {\r\n        return text.replace(this._charsRegex, \"\");\r\n    }\r\n}\r\n","// Copyright (c) Microsoft Corporation.\r\n// Licensed under the MIT License.\r\n\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { AtmospherePBRMaterialPlugin } from \"./atmospherePBRMaterialPlugin\";\r\nimport { AtmospherePerCameraVariables } from \"./atmospherePerCameraVariables\";\r\nimport { AtmospherePhysicalProperties } from \"./atmospherePhysicalProperties\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { DeepImmutable, Nullable } from \"core/types\";\r\nimport { DiffuseSkyIrradianceLut } from \"./diffuseSkyIrradianceLut\";\r\nimport type { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport type { Effect } from \"core/Materials/effect\";\r\nimport { EffectRenderer, EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport type { IAtmosphereOptions } from \"./atmosphereOptions\";\r\nimport type { IColor3Like, IVector3Like } from \"core/Maths/math.like\";\r\nimport type { IDisposable, Scene } from \"core/scene\";\r\nimport { Observable, type Observer } from \"core/Misc/observable\";\r\nimport { RegisterMaterialPlugin, UnregisterMaterialPlugin } from \"core/Materials/materialPluginManager\";\r\nimport type { RenderingGroupInfo } from \"core/Rendering/renderingManager\";\r\nimport { RenderTargetTexture, type RenderTargetTextureOptions } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { RenderTargetWrapper } from \"core/Engines/renderTargetWrapper\";\r\nimport { TransmittanceLut } from \"./transmittanceLut\";\r\nimport { UniformBuffer } from \"core/Materials/uniformBuffer\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport \"./Shaders/compositeAerialPerspective.fragment\";\r\nimport \"./Shaders/compositeSky.fragment\";\r\nimport \"./Shaders/compositeGlobeAtmosphere.fragment\";\r\nimport \"./Shaders/fullscreenTriangle.vertex\";\r\nimport \"./Shaders/multiScattering.fragment\";\r\nimport \"./Shaders/skyView.fragment\";\r\nimport \"./Shaders/aerialPerspective.fragment\";\r\nimport \"./Shaders/ShadersInclude/atmosphereFragmentDeclaration\";\r\nimport \"./Shaders/ShadersInclude/atmosphereFunctions\";\r\nimport \"./Shaders/ShadersInclude/atmosphereUboDeclaration\";\r\nimport \"./Shaders/ShadersInclude/atmosphereVertexDeclaration\";\r\nimport \"./Shaders/ShadersInclude/depthFunctions\";\r\n\r\nconst MaterialPlugin = \"atmo-pbr\";\r\n\r\nconst AerialPerspectiveLutLayers = 32;\r\n\r\nlet UniqueId = 0;\r\n\r\n/**\r\n * Renders a physically based atmosphere.\r\n * Use {@link IsSupported} to check if the atmosphere is supported before creating an instance.\r\n * @experimental\r\n */\r\nexport class Atmosphere implements IDisposable {\r\n    private readonly _directionToLight = Vector3.Zero();\r\n    private readonly _tempSceneAmbient = new Color3();\r\n    private readonly _engine: AbstractEngine;\r\n    private _physicalProperties: AtmospherePhysicalProperties;\r\n    private _transmittanceLut: Nullable<TransmittanceLut>;\r\n    private _diffuseSkyIrradianceLut: Nullable<DiffuseSkyIrradianceLut>;\r\n    private _isSkyViewLutEnabled: boolean;\r\n    private _isAerialPerspectiveLutEnabled: boolean;\r\n    private _aerialPerspectiveTransmittanceScale: number;\r\n    private _aerialPerspectiveSaturation: number;\r\n    private _aerialPerspectiveIntensity: number;\r\n    private _aerialPerspectiveRadianceBias: number;\r\n    private _diffuseSkyIrradianceDesaturationFactor: number;\r\n    private _additionalDiffuseSkyIrradianceIntensity: number;\r\n    private _additionalDiffuseSkyIrradianceColor: Color3;\r\n    private _additionalDiffuseSkyIrradiance = new Color3();\r\n    private _diffuseSkyIrradianceIntensity: number;\r\n    private _multiScatteringIntensity: number;\r\n    private _groundAlbedo: Color3;\r\n    private _minimumMultiScatteringColor: Color3;\r\n    private _minimumMultiScatteringIntensity: number;\r\n    private _lights: DirectionalLight[];\r\n    private _atmosphereUbo: Nullable<UniformBuffer> = null;\r\n    private _minimumMultiScattering = new Vector3();\r\n    private _cameraAtmosphereVariables = new AtmospherePerCameraVariables();\r\n    private _isLinearSpaceComposition: boolean;\r\n    private _isLinearSpaceLight: boolean;\r\n    private _lightRadianceAtCamera = new Vector3();\r\n    private _linearLightColor = new Color3();\r\n    private _originHeight: number;\r\n    private _applyApproximateTransmittance: boolean;\r\n    private _exposure: number;\r\n    private _atmosphereUniformBufferAsArray: UniformBuffer[] = [];\r\n    private _effectRenderer: Nullable<EffectRenderer> = null;\r\n    private _skyRenderingGroup: number;\r\n    private _aerialPerspectiveRenderingGroup: number;\r\n    private _globeAtmosphereRenderingGroup: number;\r\n    private _isEnabled = true;\r\n    private _aerialPerspectiveLutHasBeenRendered = false;\r\n\r\n    private _hasRenderedMultiScatteringLut = false;\r\n    private _multiScatteringEffectWrapper: Nullable<EffectWrapper> = null;\r\n    private _multiScatteringLutRenderTarget: Nullable<RenderTargetTexture> = null;\r\n\r\n    private _aerialPerspectiveLutEffectWrapper: Nullable<EffectWrapper> = null;\r\n    private _aerialPerspectiveLutEffectRenderer: Nullable<EffectRenderer> = null;\r\n    private _aerialPerspectiveLutRenderTarget: Nullable<RenderTargetTexture> = null;\r\n\r\n    private _skyViewLutEffectWrapper: Nullable<EffectWrapper> = null;\r\n    private _skyViewLutEffectRenderer: Nullable<EffectRenderer> = null;\r\n    private _skyViewLutRenderTarget: Nullable<RenderTargetTexture> = null;\r\n\r\n    private _aerialPerspectiveCompositorEffectWrapper: Nullable<EffectWrapper> = null;\r\n    private _skyCompositorEffectWrapper: Nullable<EffectWrapper> = null;\r\n    private _globeAtmosphereCompositorEffectWrapper: Nullable<EffectWrapper> = null;\r\n\r\n    private _onBeforeCameraRenderObserver: Nullable<Observer<Camera>> = null;\r\n    private _onBeforeDrawPhaseObserver: Nullable<Observer<Scene>> = null;\r\n    private _onAfterRenderingGroupObserver: Nullable<Observer<RenderingGroupInfo>> = null;\r\n\r\n    /**\r\n     * Checks if the {@link Atmosphere} is supported.\r\n     * @param engine - The engine to check.\r\n     * @returns True if the atmosphere is supported, false otherwise.\r\n     */\r\n    public static IsSupported(engine: AbstractEngine): boolean {\r\n        return !engine._badOS && !engine.isWebGPU && engine.version >= 2;\r\n    }\r\n\r\n    /**\r\n     * The unique ID of this atmosphere instance.\r\n     */\r\n    public readonly uniqueId = UniqueId++;\r\n\r\n    /**\r\n     * Called after the atmosphere variables have been updated for the specified camera.\r\n     */\r\n    public readonly onAfterUpdateVariablesForCameraObservable = new Observable<Camera>();\r\n\r\n    /**\r\n     * Called immediately before the light variables are finalized.\r\n     */\r\n    public readonly onBeforeLightVariablesUpdateObservable = new Observable<void>();\r\n\r\n    /**\r\n     * Called before the LUTs are rendered for this camera. This happens after the per-camera UBO update.\r\n     */\r\n    public readonly onBeforeRenderLutsForCameraObservable = new Observable<Camera>();\r\n\r\n    /**\r\n     * Called after the LUTs were rendered.\r\n     */\r\n    public readonly onAfterRenderLutsForCameraObservable = new Observable<Camera>();\r\n\r\n    /**\r\n     * If provided, this is the depth texture used for composition passes.\r\n     * Expects an infinite far plane on the camera (camera.maxZ = 0) and the non-linear depth accessible in red channel.\r\n     * @internal\r\n     */\r\n    public readonly depthTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Controls the overall brightness of the atmosphere rendering.\r\n     */\r\n    public get exposure(): number {\r\n        return this._exposure;\r\n    }\r\n\r\n    public set exposure(value: number) {\r\n        this._exposure = Math.max(0, value);\r\n    }\r\n\r\n    /**\r\n     * Affects the overall intensity of the multiple scattering.\r\n     */\r\n    public get multiScatteringIntensity(): number {\r\n        return this._multiScatteringIntensity;\r\n    }\r\n\r\n    public set multiScatteringIntensity(value: number) {\r\n        const newValue = Math.max(0.0, value);\r\n        if (newValue !== this._multiScatteringIntensity) {\r\n            this._multiScatteringIntensity = value;\r\n            this._diffuseSkyIrradianceLut?.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Affects the multiply scattered light contribution in the atmosphere by describing the average light color reflected off the ground.\r\n     */\r\n    public get groundAlbedo(): DeepImmutable<IColor3Like> {\r\n        return this._groundAlbedo;\r\n    }\r\n\r\n    public set groundAlbedo(value: DeepImmutable<IColor3Like>) {\r\n        if (!this._groundAlbedo.equals(value)) {\r\n            this._groundAlbedo.copyFrom(value);\r\n            this._multiScatteringEffectWrapper?.dispose();\r\n            this._multiScatteringEffectWrapper = null;\r\n            this._hasRenderedMultiScatteringLut = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used to clamp the multiple scattering to a minimum value.\r\n     */\r\n    public get minimumMultiScatteringColor(): DeepImmutable<IColor3Like> {\r\n        return this._minimumMultiScatteringColor;\r\n    }\r\n\r\n    public set minimumMultiScatteringColor(value: DeepImmutable<IColor3Like>) {\r\n        if (!this._minimumMultiScatteringColor.equals(value)) {\r\n            const minimumScatteringColor = this._minimumMultiScatteringColor.copyFrom(value);\r\n            this._minimumMultiScattering.x = minimumScatteringColor.r * this._minimumMultiScatteringIntensity;\r\n            this._minimumMultiScattering.y = minimumScatteringColor.g * this._minimumMultiScatteringIntensity;\r\n            this._minimumMultiScattering.z = minimumScatteringColor.b * this._minimumMultiScatteringIntensity;\r\n            this._diffuseSkyIrradianceLut?.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This is an additional scaling factor applied to the {@link minimumMultiScatteringColor}.\r\n     */\r\n    public get minimumMultiScatteringIntensity(): number {\r\n        return this._minimumMultiScatteringIntensity;\r\n    }\r\n\r\n    public set minimumMultiScatteringIntensity(value: number) {\r\n        const newValue = Math.max(0.0, value);\r\n        if (newValue !== this._minimumMultiScatteringIntensity) {\r\n            this._minimumMultiScatteringIntensity = value;\r\n            this._minimumMultiScattering.x = this._minimumMultiScatteringColor.r * value;\r\n            this._minimumMultiScattering.y = this._minimumMultiScatteringColor.g * value;\r\n            this._minimumMultiScattering.z = this._minimumMultiScatteringColor.b * value;\r\n            this._diffuseSkyIrradianceLut?.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Can be used to force the diffuse irradiance towards a gray color.\r\n     */\r\n    public get diffuseSkyIrradianceDesaturationFactor(): number {\r\n        return this._diffuseSkyIrradianceDesaturationFactor;\r\n    }\r\n\r\n    public set diffuseSkyIrradianceDesaturationFactor(value: number) {\r\n        const newValue = Math.max(value, 0.0);\r\n        if (newValue !== this._diffuseSkyIrradianceDesaturationFactor) {\r\n            this._diffuseSkyIrradianceDesaturationFactor = newValue;\r\n            this._diffuseSkyIrradianceLut?.markDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This is an additional amount of irradiance added to the diffuse irradiance.\r\n     */\r\n    public get additionalDiffuseSkyIrradianceIntensity(): number {\r\n        return this._additionalDiffuseSkyIrradianceIntensity;\r\n    }\r\n\r\n    public set additionalDiffuseSkyIrradianceIntensity(value: number) {\r\n        value = Math.max(0.0, value);\r\n        if (value !== this._additionalDiffuseSkyIrradianceIntensity) {\r\n            this._additionalDiffuseSkyIrradianceIntensity = value;\r\n            this._additionalDiffuseSkyIrradianceColor.scaleToRef(value, this._additionalDiffuseSkyIrradiance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This is the color for the additional amount of irradiance added to the diffuse irradiance.\r\n     */\r\n    public get additionalDiffuseSkyIrradianceColor(): DeepImmutable<IColor3Like> {\r\n        return this._additionalDiffuseSkyIrradianceColor;\r\n    }\r\n\r\n    public set additionalDiffuseSkyIrradianceColor(value: DeepImmutable<IColor3Like>) {\r\n        if (!this._additionalDiffuseSkyIrradianceColor.equals(value)) {\r\n            this._additionalDiffuseSkyIrradianceColor.copyFrom(value).scaleToRef(this._additionalDiffuseSkyIrradianceIntensity, this._additionalDiffuseSkyIrradiance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The final additional diffuse irradiance, taking into account the intensity and color.\r\n     */\r\n    public get additionalDiffuseSkyIrradiance(): DeepImmutable<IColor3Like> {\r\n        return this._additionalDiffuseSkyIrradiance;\r\n    }\r\n\r\n    /**\r\n     * The intensity of the diffuse irradiance.\r\n     */\r\n    public get diffuseSkyIrradianceIntensity(): number {\r\n        return this._diffuseSkyIrradianceIntensity;\r\n    }\r\n\r\n    public set diffuseSkyIrradianceIntensity(value: number) {\r\n        this._diffuseSkyIrradianceIntensity = Math.max(value, 0.0);\r\n    }\r\n\r\n    /**\r\n     * True if the sky view LUT should be used for compositing the sky instead of a per-pixel ray march.\r\n     */\r\n    public get isSkyViewLutEnabled(): boolean {\r\n        return this._isSkyViewLutEnabled;\r\n    }\r\n\r\n    public set isSkyViewLutEnabled(value: boolean) {\r\n        this._isSkyViewLutEnabled = value;\r\n        this._disposeSkyCompositor();\r\n        this._disposeGlobeAtmosphereCompositor();\r\n    }\r\n\r\n    /**\r\n     * Gets the sky view LUT render target or null if not enabled.\r\n     * @returns The render target.\r\n     */\r\n    public get skyViewLutRenderTarget(): Nullable<RenderTargetTexture> {\r\n        if (!this._isSkyViewLutEnabled) {\r\n            return null;\r\n        }\r\n\r\n        if (this._skyViewLutRenderTarget !== null) {\r\n            return this._skyViewLutRenderTarget;\r\n        }\r\n\r\n        const renderTarget = (this._skyViewLutRenderTarget = CreateRenderTargetTexture(\"atmo-skyView\", { width: 128, height: 128 }, this.scene));\r\n        renderTarget.coordinatesMode = Constants.TEXTURE_EQUIRECTANGULAR_MODE;\r\n\r\n        this._skyViewLutEffectWrapper = CreateSkyViewEffectWrapper(this._engine, this.uniformBuffer);\r\n\r\n        return renderTarget;\r\n    }\r\n    /**\r\n     * True if the aerial perspective LUT should be used.\r\n     * If false, full ray marching would be used instead.\r\n     */\r\n    public get isAerialPerspectiveLutEnabled(): boolean {\r\n        return this._isAerialPerspectiveLutEnabled;\r\n    }\r\n\r\n    public set isAerialPerspectiveLutEnabled(value: boolean) {\r\n        this._isAerialPerspectiveLutEnabled = value;\r\n        this._disposeAerialPerspectiveCompositor();\r\n    }\r\n\r\n    /**\r\n     * Gets the aerial perspective LUT render target or null if not enabled.\r\n     * @returns The render target.\r\n     */\r\n    public get aerialPerspectiveLutRenderTarget(): Nullable<RenderTargetTexture> {\r\n        if (!this._isAerialPerspectiveLutEnabled) {\r\n            return null;\r\n        }\r\n\r\n        if (this._aerialPerspectiveLutRenderTarget !== null) {\r\n            return this._aerialPerspectiveLutRenderTarget;\r\n        }\r\n\r\n        const scene = this.scene;\r\n        const name = \"atmo-aerialPerspective\";\r\n        const renderTarget = (this._aerialPerspectiveLutRenderTarget = CreateRenderTargetTexture(name, { width: 16, height: 64, layers: AerialPerspectiveLutLayers }, scene, {}));\r\n        this._aerialPerspectiveLutEffectWrapper = CreateAerialPerspectiveEffectWrapper(this._engine, this.uniformBuffer);\r\n\r\n        return renderTarget;\r\n    }\r\n\r\n    /**\r\n     * The intensity of the aerial perspective.\r\n     */\r\n    public get aerialPerspectiveIntensity(): number {\r\n        return this._aerialPerspectiveIntensity;\r\n    }\r\n\r\n    public set aerialPerspectiveIntensity(value: number) {\r\n        value = Math.max(0.001, value);\r\n        if (value !== this._aerialPerspectiveIntensity) {\r\n            // Define only needs to change if the value is changing between 1 and not 1.\r\n            const hasDefineChanged = (value === 1) !== (this._aerialPerspectiveIntensity === 1);\r\n            this._aerialPerspectiveIntensity = value;\r\n            if (hasDefineChanged) {\r\n                this._disposeAerialPerspectiveCompositor();\r\n                this._disposeGlobeAtmosphereCompositor();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The amount of light transmitted into aerial perspective.\r\n     * A scale of 1 is physically correct.\r\n     */\r\n    public get aerialPerspectiveTransmittanceScale(): number {\r\n        return this._aerialPerspectiveTransmittanceScale;\r\n    }\r\n\r\n    public set aerialPerspectiveTransmittanceScale(value: number) {\r\n        value = Math.max(0, value);\r\n        if (value !== this._aerialPerspectiveTransmittanceScale) {\r\n            this._aerialPerspectiveTransmittanceScale = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The amount of saturation applied to the aerial perspective.\r\n     * Reducing to zero desaturates the aerial perspective completely.\r\n     * A value of 1 has no effect.\r\n     */\r\n    public get aerialPerspectiveSaturation(): number {\r\n        return this._aerialPerspectiveSaturation;\r\n    }\r\n\r\n    public set aerialPerspectiveSaturation(value: number) {\r\n        value = Math.max(0.0, value);\r\n        if (value !== this._aerialPerspectiveSaturation) {\r\n            this._aerialPerspectiveSaturation = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A radiance bias applied to aerial perspective.\r\n     */\r\n    public get aerialPerspectiveRadianceBias(): number {\r\n        return this._aerialPerspectiveRadianceBias;\r\n    }\r\n\r\n    public set aerialPerspectiveRadianceBias(value: number) {\r\n        if (value !== this._aerialPerspectiveRadianceBias) {\r\n            // Define only needs to change if the value is changing between 0 and not 0.\r\n            const hasDefineChanged = (value === 0) !== (this._aerialPerspectiveRadianceBias === 0);\r\n            this._aerialPerspectiveRadianceBias = value;\r\n            if (hasDefineChanged) {\r\n                this._disposeAerialPerspectiveCompositor();\r\n                this._disposeGlobeAtmosphereCompositor();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * True if the composition should be in linear space (e.g. for HDR rendering).\r\n     * Typically linear space is expected when ImageProcessing is enabled via PostProcesses.\r\n     * False for non-linear output.\r\n     */\r\n    public get isLinearSpaceComposition(): boolean {\r\n        return this._isLinearSpaceComposition;\r\n    }\r\n\r\n    public set isLinearSpaceComposition(value: boolean) {\r\n        if (value !== this._isLinearSpaceComposition) {\r\n            this._isLinearSpaceComposition = value;\r\n            // Note, LUTs will remain in linear space. Up to compositors to apply gamma if needed.\r\n            this._disposeSkyCompositor();\r\n            this._disposeAerialPerspectiveCompositor();\r\n            this._disposeGlobeAtmosphereCompositor();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * True if the {@link light} value should be specified in linear space.\r\n     * If using PBRMaterials, light value is expected to be linear.\r\n     */\r\n    public get isLinearSpaceLight(): boolean {\r\n        return this._isLinearSpaceLight;\r\n    }\r\n\r\n    public set isLinearSpaceLight(value: boolean) {\r\n        this._isLinearSpaceLight = value;\r\n    }\r\n\r\n    /**\r\n     * The lookup table for transmittance.\r\n     */\r\n    public get transmittanceLut(): Nullable<TransmittanceLut> {\r\n        return this._transmittanceLut;\r\n    }\r\n\r\n    /**\r\n     * Gets the multiple scattering LUT render target.\r\n     * @returns The render target.\r\n     */\r\n    public get multiScatteringLutRenderTarget(): Nullable<RenderTargetTexture> {\r\n        return this._multiScatteringLutRenderTarget;\r\n    }\r\n\r\n    /**\r\n     * The lookup table for diffuse sky irradiance, or null if not enabled.\r\n     */\r\n    public get diffuseSkyIrradianceLut(): Nullable<DiffuseSkyIrradianceLut> {\r\n        return this._diffuseSkyIrradianceLut;\r\n    }\r\n\r\n    /**\r\n     * The properties used to describe the size and optical parameters of the atmosphere.\r\n     */\r\n    public get physicalProperties(): AtmospherePhysicalProperties {\r\n        return this._physicalProperties;\r\n    }\r\n\r\n    /**\r\n     * The height in kilometers of the scene's origin.\r\n     */\r\n    public get originHeight(): number {\r\n        return this._originHeight;\r\n    }\r\n\r\n    public set originHeight(value: number) {\r\n        this._originHeight = value;\r\n    }\r\n\r\n    /**\r\n     * When atmospheric scattering is applied to surfaces, if this value is set to true,\r\n     * a grayscale approximation of the transmittance is used to dim surfaces.\r\n     *\r\n     * When set to false, the atmospheric composition does not dim the surfaces behind it.\r\n     * It is up to the client application to apply transmittance manually.\r\n     */\r\n    public get applyApproximateTransmittance(): boolean {\r\n        return this._applyApproximateTransmittance;\r\n    }\r\n\r\n    public set applyApproximateTransmittance(value: boolean) {\r\n        if (this._applyApproximateTransmittance !== value) {\r\n            this._applyApproximateTransmittance = value;\r\n            this._disposeSkyCompositor();\r\n            this._disposeAerialPerspectiveCompositor();\r\n            this._disposeGlobeAtmosphereCompositor();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The directional lights in the scene which represent the suns illuminating the atmosphere.\r\n     * Each frame, the color and intensity of the lights are updated based on the camera position and the light's direction.\r\n     */\r\n    public get lights(): ReadonlyArray<DirectionalLight> {\r\n        return this._lights;\r\n    }\r\n\r\n    /**\r\n     * The rendering group ID for the sky compositor.\r\n     * The sky will only be rendered for this group.\r\n     */\r\n    public get skyRenderingGroup(): number {\r\n        return this._skyRenderingGroup;\r\n    }\r\n\r\n    public set skyRenderingGroup(value: number) {\r\n        this._skyRenderingGroup = value;\r\n        this.scene.renderingManager.getRenderingGroup(value);\r\n    }\r\n\r\n    /**\r\n     * The rendering group ID for the aerial perspective compositor.\r\n     * Aerial perspective will only be rendered for this group.\r\n     */\r\n    public get aerialPerspectiveRenderingGroup(): number {\r\n        return this._aerialPerspectiveRenderingGroup;\r\n    }\r\n\r\n    public set aerialPerspectiveRenderingGroup(value: number) {\r\n        this._aerialPerspectiveRenderingGroup = value;\r\n        this.scene.renderingManager.getRenderingGroup(value);\r\n    }\r\n\r\n    /**\r\n     * The rendering group ID for the globe atmosphere compositor.\r\n     * The globe atmosphere will only be rendered for this group.\r\n     */\r\n    public get globeAtmosphereRenderingGroup(): number {\r\n        return this._globeAtmosphereRenderingGroup;\r\n    }\r\n\r\n    public set globeAtmosphereRenderingGroup(value: number) {\r\n        this._globeAtmosphereRenderingGroup = value;\r\n        this.scene.renderingManager.getRenderingGroup(value);\r\n    }\r\n\r\n    /**\r\n     * Gets the uniform buffer used to store the atmosphere's physical properties.\r\n     */\r\n    public get uniformBuffer(): UniformBuffer {\r\n        if (this._atmosphereUbo === null) {\r\n            const atmosphereUbo = (this._atmosphereUbo = new UniformBuffer(this._engine, undefined, true, \"Atmosphere\"));\r\n            atmosphereUbo.addUniform(\"peakRayleighScattering\", 3);\r\n            atmosphereUbo.addUniform(\"planetRadius\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"peakMieScattering\", 3);\r\n            atmosphereUbo.addUniform(\"atmosphereThickness\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"peakMieAbsorption\", 3);\r\n            atmosphereUbo.addUniform(\"planetRadiusSquared\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"peakMieExtinction\", 3);\r\n            atmosphereUbo.addUniform(\"atmosphereRadius\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"peakOzoneAbsorption\", 3);\r\n            atmosphereUbo.addUniform(\"atmosphereRadiusSquared\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"horizonDistanceToAtmosphereEdge\", 1);\r\n            atmosphereUbo.addUniform(\"horizonDistanceToAtmosphereEdgeSquared\", 1);\r\n            atmosphereUbo.addUniform(\"planetRadiusWithOffset\", 1);\r\n            atmosphereUbo.addUniform(\"planetRadiusOffset\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"atmosphereExposure\", 1);\r\n            atmosphereUbo.addUniform(\"aerialPerspectiveRadianceBias\", 1);\r\n            atmosphereUbo.addUniform(\"inverseAtmosphereThickness\", 1);\r\n            atmosphereUbo.addUniform(\"aerialPerspectiveTransmittanceScale\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"inverseViewProjectionWithoutTranslation\", 16);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"directionToLight\", 3);\r\n            atmosphereUbo.addUniform(\"multiScatteringIntensity\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"directionToLightRelativeToCameraGeocentricNormal\", 3);\r\n            atmosphereUbo.addUniform(\"cameraRadius\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"lightRadianceAtCamera\", 3);\r\n            atmosphereUbo.addUniform(\"diffuseSkyIrradianceDesaturationFactor\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"groundAlbedo\", 3);\r\n            atmosphereUbo.addUniform(\"aerialPerspectiveSaturation\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"minMultiScattering\", 3);\r\n            atmosphereUbo.addUniform(\"diffuseSkyIrradianceIntensity\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"cameraPositionGlobal\", 3);\r\n            atmosphereUbo.addUniform(\"lightIntensity\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"clampedCameraPositionGlobal\", 3);\r\n            atmosphereUbo.addUniform(\"aerialPerspectiveIntensity\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"cameraGeocentricNormal\", 3);\r\n            atmosphereUbo.addUniform(\"clampedCameraRadius\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"cameraForward\", 3);\r\n            atmosphereUbo.addUniform(\"clampedCameraHeight\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"cameraPosition\", 3);\r\n            atmosphereUbo.addUniform(\"cosCameraHorizonAngleFromZenith\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"viewport\", 4);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"additionalDiffuseSkyIrradiance\", 3);\r\n            atmosphereUbo.addUniform(\"cameraHeight\", 1);\r\n            // 16-byte boundary\r\n            atmosphereUbo.addUniform(\"cameraNearPlane\", 1);\r\n            atmosphereUbo.addUniform(\"originHeight\", 1);\r\n            atmosphereUbo.addUniform(\"sinCameraAtmosphereHorizonAngleFromNadir\", 1);\r\n            atmosphereUbo.create();\r\n        }\r\n        return this._atmosphereUbo;\r\n    }\r\n\r\n    /**\r\n     * Gets the camera-related variables for this atmosphere. Updated each frame.\r\n     */\r\n    public get cameraAtmosphereVariables(): AtmospherePerCameraVariables {\r\n        return this._cameraAtmosphereVariables;\r\n    }\r\n\r\n    /**\r\n     * Constructs the {@link Atmosphere}.\r\n     * @param name - The name of this instance.\r\n     * @param scene - The scene to which the atmosphere will be added.\r\n     * @param lights - The light sources that illuminate the atmosphere. Currently only supports one light, and that light should be the first light in the scene.\r\n     * @param options - The options used to create the atmosphere.\r\n     */\r\n    public constructor(\r\n        public readonly name: string,\r\n        public readonly scene: Scene,\r\n        lights: DirectionalLight[],\r\n        options?: IAtmosphereOptions\r\n    ) {\r\n        const engine = (this._engine = scene.getEngine());\r\n\r\n        if (engine.isWebGPU) {\r\n            throw new Error(\"Atmosphere is not supported on WebGPU.\");\r\n        }\r\n        if (engine.version < 2) {\r\n            throw new Error(`Atmosphere is not supported on WebGL ${engine.version}.`);\r\n        }\r\n\r\n        this._physicalProperties = options?.physicalProperties ?? new AtmospherePhysicalProperties();\r\n        this._physicalProperties.onChangedObservable.add(() => {\r\n            this._transmittanceLut?.markDirty();\r\n        });\r\n\r\n        if (lights.length !== 1) {\r\n            throw new Error(\"Atmosphere only supports one light source currently.\");\r\n        }\r\n        this._lights = lights;\r\n\r\n        this.depthTexture = options?.depthTexture ?? null;\r\n        this._exposure = options?.exposure ?? 1.0;\r\n        this._isLinearSpaceLight = options?.isLinearSpaceLight ?? false;\r\n        this._isLinearSpaceComposition = options?.isLinearSpaceComposition ?? false;\r\n        this._applyApproximateTransmittance = options?.applyApproximateTransmittance ?? true;\r\n        this._aerialPerspectiveRadianceBias = options?.aerialPerspectiveRadianceBias ?? 0.0;\r\n        this._aerialPerspectiveTransmittanceScale = options?.aerialPerspectiveTransmittanceScale ?? 1.0;\r\n        this._aerialPerspectiveSaturation = options?.aerialPerspectiveSaturation ?? 1.0;\r\n        this._aerialPerspectiveIntensity = options?.aerialPerspectiveIntensity ?? 1.0;\r\n        this._diffuseSkyIrradianceDesaturationFactor = options?.diffuseSkyIrradianceDesaturationFactor ?? 0.5;\r\n        this._diffuseSkyIrradianceIntensity = options?.diffuseSkyIrradianceIntensity ?? 1.0;\r\n        this._additionalDiffuseSkyIrradianceIntensity = options?.additionalDiffuseSkyIrradianceIntensity ?? 0.01;\r\n        this._multiScatteringIntensity = options?.multiScatteringIntensity ?? 1.0;\r\n        this._minimumMultiScatteringIntensity = options?.minimumMultiScatteringIntensity ?? 0.000618;\r\n        this._isSkyViewLutEnabled = options?.isSkyViewLutEnabled ?? true;\r\n        this._isAerialPerspectiveLutEnabled = options?.isAerialPerspectiveLutEnabled ?? true;\r\n        this._originHeight = options?.originHeight ?? 0;\r\n        this._additionalDiffuseSkyIrradianceColor = options?.additionalDiffuseSkyIrradianceColor\r\n            ? new Color3().copyFrom(options.additionalDiffuseSkyIrradianceColor)\r\n            : new Color3(163 / 255.0, 199 / 255.0, 1.0);\r\n        this._groundAlbedo = options?.groundAlbedo ? new Color3().copyFrom(options.groundAlbedo) : new Color3().set(124.0 / 255.0, 165.0 / 255.0, 1.0);\r\n        const minimumMultiScatteringColor = (this._minimumMultiScatteringColor = options?.minimumMultiScatteringColor\r\n            ? new Color3().copyFrom(options.minimumMultiScatteringColor)\r\n            : new Color3(30.0 / 255.0, 40.0 / 255.0, 77.0 / 255.0));\r\n\r\n        this._skyRenderingGroup = options?.skyRenderingGroup ?? 0;\r\n        this._aerialPerspectiveRenderingGroup = options?.aerialPerspectiveRenderingGroup ?? 0;\r\n        this._globeAtmosphereRenderingGroup = options?.globeAtmosphereRenderingGroup ?? 0;\r\n\r\n        this._additionalDiffuseSkyIrradianceColor.scaleToRef(this._additionalDiffuseSkyIrradianceIntensity, this._additionalDiffuseSkyIrradiance);\r\n        this._minimumMultiScattering.x = minimumMultiScatteringColor.r * this._minimumMultiScatteringIntensity;\r\n        this._minimumMultiScattering.y = minimumMultiScatteringColor.g * this._minimumMultiScatteringIntensity;\r\n        this._minimumMultiScattering.z = minimumMultiScatteringColor.b * this._minimumMultiScatteringIntensity;\r\n\r\n        this._effectRenderer = new EffectRenderer(engine, {\r\n            // Full screen triangle.\r\n            indices: [0, 2, 1],\r\n            positions: [-1, -1, -1, 3, 3, -1],\r\n        });\r\n\r\n        this._transmittanceLut = new TransmittanceLut(this);\r\n        this._multiScatteringLutRenderTarget = CreateRenderTargetTexture(\"atmo-multiScattering\", { width: 32, height: 32 }, scene);\r\n        if (options?.isDiffuseSkyIrradianceLutEnabled ?? true) {\r\n            this._diffuseSkyIrradianceLut = new DiffuseSkyIrradianceLut(this);\r\n        }\r\n        if (this._isSkyViewLutEnabled) {\r\n            this.skyViewLutRenderTarget!;\r\n        }\r\n        if (this._isAerialPerspectiveLutEnabled) {\r\n            this.aerialPerspectiveLutRenderTarget!;\r\n        }\r\n\r\n        // Before rendering, make sure the per-camera variables have been updated.\r\n        this._onBeforeCameraRenderObserver = scene.onBeforeCameraRenderObservable.add((x) => {\r\n            this._updatePerCameraVariables(x);\r\n            this._renderLutsForCamera(x);\r\n        });\r\n\r\n        {\r\n            const renderingManager = scene.renderingManager;\r\n            if (this._skyRenderingGroup >= 0) {\r\n                renderingManager.getRenderingGroup(this._skyRenderingGroup);\r\n            }\r\n            if (this._aerialPerspectiveRenderingGroup >= 0) {\r\n                renderingManager.getRenderingGroup(this._aerialPerspectiveRenderingGroup);\r\n            }\r\n            if (this._globeAtmosphereRenderingGroup >= 0) {\r\n                renderingManager.getRenderingGroup(this._globeAtmosphereRenderingGroup);\r\n            }\r\n\r\n            // Mark all rendering groups as being \"not empty\" before rendering the corresponding targets.\r\n            // This ensures onAfterRenderTargetsRenderObservable is called for empty groups,\r\n            // which allows the atmosphere to be rendered even when the groups are otherwise empty e.g.,\r\n            // a scene with only the atmosphere in it, and no other Meshes.\r\n            this._onBeforeDrawPhaseObserver = scene.onBeforeDrawPhaseObservable.add(() => {\r\n                if (this._skyRenderingGroup >= 0) {\r\n                    renderingManager.getRenderingGroup(this._skyRenderingGroup)._empty = false;\r\n                }\r\n                if (this._aerialPerspectiveRenderingGroup >= 0) {\r\n                    renderingManager.getRenderingGroup(this._aerialPerspectiveRenderingGroup)._empty = false;\r\n                }\r\n                if (this._globeAtmosphereRenderingGroup >= 0) {\r\n                    renderingManager.getRenderingGroup(this._globeAtmosphereRenderingGroup)._empty = false;\r\n                }\r\n            });\r\n\r\n            // Draw compositors after the respective rendering group.\r\n            this._onAfterRenderingGroupObserver = scene.onAfterRenderingGroupObservable.add((group) => {\r\n                if (group.renderingManager !== scene.renderingManager) {\r\n                    return;\r\n                }\r\n\r\n                const groupId = group.renderingGroupId;\r\n\r\n                if (this._skyRenderingGroup === groupId) {\r\n                    this.drawSkyCompositor();\r\n                }\r\n\r\n                if (this._aerialPerspectiveRenderingGroup === groupId) {\r\n                    this.drawAerialPerspectiveCompositor();\r\n                }\r\n\r\n                if (this._globeAtmosphereRenderingGroup === groupId) {\r\n                    this.drawGlobeAtmosphereCompositor();\r\n                }\r\n            });\r\n        }\r\n\r\n        // Ensure the atmosphere is disposed when the scene is disposed.\r\n        scene.onDisposeObservable.addOnce(() => {\r\n            scene.removeExternalData(\"atmosphere\");\r\n            this.dispose();\r\n        });\r\n        scene.addExternalData(\"atmosphere\", this);\r\n\r\n        // Registers a material plugin which will allow common materials to sample the atmosphere environment maps e.g.,\r\n        // sky view LUT for glossy reflections and diffuse sky illiminance LUT for irradiance.\r\n        // It also handles aerial perspective application when Atmosphere is not provided with a depth texture.\r\n        UnregisterMaterialPlugin(MaterialPlugin);\r\n        RegisterMaterialPlugin(MaterialPlugin, (material) => {\r\n            if (material.getClassName() === \"PBRMaterial\") {\r\n                return new AtmospherePBRMaterialPlugin(material, this, this.depthTexture === null);\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public dispose(): void {\r\n        this._onBeforeCameraRenderObserver?.remove();\r\n        this._onBeforeCameraRenderObserver = null;\r\n        this._onBeforeDrawPhaseObserver?.remove();\r\n        this._onBeforeDrawPhaseObserver = null;\r\n        this._onAfterRenderingGroupObserver?.remove();\r\n        this._onAfterRenderingGroupObserver = null;\r\n        this._globeAtmosphereCompositorEffectWrapper?.dispose();\r\n        this._globeAtmosphereCompositorEffectWrapper = null;\r\n        this._skyCompositorEffectWrapper?.dispose();\r\n        this._skyCompositorEffectWrapper = null;\r\n        this._aerialPerspectiveCompositorEffectWrapper?.dispose();\r\n        this._aerialPerspectiveCompositorEffectWrapper = null;\r\n        this._skyViewLutRenderTarget?.dispose();\r\n        this._skyViewLutRenderTarget = null;\r\n        this._skyViewLutEffectWrapper?.dispose();\r\n        this._skyViewLutEffectWrapper = null;\r\n        this._skyViewLutEffectRenderer?.dispose();\r\n        this._skyViewLutEffectRenderer = null;\r\n        this._aerialPerspectiveLutRenderTarget?.dispose();\r\n        this._aerialPerspectiveLutRenderTarget = null;\r\n        this._aerialPerspectiveLutEffectWrapper?.dispose();\r\n        this._aerialPerspectiveLutEffectWrapper = null;\r\n        this._aerialPerspectiveLutEffectRenderer?.dispose();\r\n        this._aerialPerspectiveLutEffectRenderer = null;\r\n        this._multiScatteringEffectWrapper?.dispose();\r\n        this._multiScatteringEffectWrapper = null;\r\n        this._multiScatteringLutRenderTarget?.dispose();\r\n        this._multiScatteringLutRenderTarget = null;\r\n        this._transmittanceLut?.dispose();\r\n        this._transmittanceLut = null;\r\n        this._diffuseSkyIrradianceLut?.dispose();\r\n        this._diffuseSkyIrradianceLut = null;\r\n        this._atmosphereUbo?.dispose();\r\n        this._atmosphereUbo = null;\r\n        this._effectRenderer?.dispose();\r\n        this._effectRenderer = null;\r\n        this._atmosphereUniformBufferAsArray.length = 0;\r\n\r\n        UnregisterMaterialPlugin(MaterialPlugin);\r\n    }\r\n\r\n    /**\r\n     * True if the atmosphere is enabled.\r\n     * @returns - True if the atmosphere is enabled.\r\n     */\r\n    public isEnabled() {\r\n        return this._isEnabled;\r\n    }\r\n\r\n    /**\r\n     * Sets the enabled state of the atmosphere.\r\n     * @param enabled - True to enable the atmosphere, false to disable it.\r\n     */\r\n    public setEnabled(enabled: boolean) {\r\n        this._isEnabled = enabled;\r\n    }\r\n\r\n    /**\r\n     * The class name of the {@link Atmosphere}.\r\n     * @returns - The class name of the atmosphere.\r\n     */\r\n    public getClassName(): string {\r\n        return \"Atmosphere\";\r\n    }\r\n\r\n    /**\r\n     * Gets the color of a light after being transmitted through the atmosphere to a point specified by its distance to the planet center and its geocentric normal.\r\n     * NOTE, the result is always a linear space color.\r\n     * @param directionToLight - The direction of the light.\r\n     * @param pointRadius - The distance from the planet center to the point in kilometers.\r\n     * @param pointGeocentricNormal - The geocentric normal at the point i.e., normalize(point - planet center).\r\n     * @param result - The color to store the result in.\r\n     * @returns The result color.\r\n     */\r\n    public getTransmittedColorToRef = <T extends IColor3Like>(directionToLight: IVector3Like, pointRadius: number, pointGeocentricNormal: IVector3Like, result: T): T =>\r\n        this._transmittanceLut!.getTransmittedColorToRef(directionToLight, pointRadius, pointGeocentricNormal, result);\r\n\r\n    /**\r\n     * Gets the diffuse sky irradiance. Result is always in linear space.\r\n     * @param directionToLight - The direction of the point to the light.\r\n     * @param pointRadius - The distance from the planet center to the point in kilometers.\r\n     * @param pointGeocentricNormal - The geocentric normal at the point: normalize(point - planet center).\r\n     * @param lightIrradiance - The irradiance of the light.\r\n     * @param result - The color to store the result in.\r\n     * @returns The result color.\r\n     */\r\n    public getDiffuseSkyIrradianceToRef = <T extends IColor3Like>(\r\n        directionToLight: IVector3Like,\r\n        pointRadius: number,\r\n        pointGeocentricNormal: IVector3Like,\r\n        lightIrradiance: number,\r\n        result: T\r\n    ): T =>\r\n        this._diffuseSkyIrradianceLut?.getDiffuseSkyIrradianceToRef(directionToLight, pointRadius, pointGeocentricNormal, lightIrradiance, result) ??\r\n        ((result.r = 0), (result.g = 0), (result.b = 0), result);\r\n\r\n    /**\r\n     * Creates a new {@link EffectWrapper} for the multiple scattering LUT\r\n     * @returns The newly created {@link EffectWrapper}.\r\n     */\r\n    private _createMultiScatteringEffectWrapper(): EffectWrapper {\r\n        const engine = this._engine;\r\n        const name = \"atmo-multiScattering\";\r\n        const ubo = this.uniformBuffer;\r\n        const useUbo = ubo.useUbo;\r\n\r\n        const defines = [\"#define POSITION_VEC2\"];\r\n        if (!this._groundAlbedo.equals(Color3.BlackReadOnly)) {\r\n            defines.push(\"#define USE_GROUND_ALBEDO\");\r\n        }\r\n\r\n        return new EffectWrapper({\r\n            engine,\r\n            name,\r\n            vertexShader: \"fullscreenTriangle\",\r\n            fragmentShader: \"multiScattering\",\r\n            attributeNames: [\"position\"],\r\n            uniformNames: [\"depth\", ...(useUbo ? [] : ubo.getUniformNames())],\r\n            uniformBuffers: useUbo ? [ubo.name] : [],\r\n            samplerNames: [\"transmittanceLut\"],\r\n            defines,\r\n            useShaderStore: true,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Draws the multiple scattering LUT using {@link EffectWrapper} and {@link EffectRenderer}.\r\n     */\r\n    private _drawMultiScatteringLut(): void {\r\n        const transmittanceLut = this._transmittanceLut!.renderTarget;\r\n        DrawEffect(\r\n            this._engine,\r\n            this._effectRenderer!,\r\n            this._multiScatteringEffectWrapper,\r\n            this._multiScatteringLutRenderTarget,\r\n            (effectRenderer, renderTarget, effect, engine) => {\r\n                this.bindUniformBufferToEffect(effect);\r\n                engine.bindFramebuffer(renderTarget!, undefined, undefined, undefined, true);\r\n                effectRenderer.bindBuffers(effect);\r\n                effect.setTexture(\"transmittanceLut\", transmittanceLut);\r\n                effectRenderer.draw();\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws the aerial perspective compositor using {@link EffectWrapper} and {@link EffectRenderer}.\r\n     */\r\n    public drawAerialPerspectiveCompositor(): void {\r\n        // Only works if we have a depth texture.\r\n        if (this.depthTexture === null) {\r\n            return;\r\n        }\r\n\r\n        const isEnabled = this.isEnabled();\r\n        if (!isEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Aerial perspective compositor only renders when inside the atmosphere.\r\n        const isOutsideAtmosphere = this._cameraAtmosphereVariables.clampedCameraRadius > this._physicalProperties.atmosphereRadius;\r\n        if (isOutsideAtmosphere) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        this._aerialPerspectiveCompositorEffectWrapper ??= CreateAerialPerspectiveCompositorEffectWrapper(\r\n            engine,\r\n            this.uniformBuffer,\r\n            this._isAerialPerspectiveLutEnabled,\r\n            this._isSkyViewLutEnabled,\r\n            this._isLinearSpaceComposition,\r\n            this._applyApproximateTransmittance,\r\n            this._aerialPerspectiveIntensity,\r\n            this._aerialPerspectiveRadianceBias\r\n        );\r\n\r\n        const skyViewLut = this._isSkyViewLutEnabled ? this.skyViewLutRenderTarget : null;\r\n        const multiScatteringLut = this._multiScatteringLutRenderTarget!;\r\n        const transmittanceLut = this._transmittanceLut!.renderTarget;\r\n        const aerialPerspectiveLut = this._isAerialPerspectiveLutEnabled ? this.aerialPerspectiveLutRenderTarget : null;\r\n        if (\r\n            !this._aerialPerspectiveCompositorEffectWrapper.isReady() ||\r\n            !(skyViewLut?.isReady() ?? true) ||\r\n            !multiScatteringLut.isReady() ||\r\n            !transmittanceLut.isReady() ||\r\n            !(aerialPerspectiveLut?.isReady() ?? true) ||\r\n            !this.depthTexture.isReady()\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        DrawEffect(\r\n            engine,\r\n            this._effectRenderer!,\r\n            this._aerialPerspectiveCompositorEffectWrapper,\r\n            null, // No render target, it will render to the current buffer.\r\n            (effectRenderer, _, effect) => {\r\n                if (this.depthTexture === null) {\r\n                    throw new Error(\"Depth texture is required for aerial perspective compositor.\");\r\n                }\r\n                this.bindUniformBufferToEffect(effect);\r\n                effectRenderer.bindBuffers(effect);\r\n                effect.setTexture(\"transmittanceLut\", transmittanceLut);\r\n                effect.setTexture(\"multiScatteringLut\", multiScatteringLut);\r\n                if (this._isSkyViewLutEnabled) {\r\n                    effect.setTexture(\"skyViewLut\", skyViewLut);\r\n                }\r\n                if (this._isAerialPerspectiveLutEnabled) {\r\n                    effect.setTexture(\"aerialPerspectiveLut\", aerialPerspectiveLut);\r\n                }\r\n                effect.setTexture(\"depthTexture\", this.depthTexture);\r\n                effectRenderer.draw();\r\n            },\r\n            1, // depth to use in the compositor.\r\n            this.applyApproximateTransmittance ? Constants.ALPHA_PREMULTIPLIED_PORTERDUFF : Constants.ALPHA_ONEONE,\r\n            true, // depthTest\r\n            false, // depthWrite\r\n            Constants.ALWAYS, // depthFunction\r\n            false // restoreDefaultFramebuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws the sky compositor using {@link EffectWrapper} and {@link EffectRenderer}.\r\n     */\r\n    public drawSkyCompositor(): void {\r\n        const isEnabled = this.isEnabled();\r\n        if (!isEnabled) {\r\n            return;\r\n        }\r\n\r\n        // The sky compositor only renders when inside the atmosphere.\r\n        const isOutsideAtmosphere = this._cameraAtmosphereVariables.clampedCameraRadius > this._physicalProperties.atmosphereRadius;\r\n        if (isOutsideAtmosphere) {\r\n            return;\r\n        }\r\n\r\n        if (this.depthTexture !== null && !this.depthTexture.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        this._skyCompositorEffectWrapper ??= CreateSkyCompositorEffectWrapper(\r\n            engine,\r\n            this.uniformBuffer,\r\n            this._isSkyViewLutEnabled,\r\n            this._isLinearSpaceComposition,\r\n            this._applyApproximateTransmittance\r\n        );\r\n\r\n        const skyViewLut = this._isSkyViewLutEnabled ? this.skyViewLutRenderTarget : null;\r\n        const multiScatteringLut = this._multiScatteringLutRenderTarget!;\r\n        const transmittanceLut = this._transmittanceLut!.renderTarget;\r\n        if (!this._skyCompositorEffectWrapper.isReady() || !(skyViewLut?.isReady() ?? true) || !multiScatteringLut.isReady() || !transmittanceLut.isReady()) {\r\n            return;\r\n        }\r\n\r\n        DrawEffect(\r\n            engine,\r\n            this._effectRenderer!,\r\n            this._skyCompositorEffectWrapper,\r\n            null, // No render target, it will render to the current buffer.\r\n            (effectRenderer, _, effect) => {\r\n                this.bindUniformBufferToEffect(effect);\r\n                effectRenderer.bindBuffers(effect);\r\n                effect.setTexture(\"multiScatteringLut\", multiScatteringLut);\r\n                effect.setTexture(\"transmittanceLut\", transmittanceLut);\r\n                if (this._isSkyViewLutEnabled) {\r\n                    effect.setTexture(\"skyViewLut\", skyViewLut);\r\n                }\r\n                effectRenderer.draw();\r\n            },\r\n            1, // depth to use in the compositor.\r\n            this._applyApproximateTransmittance ? Constants.ALPHA_PREMULTIPLIED_PORTERDUFF : Constants.ALPHA_ONEONE,\r\n            true, // depthTest\r\n            false, // depthWrite\r\n            Constants.EQUAL, // depthFunction\r\n            false // restoreDefaultFramebuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws the globe atmosphere compositor using {@link EffectWrapper} and {@link EffectRenderer}.\r\n     */\r\n    public drawGlobeAtmosphereCompositor(): void {\r\n        const isEnabled = this.isEnabled();\r\n        if (!isEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Globe atmosphere compositor only renders when outside the atmosphere.\r\n        const isOutsideAtmosphere = this._cameraAtmosphereVariables.clampedCameraRadius > this._physicalProperties.atmosphereRadius;\r\n        if (!isOutsideAtmosphere) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._engine;\r\n        this._globeAtmosphereCompositorEffectWrapper ??= CreateGlobeAtmosphereCompositorEffectWrapper(\r\n            engine,\r\n            this.uniformBuffer,\r\n            this._isSkyViewLutEnabled,\r\n            this._isLinearSpaceComposition,\r\n            this._applyApproximateTransmittance,\r\n            this._aerialPerspectiveIntensity,\r\n            this._aerialPerspectiveRadianceBias,\r\n            this.depthTexture !== null\r\n        );\r\n\r\n        const skyViewLut = this._isSkyViewLutEnabled ? this.skyViewLutRenderTarget : null;\r\n        const multiScatteringLut = this._multiScatteringLutRenderTarget!;\r\n        const transmittanceLut = this._transmittanceLut!.renderTarget;\r\n        if (!this._globeAtmosphereCompositorEffectWrapper.isReady() || !(skyViewLut?.isReady() ?? true) || !multiScatteringLut.isReady() || !transmittanceLut.isReady()) {\r\n            return;\r\n        }\r\n\r\n        if (this.depthTexture !== null && !this.depthTexture.isReady()) {\r\n            return;\r\n        }\r\n\r\n        DrawEffect(\r\n            engine,\r\n            this._effectRenderer!,\r\n            this._globeAtmosphereCompositorEffectWrapper,\r\n            null, // No render target, it will render to the current buffer.\r\n            (effectRenderer, _, effect) => {\r\n                this.bindUniformBufferToEffect(effect);\r\n                effectRenderer.bindBuffers(effect);\r\n                effect.setTexture(\"transmittanceLut\", transmittanceLut);\r\n                effect.setTexture(\"multiScatteringLut\", multiScatteringLut);\r\n                if (this._isSkyViewLutEnabled) {\r\n                    effect.setTexture(\"skyViewLut\", skyViewLut);\r\n                }\r\n                if (this.depthTexture !== null) {\r\n                    effect.setTexture(\"depthTexture\", this.depthTexture);\r\n                }\r\n                effectRenderer.draw();\r\n            },\r\n            1, // depth to use in the compositor.\r\n            this._applyApproximateTransmittance ? Constants.ALPHA_PREMULTIPLIED_PORTERDUFF : Constants.ALPHA_ONEONE,\r\n            true, // depthTest\r\n            false, // depthWrite\r\n            Constants.ALWAYS, // depthFunction\r\n            false // restoreDefaultFramebuffer\r\n        );\r\n    }\r\n\r\n    private _disposeSkyCompositor(): void {\r\n        this._skyCompositorEffectWrapper?.dispose();\r\n        this._skyCompositorEffectWrapper = null;\r\n    }\r\n\r\n    private _disposeAerialPerspectiveCompositor(): void {\r\n        this._aerialPerspectiveCompositorEffectWrapper?.dispose();\r\n        this._aerialPerspectiveCompositorEffectWrapper = null;\r\n    }\r\n\r\n    private _disposeGlobeAtmosphereCompositor(): void {\r\n        this._globeAtmosphereCompositorEffectWrapper?.dispose();\r\n        this._globeAtmosphereCompositorEffectWrapper = null;\r\n    }\r\n\r\n    /**\r\n     * Updates the camera variables that are specific to the atmosphere.\r\n     * @param camera - The camera to update the variables for.\r\n     */\r\n    private _updatePerCameraVariables(camera: Camera): void {\r\n        const light = this._lights[0];\r\n        this._directionToLight.copyFrom(light.direction);\r\n        this._directionToLight.scaleInPlace(-1);\r\n\r\n        const properties = this._physicalProperties;\r\n        const cameraAtmosphereVariables = this._cameraAtmosphereVariables;\r\n        cameraAtmosphereVariables.update(\r\n            camera,\r\n            properties.planetRadius,\r\n            properties.planetRadiusWithOffset,\r\n            properties.atmosphereRadius,\r\n            this._directionToLight,\r\n            this.originHeight\r\n        );\r\n\r\n        this._transmittanceLut!.updateLightParameters(light, cameraAtmosphereVariables.clampedCameraRadius, cameraAtmosphereVariables.cameraGeocentricNormal);\r\n        this._linearLightColor.copyFrom(light.diffuse);\r\n\r\n        this.getDiffuseSkyIrradianceToRef(this._directionToLight, 0, cameraAtmosphereVariables.cameraGeocentricNormal, this.lights[0].intensity, this._tempSceneAmbient);\r\n        if (!this.isLinearSpaceLight) {\r\n            this._tempSceneAmbient.toGammaSpaceToRef(this._tempSceneAmbient);\r\n        }\r\n        this.scene.ambientColor = this._tempSceneAmbient;\r\n\r\n        this.onAfterUpdateVariablesForCameraObservable.notifyObservers(camera);\r\n    }\r\n\r\n    /**\r\n     * Renders the lookup tables, some of which can vary per-camera.\r\n     * It is expected that updatePerCameraVariables was previously called.\r\n     * @param camera - The camera to render the LUTs for.\r\n     */\r\n    private _renderLutsForCamera(camera: Camera): void {\r\n        {\r\n            this.onBeforeLightVariablesUpdateObservable.notifyObservers();\r\n\r\n            const light = this.lights[0];\r\n            if (!this.isLinearSpaceLight) {\r\n                light.diffuse = light.diffuse.toGammaSpaceToRef(light.diffuse);\r\n                light.specular = light.specular.toGammaSpaceToRef(light.specular);\r\n            }\r\n            const intensity = light.intensity;\r\n            this._lightRadianceAtCamera.set(intensity * this._linearLightColor.r, intensity * this._linearLightColor.g, intensity * this._linearLightColor.b);\r\n        }\r\n\r\n        if (this.uniformBuffer.useUbo) {\r\n            this.updateUniformBuffer();\r\n        }\r\n\r\n        // Render the LUTs.\r\n        const isEnabled = this.isEnabled();\r\n        {\r\n            this.onBeforeRenderLutsForCameraObservable.notifyObservers(camera);\r\n\r\n            // After UBO update we can render the global LUTs which use some of these values on the GPU.\r\n            // TODO: Could break out update and UBOs to global vs. per-camera.\r\n            this.renderGlobalLuts();\r\n\r\n            // If atmosphere is enabled, render the per-camera LUTs (sky view and aerial perspective).\r\n            if (isEnabled && !this._transmittanceLut!.isDirty && this._hasRenderedMultiScatteringLut) {\r\n                if (this._isSkyViewLutEnabled) {\r\n                    this._drawSkyViewLut();\r\n                }\r\n\r\n                if (this._isAerialPerspectiveLutEnabled) {\r\n                    // Only need to render aerial perspective LUT when inside the atmosphere.\r\n                    if (this._cameraAtmosphereVariables.clampedCameraRadius <= this._physicalProperties.atmosphereRadius) {\r\n                        this._drawAerialPerspectiveLut();\r\n                    } else {\r\n                        // Make sure to clear the LUT to some initial value if this would have otherwise been the first time rendering it.\r\n                        if (!this._aerialPerspectiveLutHasBeenRendered) {\r\n                            this._clearAerialPerspectiveLut();\r\n                        }\r\n                    }\r\n                    this._aerialPerspectiveLutHasBeenRendered = true;\r\n                }\r\n            }\r\n\r\n            this.onAfterRenderLutsForCameraObservable.notifyObservers(camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders the lookup tables that do not depend on a camera position.\r\n     */\r\n    public renderGlobalLuts(): void {\r\n        const hasNewTransmittanceLut = this._transmittanceLut!.render();\r\n        if (hasNewTransmittanceLut) {\r\n            this._hasRenderedMultiScatteringLut = false;\r\n            this._diffuseSkyIrradianceLut?.markDirty();\r\n        }\r\n\r\n        if (!this._transmittanceLut!.isDirty && !this._hasRenderedMultiScatteringLut) {\r\n            this._multiScatteringEffectWrapper ??= this._createMultiScatteringEffectWrapper();\r\n            if (this._multiScatteringEffectWrapper?.isReady() && this._multiScatteringLutRenderTarget?.isReady()) {\r\n                this._drawMultiScatteringLut();\r\n                this._hasRenderedMultiScatteringLut = true;\r\n            }\r\n        }\r\n\r\n        if (!this._transmittanceLut!.isDirty && this._hasRenderedMultiScatteringLut) {\r\n            this._diffuseSkyIrradianceLut?.render(); // Will only render if needed.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds the atmosphere's uniform buffer to an {@link Effect}.\r\n     * @param effect - The {@link Effect} to bind the uniform buffer to.\r\n     */\r\n    public bindUniformBufferToEffect(effect: Effect): void {\r\n        const uniformBuffer = this.uniformBuffer;\r\n        const name = uniformBuffer.name;\r\n        uniformBuffer.bindToEffect(effect, name);\r\n        if (uniformBuffer.useUbo) {\r\n            uniformBuffer.bindUniformBuffer();\r\n        } else {\r\n            this.updateUniformBuffer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the atmosphere's uniform buffer.\r\n     */\r\n    public updateUniformBuffer(): void {\r\n        const physicalProperties = this._physicalProperties;\r\n        const cameraAtmosphereVariables = this._cameraAtmosphereVariables;\r\n        const ubo = this.uniformBuffer;\r\n\r\n        ubo.updateVector3(\"peakRayleighScattering\", physicalProperties.rayleighScattering);\r\n        ubo.updateFloat(\"planetRadius\", physicalProperties.planetRadius);\r\n        ubo.updateVector3(\"peakMieScattering\", physicalProperties.mieScattering);\r\n        ubo.updateFloat(\"atmosphereThickness\", physicalProperties.atmosphereThickness);\r\n        ubo.updateVector3(\"peakMieAbsorption\", physicalProperties.mieAbsorption);\r\n        ubo.updateFloat(\"planetRadiusSquared\", physicalProperties.planetRadiusSquared);\r\n        ubo.updateVector3(\"peakMieExtinction\", physicalProperties.mieExtinction);\r\n        ubo.updateFloat(\"atmosphereRadius\", physicalProperties.atmosphereRadius);\r\n        ubo.updateVector3(\"peakOzoneAbsorption\", physicalProperties.ozoneAbsorption);\r\n        ubo.updateFloat(\"atmosphereRadiusSquared\", physicalProperties.atmosphereRadiusSquared);\r\n        ubo.updateFloat(\"horizonDistanceToAtmosphereEdge\", physicalProperties.horizonDistanceToAtmosphereEdge);\r\n        ubo.updateFloat(\"horizonDistanceToAtmosphereEdgeSquared\", physicalProperties.horizonDistanceToAtmosphereEdgeSquared);\r\n        ubo.updateFloat(\"planetRadiusWithOffset\", physicalProperties.planetRadiusWithOffset);\r\n        ubo.updateFloat(\"planetRadiusOffset\", physicalProperties.planetRadiusOffset);\r\n        ubo.updateFloat(\"aerialPerspectiveRadianceBias\", this._aerialPerspectiveRadianceBias);\r\n        ubo.updateFloat(\"inverseAtmosphereThickness\", 1 / physicalProperties.atmosphereThickness);\r\n        ubo.updateFloat(\"aerialPerspectiveTransmittanceScale\", this._aerialPerspectiveTransmittanceScale);\r\n        ubo.updateMatrix(\"inverseViewProjectionWithoutTranslation\", cameraAtmosphereVariables.inverseViewProjectionMatrixWithoutTranslation);\r\n        ubo.updateVector3(\"directionToLight\", this._directionToLight);\r\n        ubo.updateFloat(\"multiScatteringIntensity\", this.multiScatteringIntensity);\r\n        ubo.updateVector3(\"directionToLightRelativeToCameraGeocentricNormal\", cameraAtmosphereVariables.directionToLightRelativeToCameraGeocentricNormal);\r\n        ubo.updateFloat(\"cameraRadius\", cameraAtmosphereVariables.cameraRadius);\r\n        ubo.updateVector3(\"lightRadianceAtCamera\", this._lightRadianceAtCamera);\r\n        ubo.updateFloat(\"diffuseSkyIrradianceDesaturationFactor\", this._diffuseSkyIrradianceDesaturationFactor);\r\n        ubo.updateColor3(\"groundAlbedo\", this._groundAlbedo);\r\n        ubo.updateFloat(\"aerialPerspectiveSaturation\", this._aerialPerspectiveSaturation);\r\n        ubo.updateVector3(\"minMultiScattering\", this._minimumMultiScattering);\r\n        ubo.updateFloat(\"diffuseSkyIrradianceIntensity\", this._diffuseSkyIrradianceIntensity);\r\n        ubo.updateVector3(\"cameraPositionGlobal\", cameraAtmosphereVariables.cameraPositionGlobal);\r\n        ubo.updateFloat(\"lightIntensity\", this.lights[0].getScaledIntensity());\r\n        ubo.updateVector3(\"clampedCameraPositionGlobal\", cameraAtmosphereVariables.clampedCameraPositionGlobal);\r\n        ubo.updateFloat(\"aerialPerspectiveIntensity\", this._aerialPerspectiveIntensity);\r\n        ubo.updateVector3(\"cameraGeocentricNormal\", cameraAtmosphereVariables.cameraGeocentricNormal);\r\n        ubo.updateFloat(\"clampedCameraRadius\", cameraAtmosphereVariables.clampedCameraRadius);\r\n        ubo.updateVector3(\"cameraForward\", cameraAtmosphereVariables.cameraForward);\r\n        ubo.updateFloat(\"clampedCameraHeight\", cameraAtmosphereVariables.clampedCameraHeight);\r\n        ubo.updateVector3(\"cameraPosition\", cameraAtmosphereVariables.cameraPosition);\r\n        ubo.updateFloat(\"cosCameraHorizonAngleFromZenith\", cameraAtmosphereVariables.cosCameraHorizonAngleFromZenith);\r\n        ubo.updateVector4(\"viewport\", cameraAtmosphereVariables.viewport);\r\n        ubo.updateColor3(\"additionalDiffuseSkyIrradiance\", this._additionalDiffuseSkyIrradiance);\r\n        ubo.updateFloat(\"cameraHeight\", cameraAtmosphereVariables.cameraHeight);\r\n        ubo.updateFloat(\"cameraNearPlane\", cameraAtmosphereVariables.cameraNearPlane);\r\n        ubo.updateFloat(\"originHeight\", this._originHeight);\r\n        ubo.updateFloat(\"sinCameraAtmosphereHorizonAngleFromNadir\", cameraAtmosphereVariables.sinCameraAtmosphereHorizonAngleFromNadir);\r\n        ubo.updateFloat(\"atmosphereExposure\", this._exposure);\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Draws the aerial perspective LUT using {@link EffectWrapper} and {@link EffectRenderer}.\r\n     */\r\n    private _drawAerialPerspectiveLut(): void {\r\n        const transmittanceLut = this._transmittanceLut!.renderTarget;\r\n        const multiScatteringLut = this._multiScatteringLutRenderTarget;\r\n        DrawEffect(\r\n            this._engine,\r\n            this._effectRenderer!,\r\n            this._aerialPerspectiveLutEffectWrapper,\r\n            this._aerialPerspectiveLutRenderTarget,\r\n            (effectRenderer, renderTarget, effect, engine) => {\r\n                this.bindUniformBufferToEffect(effect);\r\n                effect.setTexture(\"transmittanceLut\", transmittanceLut);\r\n                effect.setTexture(\"multiScatteringLut\", multiScatteringLut);\r\n                for (let layer = 0; layer < AerialPerspectiveLutLayers; layer++) {\r\n                    engine.bindFramebuffer(renderTarget!, undefined, undefined, undefined, true, undefined, layer);\r\n                    effectRenderer.bindBuffers(effect);\r\n                    effect.setFloat(\"layerIdx\", layer);\r\n                    effectRenderer.draw();\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    private _clearAerialPerspectiveLut(): void {\r\n        const renderTarget = this._aerialPerspectiveLutRenderTarget?.renderTarget;\r\n        if (renderTarget) {\r\n            const engine = this._engine;\r\n            const clearColor = { r: 0, g: 0, b: 0, a: 0 };\r\n            for (let layer = 0; layer < AerialPerspectiveLutLayers; layer++) {\r\n                engine.bindFramebuffer(renderTarget, undefined, undefined, undefined, true, undefined, layer);\r\n                engine.clear(clearColor, true, false, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws the sky view LUT using {@link EffectWrapper} and {@link EffectRenderer}.\r\n     */\r\n    private _drawSkyViewLut(): void {\r\n        const transmittanceLut = this._transmittanceLut!.renderTarget;\r\n        const multiScatteringLut = this._multiScatteringLutRenderTarget!;\r\n        DrawEffect(this._engine, this._effectRenderer!, this._skyViewLutEffectWrapper, this._skyViewLutRenderTarget, (effectRenderer, renderTarget, effect, engine) => {\r\n            this.bindUniformBufferToEffect(effect);\r\n            engine.bindFramebuffer(renderTarget!, undefined, undefined, undefined, true);\r\n            effectRenderer.bindBuffers(effect);\r\n            effect.setTexture(\"transmittanceLut\", transmittanceLut);\r\n            effect.setTexture(\"multiScatteringLut\", multiScatteringLut);\r\n            effectRenderer.draw();\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an {@link EffectWrapper} with the given parameters.\r\n * @param engine - The engine to use.\r\n * @param name - The name of the effect wrapper.\r\n * @param fragmentShader - The fragment shader source.\r\n * @param uniformNames - The uniform names to use.\r\n * @param samplerNames - The sampler names to use.\r\n * @param uniformBuffers - The uniform buffers to use.\r\n * @param defineNames - Array of define names to prepend with \"#define \".\r\n * @returns The effect wrapper.\r\n */\r\nconst CreateEffectWrapper = (\r\n    engine: AbstractEngine,\r\n    name: string,\r\n    fragmentShader: string,\r\n    uniformNames?: string[],\r\n    samplerNames?: string[],\r\n    uniformBuffers?: string[],\r\n    defineNames?: string[]\r\n): EffectWrapper => {\r\n    const defines = defineNames?.map((defineName) => `#define ${defineName}`) ?? [];\r\n\r\n    return new EffectWrapper({\r\n        engine,\r\n        name,\r\n        vertexShader: \"fullscreenTriangle\",\r\n        fragmentShader,\r\n        attributeNames: [\"position\"],\r\n        uniformNames,\r\n        uniformBuffers,\r\n        samplerNames,\r\n        defines,\r\n        useShaderStore: true,\r\n    });\r\n};\r\n\r\nconst CreateRenderTargetTexture = (\r\n    name: string,\r\n    size: number | { width: number; height: number; layers?: number },\r\n    scene: Scene,\r\n    options?: RenderTargetTextureOptions\r\n): RenderTargetTexture => {\r\n    const caps = scene.getEngine().getCaps();\r\n    const textureType = caps.textureHalfFloatRender\r\n        ? Constants.TEXTURETYPE_HALF_FLOAT\r\n        : caps.textureFloatRender\r\n          ? Constants.TEXTURETYPE_FLOAT\r\n          : Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    const rtOptions: RenderTargetTextureOptions = {\r\n        generateMipMaps: false,\r\n        generateDepthBuffer: false,\r\n        generateStencilBuffer: false,\r\n        gammaSpace: false,\r\n        samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n        type: textureType,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        ...options,\r\n    };\r\n    const renderTarget = new RenderTargetTexture(name, size, scene, rtOptions);\r\n\r\n    renderTarget.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    renderTarget.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n    renderTarget.anisotropicFilteringLevel = 1;\r\n    renderTarget.skipInitialClear = true;\r\n    return renderTarget;\r\n};\r\n\r\n/**\r\n * Common setup and teardown for drawing LUTs or composition passes.\r\n * @param engine - The engine to use.\r\n * @param effectRenderer - The effect renderer to use.\r\n * @param effectWrapper - The effect wrapper to use.\r\n * @param renderTarget - The render target.\r\n * @param drawCallback - Callback function that performs the drawing.\r\n * @param depth - The depth value to set in the effect.\r\n * @param alphaMode - The alpha mode to set before drawing.\r\n * @param depthTest - Whether to enable depth testing.\r\n * @param depthWrite - Optional depth write state to set before drawing.\r\n * @param depthFunction - The depth function to set before drawing.\r\n * @param restoreDefaultFramebuffer - Whether to restore the default framebuffer after drawing.\r\n */\r\nconst DrawEffect = (\r\n    engine: AbstractEngine,\r\n    effectRenderer: EffectRenderer,\r\n    effectWrapper: Nullable<EffectWrapper>,\r\n    renderTarget: Nullable<RenderTargetTexture>,\r\n    drawCallback: (effectRenderer: EffectRenderer, renderTarget: Nullable<RenderTargetWrapper>, effect: Effect, engine: AbstractEngine) => void,\r\n    depth = 0,\r\n    alphaMode = Constants.ALPHA_DISABLE,\r\n    depthTest = true,\r\n    depthWrite?: boolean,\r\n    depthFunction = Constants.LEQUAL,\r\n    restoreDefaultFramebuffer = true\r\n): void => {\r\n    if ((renderTarget !== null && !renderTarget.isReady()) || !effectWrapper?.isReady()) {\r\n        return;\r\n    }\r\n\r\n    // Set additional depth/stencil states before calling applyEffectWrapper.\r\n    const currentDepthWrite = engine.getDepthWrite();\r\n    if (depthWrite !== undefined) {\r\n        engine.setDepthWrite(depthWrite);\r\n    }\r\n    const currentDepthFunction = engine.getDepthFunction();\r\n    engine.setDepthFunction(depthFunction);\r\n\r\n    // Likewise with the alpha mode, which can affect depth state too.\r\n    const currentAlphaMode = engine.getAlphaMode();\r\n    if (alphaMode !== Constants.ALPHA_DISABLE) {\r\n        engine.setAlphaMode(alphaMode);\r\n    }\r\n\r\n    effectRenderer.saveStates();\r\n    effectRenderer.setViewport();\r\n    effectRenderer.applyEffectWrapper(effectWrapper, depthTest); // Note, stencil is false by default.\r\n\r\n    const effect = effectWrapper.effect;\r\n\r\n    effect.setFloat(\"depth\", depth);\r\n\r\n    // Call the specific drawing logic.\r\n    drawCallback(effectRenderer, renderTarget?.renderTarget!, effect, engine);\r\n\r\n    // Restore state (order matters!)\r\n    engine.setAlphaMode(currentAlphaMode);\r\n    if (currentDepthWrite !== undefined) {\r\n        engine.setDepthWrite(currentDepthWrite);\r\n    }\r\n    if (currentDepthFunction) {\r\n        engine.setDepthFunction(currentDepthFunction);\r\n    }\r\n    effectRenderer.restoreStates();\r\n\r\n    // And restore the default framebuffer.\r\n    if (restoreDefaultFramebuffer) {\r\n        engine.restoreDefaultFramebuffer();\r\n    }\r\n};\r\n\r\n/**\r\n * Creates an EffectWrapper for the sky compositor.\r\n * @param engine - The engine to use.\r\n * @param uniformBuffer - The uniform buffer to use.\r\n * @param isSkyViewLutEnabled - Whether the sky view LUT is enabled.\r\n * @param isLinearSpaceComposition - Whether composition is in linear space.\r\n * @param applyApproximateTransmittance - Whether to apply approximate transmittance.\r\n * @returns The created EffectWrapper.\r\n */\r\nconst CreateSkyCompositorEffectWrapper = (\r\n    engine: AbstractEngine,\r\n    uniformBuffer: UniformBuffer,\r\n    isSkyViewLutEnabled: boolean,\r\n    isLinearSpaceComposition: boolean,\r\n    applyApproximateTransmittance: boolean\r\n): EffectWrapper => {\r\n    const useUbo = uniformBuffer.useUbo;\r\n    const defines = [\"COMPUTE_WORLD_RAY\"];\r\n    if (isSkyViewLutEnabled) {\r\n        defines.push(\"USE_SKY_VIEW_LUT\");\r\n    }\r\n    if (!isLinearSpaceComposition) {\r\n        defines.push(\"OUTPUT_TO_SRGB\");\r\n    }\r\n    if (applyApproximateTransmittance) {\r\n        defines.push(\"APPLY_TRANSMITTANCE_BLENDING\");\r\n    }\r\n    const textures = isSkyViewLutEnabled ? [\"skyViewLut\"] : [\"transmittanceLut\", \"multiScatteringLut\"];\r\n    return CreateEffectWrapper(\r\n        engine,\r\n        \"atmo-skyCompositor\",\r\n        \"compositeSky\",\r\n        [\"depth\", ...(useUbo ? [] : uniformBuffer.getUniformNames())],\r\n        textures,\r\n        useUbo ? [uniformBuffer.name] : [],\r\n        defines\r\n    );\r\n};\r\n\r\n/**\r\n * Creates an EffectWrapper for the aerial perspective LUT.\r\n * @param engine - The engine to use.\r\n * @param uniformBuffer - The uniform buffer to use.\r\n * @returns The created EffectWrapper.\r\n */\r\nconst CreateAerialPerspectiveEffectWrapper = (engine: AbstractEngine, uniformBuffer: UniformBuffer): EffectWrapper =>\r\n    CreateEffectWrapper(\r\n        engine,\r\n        \"atmo-aerialPerspective\",\r\n        \"aerialPerspective\",\r\n        [\"layerIdx\", \"depth\", ...(uniformBuffer.useUbo ? [] : uniformBuffer.getUniformNames())],\r\n        [\"transmittanceLut\", \"multiScatteringLut\"],\r\n        uniformBuffer.useUbo ? [uniformBuffer.name] : [],\r\n        [\"COMPUTE_WORLD_RAY\"]\r\n    );\r\n\r\n/**\r\n * Creates an EffectWrapper for the aerial perspective compositor.\r\n * @param engine - The engine to use.\r\n * @param uniformBuffer - The uniform buffer.\r\n * @param isAerialPerspectiveLutEnabled - Whether the aerial perspective LUT is enabled.\r\n * @param isSkyViewLutEnabled - Whether the sky view LUT is enabled.\r\n * @param isLinearSpaceComposition - Whether composition is in linear space.\r\n * @param applyApproximateTransmittance - Whether to apply approximate transmittance.\r\n * @param aerialPerspectiveIntensity - The aerial perspective intensity.\r\n * @param aerialPerspectiveRadianceBias - The aerial perspective radiance bias.\r\n * @returns The created EffectWrapper.\r\n */\r\nconst CreateAerialPerspectiveCompositorEffectWrapper = (\r\n    engine: AbstractEngine,\r\n    uniformBuffer: UniformBuffer,\r\n    isAerialPerspectiveLutEnabled: boolean,\r\n    isSkyViewLutEnabled: boolean,\r\n    isLinearSpaceComposition: boolean,\r\n    applyApproximateTransmittance: boolean,\r\n    aerialPerspectiveIntensity: number,\r\n    aerialPerspectiveRadianceBias: number\r\n): EffectWrapper => {\r\n    const useUbo = uniformBuffer.useUbo;\r\n    const defines = [\"COMPUTE_WORLD_RAY\"];\r\n    if (isAerialPerspectiveLutEnabled) {\r\n        defines.push(\"USE_AERIAL_PERSPECTIVE_LUT\");\r\n    }\r\n    if (isSkyViewLutEnabled) {\r\n        defines.push(\"USE_SKY_VIEW_LUT\");\r\n    }\r\n    if (aerialPerspectiveIntensity !== 1) {\r\n        defines.push(\"APPLY_AERIAL_PERSPECTIVE_INTENSITY\");\r\n    }\r\n    if (!isLinearSpaceComposition) {\r\n        defines.push(\"OUTPUT_TO_SRGB\");\r\n    }\r\n    if (applyApproximateTransmittance) {\r\n        defines.push(\"APPLY_TRANSMITTANCE_BLENDING\");\r\n    }\r\n    if (aerialPerspectiveRadianceBias !== 0.0) {\r\n        defines.push(\"APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS\");\r\n    }\r\n\r\n    const samplers = [\"transmittanceLut\", \"multiScatteringLut\", \"depthTexture\"];\r\n    if (isSkyViewLutEnabled) {\r\n        samplers.push(\"skyViewLut\");\r\n    }\r\n    if (isAerialPerspectiveLutEnabled) {\r\n        samplers.push(\"aerialPerspectiveLut\");\r\n    }\r\n\r\n    return CreateEffectWrapper(\r\n        engine,\r\n        \"atmo-aerialPerspectiveCompositor\",\r\n        \"compositeAerialPerspective\",\r\n        [\"depth\", ...(useUbo ? [] : uniformBuffer.getUniformNames())],\r\n        samplers,\r\n        useUbo ? [uniformBuffer.name] : [],\r\n        defines\r\n    );\r\n};\r\n\r\n/**\r\n * Creates an EffectWrapper for the globe atmosphere compositor.\r\n * @param engine - The engine to use.\r\n * @param uniformBuffer - The uniform buffer to use.\r\n * @param isSkyViewLutEnabled - Whether the sky view LUT is enabled.\r\n * @param isLinearSpaceComposition - Whether composition is in linear space.\r\n * @param applyApproximateTransmittance - Whether to apply approximate transmittance.\r\n * @param aerialPerspectiveIntensity - The aerial perspective intensity.\r\n * @param aerialPerspectiveRadianceBias - The aerial perspective radiance bias.\r\n * @param hasDepthTexture - Whether a depth texture is available.\r\n * @returns The created EffectWrapper.\r\n */\r\nconst CreateGlobeAtmosphereCompositorEffectWrapper = (\r\n    engine: AbstractEngine,\r\n    uniformBuffer: UniformBuffer,\r\n    isSkyViewLutEnabled: boolean,\r\n    isLinearSpaceComposition: boolean,\r\n    applyApproximateTransmittance: boolean,\r\n    aerialPerspectiveIntensity: number,\r\n    aerialPerspectiveRadianceBias: number,\r\n    hasDepthTexture: boolean\r\n): EffectWrapper => {\r\n    const useUbo = uniformBuffer.useUbo;\r\n    const defines = [\"COMPUTE_WORLD_RAY\"];\r\n    if (isSkyViewLutEnabled) {\r\n        defines.push(\"USE_SKY_VIEW_LUT\");\r\n    }\r\n    if (aerialPerspectiveIntensity !== 1) {\r\n        defines.push(\"APPLY_AERIAL_PERSPECTIVE_INTENSITY\");\r\n    }\r\n    if (!isLinearSpaceComposition) {\r\n        defines.push(\"OUTPUT_TO_SRGB\");\r\n    }\r\n    if (hasDepthTexture) {\r\n        defines.push(\"HAS_DEPTH_TEXTURE\");\r\n    }\r\n    if (applyApproximateTransmittance) {\r\n        defines.push(\"APPLY_TRANSMITTANCE_BLENDING\");\r\n    }\r\n    if (aerialPerspectiveRadianceBias !== 0.0) {\r\n        defines.push(\"APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS\");\r\n    }\r\n\r\n    const samplers = [\"transmittanceLut\", \"multiScatteringLut\"];\r\n    if (isSkyViewLutEnabled) {\r\n        samplers.push(\"skyViewLut\");\r\n    }\r\n    if (hasDepthTexture) {\r\n        samplers.push(\"depthTexture\");\r\n    }\r\n\r\n    return CreateEffectWrapper(\r\n        engine,\r\n        \"atmo-globeAtmosphereCompositor\",\r\n        \"compositeGlobeAtmosphere\",\r\n        [\"depth\", ...(useUbo ? [] : uniformBuffer.getUniformNames())],\r\n        samplers,\r\n        useUbo ? [uniformBuffer.name] : [],\r\n        defines\r\n    );\r\n};\r\n\r\n/**\r\n * Creates an EffectWrapper for the sky view LUT.\r\n * @param engine - The engine to use.\r\n * @param uniformBuffer - The uniform buffer to use.\r\n * @returns The created EffectWrapper.\r\n */\r\nconst CreateSkyViewEffectWrapper = (engine: AbstractEngine, uniformBuffer: UniformBuffer): EffectWrapper =>\r\n    CreateEffectWrapper(\r\n        engine,\r\n        \"atmo-skyView\",\r\n        \"skyView\",\r\n        [\"depth\", ...(uniformBuffer.useUbo ? [] : uniformBuffer.getUniformNames())],\r\n        [\"transmittanceLut\", \"multiScatteringLut\"],\r\n        uniformBuffer.useUbo ? [uniformBuffer.name] : []\r\n    );\r\n","import type { Scene } from \"core/scene\";\r\nimport { Matrix, Quaternion, Vector3 } from \"core/Maths/math\";\r\n\r\nimport type { HtmlMesh } from \"./htmlMesh\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { RenderingGroup } from \"core/Rendering/renderingGroup\";\r\n\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { AbstractEngine } from \"core/Engines\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nconst PositionUpdateFailMessage = \"Failed to update html mesh renderer position due to failure to get canvas rect.  HtmlMesh instances may not render correctly\";\r\nconst BabylonUnitsToPixels = 100;\r\n\r\n/**\r\n * A function that compares two submeshes and returns a number indicating which\r\n * should be rendered first.\r\n */\r\ntype RenderOrderFunction = (subMeshA: SubMesh, subMeshB: SubMesh) => number;\r\n\r\ntype RenderLayerElements = {\r\n    container: HTMLElement;\r\n    domElement: HTMLElement;\r\n    cameraElement: HTMLElement;\r\n};\r\n\r\n// Returns a function that ensures that HtmlMeshes are rendered before all other meshes.\r\n// Note this will only be applied to group 0.\r\n// If neither mesh is an HtmlMesh, then the default render order is used\r\n// This prevents HtmlMeshes from appearing in front of other meshes when they are behind them\r\nconst RenderOrderFunc = (defaultRenderOrder: RenderOrderFunction): RenderOrderFunction => {\r\n    return (subMeshA: SubMesh, subMeshB: SubMesh) => {\r\n        const meshA = subMeshA.getMesh();\r\n        const meshB = subMeshB.getMesh();\r\n\r\n        // Use property check instead of instanceof since it is less expensive and\r\n        // this will be called many times per frame\r\n        const meshIsHtmlMeshA = (meshA as any)[\"isHtmlMesh\"];\r\n        const meshIsHtmlMeshB = (meshB as any)[\"isHtmlMesh\"];\r\n        if (meshIsHtmlMeshA) {\r\n            return meshIsHtmlMeshB ? (meshA.absolutePosition.z <= meshB.absolutePosition.z ? 1 : -1) : -1;\r\n        } else {\r\n            return meshIsHtmlMeshB ? 1 : defaultRenderOrder(subMeshA, subMeshB);\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * An instance of this is required to render HtmlMeshes in the scene.\r\n * if using HtmlMeshes, you must not set render order for group 0 using\r\n * scene.setRenderingOrder.  You must instead pass the compare functions\r\n * to the HtmlMeshRenderer constructor.  If you do not, then your render\r\n * order will be overwritten if the HtmlMeshRenderer is created after and\r\n * the HtmlMeshes will not render correctly (they will appear in front of\r\n * meshes that are actually in front of them) if the HtmlMeshRenderer is\r\n * created before.\r\n */\r\nexport class HtmlMeshRenderer {\r\n    /**\r\n     * Global scale factor applied to the homogeneous `w` component (m[15]) of the\r\n     * transformation matrix when projecting 3D objects into pixel space.\r\n     *\r\n     * This value is used to balance Babylon units against screen pixels, ensuring\r\n     * that HTML-mapped or screen-space objects appear with the correct relative\r\n     * size. Adjust with care, as changing it affects the projection scale of all\r\n     * transformed objects.\r\n     *\r\n     *  The default value is `0.00001`, which works well when 1 Babylon unit\r\n     *  corresponds to 1 meter, and the typical screen resolution is around\r\n     * 100 pixels per meter (i.e., 1 pixel per centimeter).\r\n     */\r\n    public static PROJECTION_SCALE_FACTOR = 0.00001;\r\n\r\n    private _containerId?: string;\r\n    private _inSceneElements?: RenderLayerElements | null;\r\n    private _overlayElements?: RenderLayerElements | null;\r\n    private _engine: AbstractEngine;\r\n\r\n    private _cache = {\r\n        cameraData: { fov: 0, position: new Vector3(), style: \"\" },\r\n        htmlMeshData: new WeakMap<object, { style: string }>(),\r\n    };\r\n    private _width = 0;\r\n    private _height = 0;\r\n    private _heightHalf = 0;\r\n\r\n    private _cameraWorldMatrix?: Matrix;\r\n\r\n    // Create some refs to avoid creating new objects every frame\r\n    private _temp = {\r\n        scaleTransform: new Vector3(),\r\n        rotationTransform: new Quaternion(),\r\n        positionTransform: new Vector3(),\r\n        objectMatrix: Matrix.Identity(),\r\n        cameraWorldMatrix: Matrix.Identity(),\r\n        cameraRotationMatrix: Matrix.Identity(),\r\n        cameraWorldMatrixAsArray: new Array(16),\r\n    };\r\n\r\n    // Keep track of DPR so we can resize if DPR changes\r\n    // Otherwise the DOM content will scale, but the mesh won't\r\n    private _lastDevicePixelRatio = window.devicePixelRatio;\r\n\r\n    // Keep track of camera matrix changes so we only update the\r\n    // DOM element styles when necessary\r\n    private _cameraMatrixUpdated = true;\r\n\r\n    // Keep track of position changes so we only update the DOM element\r\n    // styles when necessary\r\n    private _previousCanvasDocumentPosition = {\r\n        top: 0,\r\n        left: 0,\r\n    };\r\n\r\n    private _renderObserver: Observer<Scene> | null = null;\r\n\r\n    /**\r\n     * Contruct an instance of HtmlMeshRenderer\r\n     * @param scene\r\n     * @param options object containing the following optional properties:\r\n     * @returns\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        {\r\n            parentContainerId = null,\r\n            _containerId = \"css-container\",\r\n            enableOverlayRender = true,\r\n            defaultOpaqueRenderOrder = RenderingGroup.PainterSortCompare,\r\n            defaultAlphaTestRenderOrder = RenderingGroup.PainterSortCompare,\r\n            defaultTransparentRenderOrder = RenderingGroup.defaultTransparentSortCompare,\r\n        }: {\r\n            parentContainerId?: string | null;\r\n            _containerId?: string;\r\n            defaultOpaqueRenderOrder?: RenderOrderFunction;\r\n            defaultAlphaTestRenderOrder?: RenderOrderFunction;\r\n            defaultTransparentRenderOrder?: RenderOrderFunction;\r\n            enableOverlayRender?: boolean;\r\n        } = {}\r\n    ) {\r\n        // Requires a browser to work.  Only init if we are in a browser\r\n        if (typeof document === \"undefined\") {\r\n            return;\r\n        }\r\n        this._containerId = _containerId;\r\n        this._init(scene, parentContainerId, enableOverlayRender, defaultOpaqueRenderOrder, defaultAlphaTestRenderOrder, defaultTransparentRenderOrder);\r\n    }\r\n\r\n    /**\r\n     * Dispose of the HtmlMeshRenderer\r\n     */\r\n    public dispose() {\r\n        if (this._renderObserver) {\r\n            this._renderObserver.remove();\r\n            this._renderObserver = null;\r\n        }\r\n\r\n        this._overlayElements?.container.remove();\r\n        this._overlayElements = null;\r\n\r\n        this._inSceneElements?.container.remove();\r\n        this._inSceneElements = null;\r\n    }\r\n\r\n    protected _init(\r\n        scene: Scene,\r\n        parentContainerId: string | null,\r\n        enableOverlayRender: boolean,\r\n        defaultOpaqueRenderOrder: RenderOrderFunction,\r\n        defaultAlphaTestRenderOrder: RenderOrderFunction,\r\n        defaultTransparentRenderOrder: RenderOrderFunction\r\n    ): void {\r\n        // Requires a browser to work.  Only init if we are in a browser\r\n        if (typeof document === \"undefined\") {\r\n            return;\r\n        }\r\n\r\n        // Create the DOM containers\r\n        let parentContainer = parentContainerId ? document.getElementById(parentContainerId) : document.body;\r\n\r\n        if (!parentContainer) {\r\n            parentContainer = document.body;\r\n        }\r\n\r\n        // if the container already exists, then remove it\r\n        const inSceneContainerId = `${this._containerId}_in_scene`;\r\n        this._inSceneElements = this._createRenderLayerElements(inSceneContainerId);\r\n\r\n        parentContainer.insertBefore(this._inSceneElements.container, parentContainer.firstChild);\r\n\r\n        if (enableOverlayRender) {\r\n            const overlayContainerId = `${this._containerId}_overlay`;\r\n            this._overlayElements = this._createRenderLayerElements(overlayContainerId);\r\n            const zIndex = +(scene.getEngine().getRenderingCanvas()!.style.zIndex ?? \"0\") + 1;\r\n            this._overlayElements.container.style.zIndex = `${zIndex}`;\r\n            this._overlayElements.container.style.pointerEvents = \"none\";\r\n            parentContainer.insertBefore(this._overlayElements.container, parentContainer.firstChild);\r\n        }\r\n        this._engine = scene.getEngine();\r\n        const clientRect = this._engine.getRenderingCanvasClientRect();\r\n        if (!clientRect) {\r\n            throw new Error(\"Failed to get client rect for rendering canvas\");\r\n        }\r\n\r\n        // Set the size and resize behavior\r\n        this._setSize(clientRect.width, clientRect.height);\r\n\r\n        this._engine.onResizeObservable.add(() => {\r\n            const clientRect = this._engine.getRenderingCanvasClientRect();\r\n            if (clientRect) {\r\n                this._setSize(clientRect.width, clientRect.height);\r\n            }\r\n        });\r\n\r\n        let projectionObs: Observer<Camera>;\r\n        let matrixObs: Observer<Camera>;\r\n\r\n        const observeCamera = () => {\r\n            const camera = scene.activeCamera;\r\n            if (camera) {\r\n                projectionObs = camera.onProjectionMatrixChangedObservable.add(() => {\r\n                    this._onCameraMatrixChanged(camera);\r\n                });\r\n                matrixObs = camera.onViewMatrixChangedObservable.add(() => {\r\n                    this._onCameraMatrixChanged(camera);\r\n                });\r\n            }\r\n        };\r\n\r\n        observeCamera();\r\n\r\n        scene.onActiveCameraChanged.add(() => {\r\n            if (projectionObs) {\r\n                scene.activeCamera?.onProjectionMatrixChangedObservable.remove(projectionObs);\r\n            }\r\n            if (matrixObs) {\r\n                scene.activeCamera?.onViewMatrixChangedObservable.remove(matrixObs);\r\n            }\r\n            observeCamera();\r\n        });\r\n\r\n        // We need to make sure that HtmlMeshes are rendered before all other meshes\r\n        // so that they don't appear in front of meshes that are actually in front of them\r\n        // Updating the render order isn't ideal, but it is the only way to acheive this\r\n        // The implication is that an app using the HtmlMeshRendered must set the scene render order\r\n        // via the HtmlMeshRendered constructor\r\n        const opaqueRenderOrder = RenderOrderFunc(defaultOpaqueRenderOrder);\r\n        const alphaTestRenderOrder = RenderOrderFunc(defaultAlphaTestRenderOrder);\r\n        const transparentRenderOrder = RenderOrderFunc(defaultTransparentRenderOrder);\r\n        scene.setRenderingOrder(0, opaqueRenderOrder, alphaTestRenderOrder, transparentRenderOrder);\r\n\r\n        this._renderObserver = scene.onBeforeRenderObservable.add(() => {\r\n            this._render(scene, scene.activeCamera as Camera);\r\n        });\r\n    }\r\n\r\n    private _createRenderLayerElements(containerId: string): RenderLayerElements {\r\n        const existingContainer = document.getElementById(containerId);\r\n        if (existingContainer) {\r\n            existingContainer.remove();\r\n        }\r\n        const container = document.createElement(\"div\");\r\n        container.id = containerId;\r\n        container.style.position = \"absolute\";\r\n        container.style.width = \"100%\";\r\n        container.style.height = \"100%\";\r\n        container.style.zIndex = \"-1\";\r\n\r\n        const domElement = document.createElement(\"div\");\r\n        domElement.style.overflow = \"hidden\";\r\n\r\n        const cameraElement = document.createElement(\"div\");\r\n\r\n        cameraElement.style.webkitTransformStyle = \"preserve-3d\";\r\n        cameraElement.style.transformStyle = \"preserve-3d\";\r\n\r\n        cameraElement.style.pointerEvents = \"none\";\r\n\r\n        domElement.appendChild(cameraElement);\r\n        container.appendChild(domElement);\r\n        return {\r\n            container,\r\n            domElement,\r\n            cameraElement,\r\n        };\r\n    }\r\n\r\n    protected _getSize(): { width: number; height: number } {\r\n        return {\r\n            width: this._width,\r\n            height: this._height,\r\n        };\r\n    }\r\n\r\n    protected _setSize(width: number, height: number): void {\r\n        this._width = width;\r\n        this._height = height;\r\n        this._heightHalf = this._height / 2;\r\n\r\n        if (!this._inSceneElements || !this._overlayElements) {\r\n            return;\r\n        }\r\n\r\n        const domElements = [this._inSceneElements.domElement, this._overlayElements.domElement, this._inSceneElements.cameraElement, this._overlayElements.cameraElement];\r\n        for (const dom of domElements) {\r\n            if (dom) {\r\n                dom.style.width = `${width}px`;\r\n                dom.style.height = `${height}px`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // prettier-ignore\r\n    protected _getCameraCssMatrix(matrix: Matrix): string {\r\n        const elements = matrix.m;\r\n        return `matrix3d(${\r\n            this._epsilon( elements[0] )\r\n        },${\r\n            this._epsilon( - elements[1] )\r\n        },${\r\n            this._epsilon( elements[2] )\r\n        },${\r\n            this._epsilon( elements[3] )\r\n        },${\r\n            this._epsilon( elements[4] )\r\n        },${\r\n            this._epsilon( - elements[5] )\r\n        },${\r\n            this._epsilon( elements[6] )\r\n        },${\r\n            this._epsilon( elements[7] )\r\n        },${\r\n            this._epsilon( elements[8] )\r\n        },${\r\n            this._epsilon( - elements[9] )\r\n        },${\r\n            this._epsilon( elements[10] )\r\n        },${\r\n            this._epsilon( elements[11] )\r\n        },${\r\n            this._epsilon( elements[12] )\r\n        },${\r\n            this._epsilon( - elements[13] )\r\n        },${\r\n            this._epsilon( elements[14] )\r\n        },${\r\n            this._epsilon( elements[15] )\r\n        })`;\r\n    }\r\n\r\n    // Convert a Babylon world matrix to a CSS matrix\r\n    // This also handles conversion from BJS left handed coords\r\n    // to CSS right handed coords\r\n    // prettier-ignore\r\n    protected _getHtmlContentCssMatrix(matrix: Matrix, useRightHandedSystem: boolean): string {\r\n        const elements = matrix.m;\r\n        // In a right handed coordinate system, the elements 11 to 14 have to change their direction\r\n        const direction = useRightHandedSystem ? -1 : 1;\r\n        const matrix3d = `matrix3d(${\r\n            this._epsilon( elements[0] )\r\n        },${\r\n            this._epsilon( elements[1] )\r\n        },${\r\n            this._epsilon( elements[2] * -direction )\r\n        },${\r\n            this._epsilon( elements[3] )\r\n        },${\r\n            this._epsilon( - elements[4] )\r\n        },${\r\n            this._epsilon( - elements[5] )\r\n        },${\r\n            this._epsilon( elements[6]  * direction )\r\n        },${\r\n            this._epsilon( - elements[7] )\r\n        },${\r\n            this._epsilon( elements[8] * -direction )\r\n        },${\r\n            this._epsilon( elements[9] * -direction )\r\n        },${\r\n            this._epsilon( elements[10] )\r\n        },${\r\n            this._epsilon( elements[11] * direction )\r\n        },${\r\n            this._epsilon( elements[12] * direction )\r\n        },${\r\n            this._epsilon( elements[13] * direction )\r\n        },${\r\n            this._epsilon( elements[14] * direction )\r\n        },${\r\n            this._epsilon( elements[15] )\r\n        })`;\r\n        return matrix3d;\r\n    }\r\n\r\n    protected _getTransformationMatrix(htmlMesh: HtmlMesh, useRightHandedSystem: boolean): Matrix {\r\n        // Get the camera world matrix\r\n        // Make sure the camera world matrix is up to date\r\n        if (!this._cameraWorldMatrix) {\r\n            this._cameraWorldMatrix = htmlMesh.getScene().activeCamera?.getWorldMatrix();\r\n        }\r\n        if (!this._cameraWorldMatrix) {\r\n            return Matrix.Identity();\r\n        }\r\n\r\n        const objectWorldMatrix = htmlMesh.getWorldMatrix();\r\n\r\n        // Scale the object matrix by the base scale factor for the mesh\r\n        // which is the ratio of the mesh width/height to the renderer\r\n        // width/height divided by the babylon units to pixels ratio\r\n        let widthScaleFactor = 1;\r\n        let heightScaleFactor = 1;\r\n        if (htmlMesh.sourceWidth && htmlMesh.sourceHeight) {\r\n            widthScaleFactor = htmlMesh.width! / (htmlMesh.sourceWidth / BabylonUnitsToPixels);\r\n            heightScaleFactor = htmlMesh.height! / (htmlMesh.sourceHeight / BabylonUnitsToPixels);\r\n        }\r\n\r\n        // Apply the scale to the object's world matrix.  Note we aren't scaling\r\n        // the object, just getting a matrix as though it were scaled, so we can\r\n        // scale the content\r\n        const scaleTransform = this._temp.scaleTransform;\r\n        const rotationTransform = this._temp.rotationTransform;\r\n        const positionTransform = this._temp.positionTransform;\r\n        const scaledAndTranslatedObjectMatrix = this._temp.objectMatrix;\r\n\r\n        objectWorldMatrix.decompose(scaleTransform, rotationTransform, positionTransform);\r\n        scaleTransform.x *= widthScaleFactor;\r\n        scaleTransform.y *= heightScaleFactor;\r\n\r\n        Matrix.ComposeToRef(scaleTransform, rotationTransform, positionTransform, scaledAndTranslatedObjectMatrix);\r\n\r\n        // Adjust direction of 12 and 13 of the transformation matrix based on the handedness of the system\r\n        const direction = useRightHandedSystem ? -1 : 1;\r\n        // Adjust translation values to be from camera vs world origin\r\n        // Note that we are also adjusting these values to be pixels vs Babylon units\r\n        const position = htmlMesh.getAbsolutePosition();\r\n        scaledAndTranslatedObjectMatrix.setRowFromFloats(\r\n            3,\r\n            (-this._cameraWorldMatrix.m[12] + position.x) * BabylonUnitsToPixels * direction,\r\n            (-this._cameraWorldMatrix.m[13] + position.y) * BabylonUnitsToPixels * direction,\r\n            (this._cameraWorldMatrix.m[14] - position.z) * BabylonUnitsToPixels,\r\n            this._cameraWorldMatrix.m[15] * HtmlMeshRenderer.PROJECTION_SCALE_FACTOR * BabylonUnitsToPixels\r\n        );\r\n\r\n        // Adjust other values to be pixels vs Babylon units\r\n        scaledAndTranslatedObjectMatrix.multiplyAtIndex(3, BabylonUnitsToPixels);\r\n        scaledAndTranslatedObjectMatrix.multiplyAtIndex(7, BabylonUnitsToPixels);\r\n        scaledAndTranslatedObjectMatrix.multiplyAtIndex(11, BabylonUnitsToPixels);\r\n\r\n        return scaledAndTranslatedObjectMatrix;\r\n    }\r\n\r\n    protected _renderHtmlMesh(htmlMesh: HtmlMesh, useRightHandedSystem: boolean) {\r\n        if (!htmlMesh.element || !htmlMesh.element.firstElementChild) {\r\n            // nothing to render, so bail\r\n            return;\r\n        }\r\n\r\n        // We need to ensure html mesh data is initialized before\r\n        // computing the base scale factor\r\n        let htmlMeshData = this._cache.htmlMeshData.get(htmlMesh);\r\n        if (!htmlMeshData) {\r\n            htmlMeshData = { style: \"\" };\r\n            this._cache.htmlMeshData.set(htmlMesh, htmlMeshData);\r\n        }\r\n\r\n        const cameraElement = htmlMesh._isCanvasOverlay ? this._overlayElements?.cameraElement : this._inSceneElements?.cameraElement;\r\n\r\n        if (htmlMesh.element.parentNode !== cameraElement) {\r\n            cameraElement!.appendChild(htmlMesh.element);\r\n        }\r\n\r\n        // If the htmlMesh content has changed, update the base scale factor\r\n        if (htmlMesh.requiresUpdate) {\r\n            this._updateBaseScaleFactor(htmlMesh);\r\n        }\r\n\r\n        // Get the transformation matrix for the html mesh\r\n        const scaledAndTranslatedObjectMatrix = this._getTransformationMatrix(htmlMesh, useRightHandedSystem);\r\n\r\n        let style = `translate(-50%, -50%) ${this._getHtmlContentCssMatrix(scaledAndTranslatedObjectMatrix, useRightHandedSystem)}`;\r\n        // In a right handed system, screens are on the wrong side of the mesh, so we have to rotate by Math.PI which results in the matrix3d seen below\r\n        // Also in RH + billboard mode, we cancel the handedness so we do not need to scale on x\r\n        style += `${useRightHandedSystem ? `matrix3d(${htmlMesh.billboardMode !== TransformNode.BILLBOARDMODE_NONE ? 1 : -1}, 0, 0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1)` : \"\"}`;\r\n\r\n        if (htmlMeshData.style !== style) {\r\n            htmlMesh.element.style.webkitTransform = style;\r\n            htmlMesh.element.style.transform = style;\r\n        }\r\n\r\n        htmlMesh._markAsUpdated();\r\n    }\r\n\r\n    protected _render(scene: Scene, camera: Camera) {\r\n        let needsUpdate = false;\r\n\r\n        const useRightHandedSystem = scene.useRightHandedSystem;\r\n\r\n        // Update the container position and size if necessary\r\n        this._updateContainerPositionIfNeeded();\r\n\r\n        // Check for a camera change\r\n        if (this._cameraMatrixUpdated) {\r\n            this._cameraMatrixUpdated = false;\r\n            needsUpdate = true;\r\n        }\r\n\r\n        // If the camera position has changed, then we also need to update\r\n        if (\r\n            camera.position.x !== this._cache.cameraData.position.x ||\r\n            camera.position.y !== this._cache.cameraData.position.y ||\r\n            camera.position.z !== this._cache.cameraData.position.z\r\n        ) {\r\n            this._cache.cameraData.position.copyFrom(camera.position);\r\n            needsUpdate = true;\r\n        }\r\n\r\n        // Check for a dpr change\r\n        if (window.devicePixelRatio !== this._lastDevicePixelRatio) {\r\n            this._lastDevicePixelRatio = window.devicePixelRatio;\r\n            Logger.Log(\"In render - dpr changed: \", this._lastDevicePixelRatio);\r\n            needsUpdate = true;\r\n        }\r\n\r\n        // Check if any meshes need to be updated\r\n        const meshesNeedingUpdate = scene.meshes.filter((mesh) => (mesh as any)[\"isHtmlMesh\"] && (needsUpdate || (mesh as HtmlMesh).requiresUpdate));\r\n        needsUpdate = needsUpdate || meshesNeedingUpdate.length > 0;\r\n\r\n        if (!needsUpdate) {\r\n            return;\r\n        }\r\n\r\n        // Get a projection matrix for the camera\r\n        const projectionMatrix = camera.getProjectionMatrix();\r\n        const fov = projectionMatrix.m[5] * this._heightHalf;\r\n\r\n        if (this._cache.cameraData.fov !== fov) {\r\n            const source = [this._overlayElements?.domElement, this._inSceneElements?.domElement];\r\n            if (camera.mode == Camera.PERSPECTIVE_CAMERA) {\r\n                for (const el of source) {\r\n                    if (el) {\r\n                        el.style.webkitPerspective = fov + \"px\";\r\n                        el.style.perspective = fov + \"px\";\r\n                    }\r\n                }\r\n            } else {\r\n                for (const el of source) {\r\n                    if (el) {\r\n                        el.style.webkitPerspective = \"\";\r\n                        el.style.perspective = \"\";\r\n                    }\r\n                }\r\n            }\r\n            this._cache.cameraData.fov = fov;\r\n        }\r\n\r\n        // Get the CSS matrix for the camera (which will include any camera rotation)\r\n        if (camera.parent === null) {\r\n            camera.computeWorldMatrix();\r\n        }\r\n\r\n        const cameraMatrixWorld = this._temp.cameraWorldMatrix;\r\n        cameraMatrixWorld.copyFrom(camera.getWorldMatrix());\r\n        const cameraRotationMatrix = this._temp.cameraRotationMatrix;\r\n        cameraMatrixWorld.getRotationMatrix().transposeToRef(cameraRotationMatrix);\r\n\r\n        const cameraMatrixWorldAsArray = this._temp.cameraWorldMatrixAsArray;\r\n        cameraMatrixWorld.copyToArray(cameraMatrixWorldAsArray);\r\n\r\n        // For a few values, we have to adjust the direction based on the handedness of the system\r\n        const direction = useRightHandedSystem ? 1 : -1;\r\n\r\n        cameraMatrixWorldAsArray[1] = cameraRotationMatrix.m[1];\r\n        cameraMatrixWorldAsArray[2] = cameraRotationMatrix.m[2] * direction;\r\n        cameraMatrixWorldAsArray[4] = cameraRotationMatrix.m[4] * direction;\r\n        cameraMatrixWorldAsArray[6] = cameraRotationMatrix.m[6] * direction;\r\n        cameraMatrixWorldAsArray[8] = cameraRotationMatrix.m[8] * direction;\r\n        cameraMatrixWorldAsArray[9] = cameraRotationMatrix.m[9] * direction;\r\n\r\n        Matrix.FromArrayToRef(cameraMatrixWorldAsArray, 0, cameraMatrixWorld);\r\n\r\n        const cameraCSSMatrix = this._getCameraCssMatrix(cameraMatrixWorld);\r\n        const style = cameraCSSMatrix;\r\n\r\n        if (this._cache.cameraData.style !== style) {\r\n            const source = [this._inSceneElements?.cameraElement, this._overlayElements?.cameraElement];\r\n            for (const el of source) {\r\n                if (el) {\r\n                    el.style.webkitTransform = style;\r\n                    el.style.transform = style;\r\n                }\r\n            }\r\n            this._cache.cameraData.style = style;\r\n        }\r\n\r\n        // _Render objects if necessary\r\n        for (const mesh of meshesNeedingUpdate) {\r\n            this._renderHtmlMesh(mesh as HtmlMesh, useRightHandedSystem);\r\n        }\r\n    }\r\n\r\n    protected _updateBaseScaleFactor(htmlMesh: HtmlMesh) {\r\n        // Get screen width and height\r\n        let screenWidth = this._width;\r\n        let screenHeight = this._height;\r\n\r\n        // Calculate aspect ratios\r\n        const htmlMeshAspectRatio = (htmlMesh.width || 1) / (htmlMesh.height || 1);\r\n        const screenAspectRatio = screenWidth / screenHeight;\r\n\r\n        // Adjust screen dimensions based on aspect ratios\r\n        if (htmlMeshAspectRatio > screenAspectRatio) {\r\n            // If the HTML mesh is wider relative to its height than the screen, adjust the screen width\r\n            screenWidth = screenHeight * htmlMeshAspectRatio;\r\n        } else {\r\n            // If the HTML mesh is taller relative to its width than the screen, adjust the screen height\r\n            screenHeight = screenWidth / htmlMeshAspectRatio;\r\n        }\r\n\r\n        // Set content to fill screen so we get max resolution when it is shrunk to fit the mesh\r\n        htmlMesh.setContentSizePx(screenWidth, screenHeight);\r\n    }\r\n\r\n    protected _updateContainerPositionIfNeeded() {\r\n        // Determine if the canvas has moved on the screen\r\n        const canvasRect = this._engine.getRenderingCanvasClientRect();\r\n\r\n        // canvas rect may be null if layout not complete\r\n        if (!canvasRect) {\r\n            Logger.Warn(PositionUpdateFailMessage);\r\n            return;\r\n        }\r\n        const scrollTop = window.scrollY;\r\n        const scrollLeft = window.scrollX;\r\n        const canvasDocumentTop = canvasRect.top + scrollTop;\r\n        const canvasDocumentLeft = canvasRect.left + scrollLeft;\r\n\r\n        if (this._previousCanvasDocumentPosition.top !== canvasDocumentTop || this._previousCanvasDocumentPosition.left !== canvasDocumentLeft) {\r\n            this._previousCanvasDocumentPosition.top = canvasDocumentTop;\r\n            this._previousCanvasDocumentPosition.left = canvasDocumentLeft;\r\n\r\n            const source = [this._inSceneElements?.container, this._overlayElements?.container];\r\n            for (const container of source) {\r\n                if (!container) {\r\n                    continue;\r\n                }\r\n                // set the top and left of the css container to match the canvas\r\n                const containerParent = container.offsetParent as HTMLElement;\r\n                const parentRect = containerParent.getBoundingClientRect();\r\n                const parentDocumentTop = parentRect.top + scrollTop;\r\n                const parentDocumentLeft = parentRect.left + scrollLeft;\r\n\r\n                const ancestorMarginsAndPadding = this._getAncestorMarginsAndPadding(containerParent);\r\n\r\n                // Add the body margin\r\n                const bodyStyle = window.getComputedStyle(document.body);\r\n                const bodyMarginTop = parseInt(bodyStyle.marginTop, 10);\r\n                const bodyMarginLeft = parseInt(bodyStyle.marginLeft, 10);\r\n\r\n                container.style.top = `${canvasDocumentTop - parentDocumentTop - ancestorMarginsAndPadding.marginTop + ancestorMarginsAndPadding.paddingTop + bodyMarginTop}px`;\r\n                container.style.left = `${\r\n                    canvasDocumentLeft - parentDocumentLeft - ancestorMarginsAndPadding.marginLeft + ancestorMarginsAndPadding.paddingLeft + bodyMarginLeft\r\n                }px`;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _onCameraMatrixChanged = (camera: Camera) => {\r\n        this._cameraWorldMatrix = camera.getWorldMatrix();\r\n        this._cameraMatrixUpdated = true;\r\n    };\r\n\r\n    private _epsilon(value: number) {\r\n        return Math.abs(value) < 1e-10 ? 0 : value;\r\n    }\r\n\r\n    // Get total margins and padding for an element, excluding the body and document margins\r\n    private _getAncestorMarginsAndPadding(element: HTMLElement) {\r\n        let marginTop = 0;\r\n        let marginLeft = 0;\r\n        let paddingTop = 0;\r\n        let paddingLeft = 0;\r\n\r\n        while (element && element !== document.body && element !== document.documentElement) {\r\n            const style = window.getComputedStyle(element);\r\n            marginTop += parseInt(style.marginTop, 10);\r\n            marginLeft += parseInt(style.marginLeft, 10);\r\n            paddingTop += parseInt(style.paddingTop, 10);\r\n            paddingLeft += parseInt(style.paddingLeft, 10);\r\n            element = element.offsetParent as HTMLElement;\r\n        }\r\n\r\n        return { marginTop, marginLeft, paddingTop, paddingLeft };\r\n    }\r\n}\r\n","import { Tools } from \"core/Misc/tools\";\r\n\r\n// A capture management system to ensure that the correct object has the pointer\r\n// events by eliminating race conditions that can cause the pointer events to be\r\n// released by a different object after they are captured leaving no object\r\n// as the owner.  It does this by queueing requests and only allowing\r\n// capture when the current capture owner releases pointer events.\r\n\r\ntype CaptureReleaseCallback = () => void;\r\n\r\ntype CaptureReleaseCallbacks = {\r\n    capture: CaptureReleaseCallback;\r\n    release: CaptureReleaseCallback;\r\n};\r\n\r\nlet CaptureRequestQueue: string[] = [];\r\n\r\n// Key is request id, value is object with capture and release callbacks\r\nconst PendingRequestCallbacks: Map<string, CaptureReleaseCallbacks> = new Map();\r\n\r\n// Keep track of release requests with no matching capture request\r\n// in case the release request arrived before the capture to avoid\r\n// the capture request never getting released.\r\nlet UnmatchedReleaseRequests: string[] = [];\r\n\r\nlet CurrentOwner: string | null = null; // Called on first capture or release request\r\n\r\n/**\r\n * Get the id of the object currently capturing pointer events\r\n * @returns The id of the object currently capturing pointer events\r\n * or null if no object is capturing pointer events\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const getCapturingId = () => {\r\n    return CurrentOwner;\r\n};\r\n\r\n/**\r\n * Request that the object with the given id capture pointer events.  If there is no current\r\n * owner, then the request is granted immediately.  If there is a current owner, then the request\r\n * is queued until the current owner releases pointer events.\r\n * @param requestId An id to identify the request.  This id will be used to match the capture\r\n * request with the release request.\r\n * @param captureCallback The callback to call when the request is granted and the object is capturing\r\n * @param releaseCallback The callback to call when the object is no longer capturing pointer events\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const requestCapture = (requestId: string, captureCallback: CaptureReleaseCallback, releaseCallback: CaptureReleaseCallback) => {\r\n    DebugLog(`In pointerEventsCapture.requestCapture - Pointer events capture requested for ${requestId}`);\r\n\r\n    // If there is a release for this request, then ignore the request\r\n    if (RemoveUnmatchedRequest(requestId)) {\r\n        DebugLog(`In pointerEventsCapture.requestCapture - Capture request matched previous release request ${requestId}.  Cancelling capture request`);\r\n        return;\r\n    } else if (requestId !== CurrentOwner) {\r\n        // if the request is not already in the queue, add it to the queue\r\n        EnqueueCaptureRequest(requestId, captureCallback, releaseCallback);\r\n    }\r\n\r\n    if (!CurrentOwner) {\r\n        // If there is no current owner, go ahead and grant the request\r\n        TransferPointerEventsOwnership();\r\n    }\r\n    // If the request id is the current owner, do nothing\r\n};\r\n\r\n/**\r\n * Release pointer events from the object with the given id.  If the object is the current owner\r\n * then pointer events are released immediately.  If the object is not the current owner, then the\r\n * associated capture request is removed from the queue.  If there is no matching capture request\r\n * in the queue, then the release request is added to a list of unmatched release requests and will\r\n * negate the next capture request with the same id.  This is to guard against the possibility that\r\n * the release request arrived before the capture request.\r\n * @param requestId The id which should match the id of the capture request\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const requestRelease = (requestId: string | null) => {\r\n    DebugLog(`In pointerEventsCapture.requestRelease - Pointer events release requested for ${requestId}`);\r\n\r\n    // if the requestId is the current capture holder release it\r\n    if (!requestId || requestId === CurrentOwner) {\r\n        TransferPointerEventsOwnership();\r\n    } else if (CancelRequest(requestId)) {\r\n        // if the request is in the queue, but not the current capture holder, remove it and it's callbacks\r\n        PendingRequestCallbacks.delete(requestId);\r\n    } else {\r\n        DebugLog(`In pointerEventsCapture.requestRelease - Received release request ${requestId} but no matching capture request was received`);\r\n        // request was not current and not in queue, likely because we received a release\r\n        // request before the capture.  Add it to the unmatched list to guard against this possibility\r\n        if (!UnmatchedReleaseRequests.includes(requestId)) {\r\n            UnmatchedReleaseRequests.push(requestId);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Release pointer events from the current owner\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const releaseCurrent = () => {\r\n    requestRelease(CurrentOwner);\r\n};\r\n\r\nconst EnqueueCaptureRequest = (requestId: string, capture: CaptureReleaseCallback, release: CaptureReleaseCallback) => {\r\n    DebugLog(`In pointerEventsCapture.enqueueCaptureRequest - Enqueueing capture request for  ${requestId}`);\r\n    if (!CaptureRequestQueue.includes(requestId)) {\r\n        CaptureRequestQueue.push(requestId);\r\n        PendingRequestCallbacks.set(requestId, { capture, release });\r\n    }\r\n};\r\n\r\n// Removes the request from the queue if it exists.  Returns true\r\n// if the request was found and removed, otherwise false\r\nconst CancelRequest = (requestId: string | null) => {\r\n    let removed = false;\r\n    CaptureRequestQueue = CaptureRequestQueue.filter((id) => {\r\n        if (id !== requestId) {\r\n            return true;\r\n        } else {\r\n            removed = true;\r\n            DebugLog(`In pointerEventsCapture.cancelRequest - Canceling pointer events capture request ${requestId}`);\r\n            return false;\r\n        }\r\n    });\r\n    return removed;\r\n};\r\n\r\nconst RemoveUnmatchedRequest = (requestId: string) => {\r\n    let removed = false;\r\n    UnmatchedReleaseRequests = UnmatchedReleaseRequests.filter((id) => {\r\n        if (id !== requestId) {\r\n            return true;\r\n        } else {\r\n            removed = true;\r\n            return false;\r\n        }\r\n    });\r\n    return removed;\r\n};\r\n\r\nconst TransferPointerEventsOwnership = () => {\r\n    const newOwnerId = NextCaptureRequest();\r\n    DebugLog(`In pointerEventsCapture.transferPointerEventsOwnership - Transferrring pointer events from ${CurrentOwner} to ${newOwnerId}`);\r\n    // Release the current owner\r\n    DoRelease();\r\n    if (newOwnerId) {\r\n        DoCapture(newOwnerId);\r\n    }\r\n};\r\n\r\nconst DoRelease = () => {\r\n    DebugLog(`In pointerEventsCapture.doRelease - Releasing pointer events from ${CurrentOwner}`);\r\n    if (CurrentOwner) {\r\n        // call the release callback\r\n        PendingRequestCallbacks.get(CurrentOwner)?.release();\r\n        // And remove the callbacks\r\n        PendingRequestCallbacks.delete(CurrentOwner);\r\n        CurrentOwner = null;\r\n    }\r\n};\r\n\r\nconst DoCapture = (newOwnerId: string) => {\r\n    if (newOwnerId) {\r\n        // call the capture callback\r\n        PendingRequestCallbacks.get(newOwnerId)?.capture();\r\n    }\r\n    CurrentOwner = newOwnerId;\r\n    DebugLog(`In pointerEventsCapture.doCapture - Pointer events now captured by ${newOwnerId}`);\r\n};\r\n\r\nconst NextCaptureRequest = () => {\r\n    return CaptureRequestQueue.length > 0 ? CaptureRequestQueue.shift() : null;\r\n};\r\n\r\n// #region Debugging support\r\ndeclare global {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    interface Window {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \"pointer-events-capture-debug\": boolean | null;\r\n    }\r\n}\r\n\r\nconst DebugLog = (message: string) => {\r\n    // If we are runnning in a test runner (in node, so window is not defined)\r\n    // or if the debug flag is set, then log the message\r\n    if (typeof window === \"undefined\" || window[\"pointer-events-capture-debug\"]) {\r\n        Tools.Log(\r\n            `${performance.now()} - game.scene.pointerEvents - ${message}\\ncurrentOwner: ${CurrentOwner}\\nqueue: ${CaptureRequestQueue}\\nunmatched: ${UnmatchedReleaseRequests}`\r\n        );\r\n    }\r\n};\r\n// #endregion Debugging support\r\n","import type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Behavior } from \"core/Behaviors/behavior\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { requestCapture, requestRelease, releaseCurrent, getCapturingId } from \"./pointerEventsCapture\";\r\n\r\n// Module level variable for holding the current scene\r\nlet LocalScene: Scene | null = null;\r\n\r\n// Module level variable to hold the count of behavior instances that are currently capturing pointer events\r\n// on entry.  This is used to determine if we need to start or stop observing pointer movement.\r\nlet CaptureOnEnterCount = 0;\r\n\r\n// Map used to store instance of the PointerEventsCaptureBehavior for a mesh\r\n// We do this because this gets checked on pointer move and we don't want to\r\n// use getBehaviorByName() because that is a linear search\r\nconst MeshToBehaviorMap = new WeakMap<AbstractMesh, PointerEventsCaptureBehavior>();\r\n\r\nconst StartCaptureOnEnter = (scene: Scene) => {\r\n    // If we are not in a browser, do nothing\r\n    if (typeof document === \"undefined\") {\r\n        return;\r\n    }\r\n    if (CaptureOnEnterCount === 0) {\r\n        document.addEventListener(\"pointermove\", OnPointerMove);\r\n        document.addEventListener(\"touchstart\", OnPointerMove);\r\n        LocalScene = LocalScene ?? scene;\r\n        Logger.Log(\"PointerEventsCaptureBehavior: Starting observation of pointer move events.\");\r\n        LocalScene.onDisposeObservable.add(DoStopCaptureOnEnter);\r\n    }\r\n    CaptureOnEnterCount++;\r\n};\r\n\r\nconst DoStopCaptureOnEnter = () => {\r\n    document.removeEventListener(\"pointermove\", OnPointerMove);\r\n    document.removeEventListener(\"touchstart\", OnPointerMove);\r\n    LocalScene = null;\r\n    Logger.Log(\"PointerEventsCaptureBehavior: Stopping observation of pointer move events.\");\r\n    CaptureOnEnterCount = 0;\r\n};\r\n\r\nconst StopCaptureOnEnter = () => {\r\n    // If we are not in a browser, do nothing\r\n    if (typeof document === \"undefined\") {\r\n        return;\r\n    }\r\n\r\n    // If we are not observing pointer movement, do nothing\r\n    if (!LocalScene) {\r\n        return;\r\n    }\r\n\r\n    CaptureOnEnterCount--;\r\n    if (CaptureOnEnterCount <= 0) {\r\n        DoStopCaptureOnEnter();\r\n    }\r\n};\r\n\r\n// Module level function used to determine if an entered mesh should capture pointer events\r\nconst OnPointerMove = (evt: PointerEvent | TouchEvent) => {\r\n    if (!LocalScene) {\r\n        return;\r\n    }\r\n\r\n    const canvasRect = LocalScene.getEngine().getRenderingCanvasClientRect();\r\n    if (!canvasRect) {\r\n        return;\r\n    }\r\n\r\n    // Get the object that contains the client X and Y from either the pointer event or from the\r\n    // TouchEvent touch\r\n    const { clientX, clientY } = \"touches\" in evt ? evt.touches[0] : evt;\r\n\r\n    // get the picked mesh, if any\r\n    const pointerScreenX = clientX - canvasRect.left;\r\n    const pointerScreenY = clientY - canvasRect.top;\r\n\r\n    let pointerCaptureBehavior: PointerEventsCaptureBehavior | undefined;\r\n    const pickResult = LocalScene.pick(pointerScreenX, pointerScreenY, (mesh) => {\r\n        // If the mesh has an instance of PointerEventsCaptureBehavior attached to it,\r\n        // and capture on pointer enter is true, then we want to pick it\r\n        const pointerCaptureBehavior = MeshToBehaviorMap.get(mesh);\r\n        return mesh.isEnabled() && typeof pointerCaptureBehavior !== \"undefined\" && pointerCaptureBehavior._captureOnPointerEnter;\r\n    });\r\n\r\n    let pickedMesh: AbstractMesh | null;\r\n    if (pickResult.hit) {\r\n        pickedMesh = pickResult.pickedMesh;\r\n    } else {\r\n        pickedMesh = null;\r\n    }\r\n\r\n    const capturingIdAsInt = parseInt(getCapturingId() || \"\");\r\n\r\n    // if the picked mesh is the current capturing mesh, do nothing\r\n    if (pickedMesh && pickedMesh.uniqueId === capturingIdAsInt) {\r\n        return;\r\n    }\r\n\r\n    // If there is a capturing mesh and it is not the current picked mesh, or no\r\n    // mesh is picked, release the capturing mesh\r\n    if (capturingIdAsInt && (!pickedMesh || pickedMesh.uniqueId !== capturingIdAsInt)) {\r\n        releaseCurrent();\r\n    }\r\n\r\n    // If there is a picked mesh and it is not the current capturing mesh, capture\r\n    // the pointer events.  Note that the current capturing mesh has already been\r\n    // released above\r\n    if (pickedMesh) {\r\n        pointerCaptureBehavior = MeshToBehaviorMap.get(pickedMesh);\r\n        pointerCaptureBehavior!.capturePointerEvents();\r\n    }\r\n};\r\n\r\n/**\r\n * Behavior for any content that can capture pointer events, i.e. bypass the Babylon pointer event handling\r\n * and receive pointer events directly.  It will register the capture triggers and negotiate the capture and\r\n * release of pointer events.  Curerntly this applies only to HtmlMesh\r\n */\r\nexport class PointerEventsCaptureBehavior implements Behavior<AbstractMesh> {\r\n    /** gets or sets behavior's name */\r\n    public name = \"PointerEventsCaptureBehavior\";\r\n\r\n    private _attachedMesh: AbstractMesh | null;\r\n    /** @internal */\r\n    public _captureOnPointerEnter: boolean;\r\n\r\n    /**\r\n     * Gets or sets the mesh that the behavior is attached to\r\n     */\r\n    public get attachedMesh() {\r\n        return this._attachedMesh;\r\n    }\r\n\r\n    public set attachedMesh(value: AbstractMesh | null) {\r\n        this._attachedMesh = value;\r\n    }\r\n\r\n    /**\r\n     * Attached node of this behavior\r\n     */\r\n    public get attachedNode(): AbstractMesh | null {\r\n        return this._attachedMesh;\r\n    }\r\n\r\n    constructor(\r\n        private _captureCallback: () => void,\r\n        private _releaseCallback: () => void,\r\n        { captureOnPointerEnter = true } = {}\r\n    ) {\r\n        this._attachedMesh = null;\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n\r\n        // Warn if we are not in a browser\r\n        if (typeof document === \"undefined\") {\r\n            Logger.Warn(`Creating an instance of PointerEventsCaptureBehavior outside of a browser.  The behavior will not work.`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set if the behavior should capture pointer events when the pointer enters the mesh\r\n     */\r\n    public set captureOnPointerEnter(captureOnPointerEnter: boolean) {\r\n        if (this._captureOnPointerEnter === captureOnPointerEnter) {\r\n            return;\r\n        }\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n        if (this._attachedMesh) {\r\n            if (this._captureOnPointerEnter) {\r\n                StartCaptureOnEnter(this._attachedMesh.getScene());\r\n            } else {\r\n                StopCaptureOnEnter();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function called when the behavior needs to be initialized (before attaching it to a target)\r\n     */\r\n    public init() {}\r\n\r\n    /**\r\n     * Called when the behavior is attached to a target\r\n     * @param mesh defines the target where the behavior is attached to\r\n     */\r\n    public attach(mesh: AbstractMesh) {\r\n        // Add a reference to this behavior on the mesh.  We do this so we can get a\r\n        // reference to the behavior in the onPointerMove function without relying on\r\n        // getBehaviorByName(), which does a linear search of the behaviors array.\r\n        this.attachedMesh = mesh;\r\n        MeshToBehaviorMap.set(mesh, this);\r\n        if (this._captureOnPointerEnter) {\r\n            StartCaptureOnEnter(mesh.getScene());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the behavior is detached from its target\r\n     */\r\n    public detach() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        // Remove the reference to this behavior from the mesh\r\n        MeshToBehaviorMap.delete(this.attachedMesh);\r\n        if (this._captureOnPointerEnter) {\r\n            StopCaptureOnEnter();\r\n        }\r\n        this.attachedMesh = null;\r\n    }\r\n\r\n    /**\r\n     * Dispose the behavior\r\n     */\r\n    public dispose() {\r\n        this.detach();\r\n    }\r\n\r\n    // Release pointer events\r\n    public releasePointerEvents() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        requestRelease(this.attachedMesh.uniqueId.toString());\r\n    }\r\n\r\n    // Capture pointer events\r\n    public capturePointerEvents() {\r\n        if (!this.attachedMesh) {\r\n            return;\r\n        }\r\n        requestCapture(this.attachedMesh.uniqueId.toString(), this._captureCallback, this._releaseCallback);\r\n    }\r\n}\r\n","export type FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement;\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number): void;\r\n};\r\n\r\nconst FitStrategyContain: FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement {\r\n        const sizingElement = document.createElement(\"div\");\r\n        sizingElement.style.display = \"flex\";\r\n        sizingElement.style.justifyContent = \"center\";\r\n        sizingElement.style.alignItems = \"center\";\r\n        const scalingElement = document.createElement(\"div\");\r\n        scalingElement.style.visibility = \"hidden\";\r\n        scalingElement.appendChild(element);\r\n        sizingElement.appendChild(scalingElement);\r\n        return sizingElement;\r\n    },\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number) {\r\n        const scalingElement = sizingElement.firstElementChild! as HTMLElement;\r\n        sizingElement.style.width = `${width}px`;\r\n        sizingElement.style.height = `${height}px`;\r\n\r\n        const [childWidth, childHeight] = [scalingElement.offsetWidth, scalingElement.offsetHeight];\r\n        const scale = Math.min(width / childWidth, height / childHeight);\r\n        scalingElement.style.transform = `scale(${scale})`;\r\n        scalingElement.style.visibility = \"visible\";\r\n    },\r\n};\r\n\r\nconst FitStrategyCover: FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement {\r\n        const sizingElement = document.createElement(\"div\");\r\n        sizingElement.style.display = \"flex\";\r\n        sizingElement.style.justifyContent = \"center\";\r\n        sizingElement.style.alignItems = \"center\";\r\n        sizingElement.style.overflow = \"hidden\";\r\n        const scalingElement = document.createElement(\"div\");\r\n        scalingElement.style.visibility = \"hidden\";\r\n        scalingElement.appendChild(element);\r\n        sizingElement.appendChild(scalingElement);\r\n        return sizingElement;\r\n    },\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number) {\r\n        const scalingElement = sizingElement.firstElementChild! as HTMLElement;\r\n        sizingElement.style.width = `${width}px`;\r\n        sizingElement.style.height = `${height}px`;\r\n\r\n        const [childWidth, childHeight] = [scalingElement.offsetWidth, scalingElement.offsetHeight];\r\n        const scale = Math.max(width / childWidth, height / childHeight);\r\n        scalingElement.style.transform = `scale(${scale})`;\r\n        scalingElement.style.visibility = \"visible\";\r\n    },\r\n};\r\n\r\nconst FitStrategyStretch: FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement {\r\n        const sizingElement = document.createElement(\"div\");\r\n        sizingElement.style.display = \"flex\";\r\n        sizingElement.style.justifyContent = \"center\";\r\n        sizingElement.style.alignItems = \"center\";\r\n        const scalingElement = document.createElement(\"div\");\r\n        scalingElement.style.visibility = \"hidden\";\r\n        scalingElement.appendChild(element);\r\n        sizingElement.appendChild(scalingElement);\r\n        return sizingElement;\r\n    },\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number) {\r\n        const scalingElement = sizingElement.firstElementChild! as HTMLElement;\r\n        sizingElement.style.width = `${width}px`;\r\n        sizingElement.style.height = `${height}px`;\r\n\r\n        const [childWidth, childHeight] = [scalingElement.offsetWidth, scalingElement.offsetHeight];\r\n        scalingElement.style.transform = `scale(${width / childWidth}, ${height / childHeight})`;\r\n        scalingElement.style.visibility = \"visible\";\r\n    },\r\n};\r\n\r\nconst FitStrategyNone: FitStrategyType = {\r\n    wrapElement(element: HTMLElement): HTMLElement {\r\n        return element;\r\n    },\r\n    updateSize(sizingElement: HTMLElement, width: number, height: number) {\r\n        if (sizingElement) {\r\n            sizingElement.style.width = `${width}px`;\r\n            sizingElement.style.height = `${height}px`;\r\n        }\r\n    },\r\n};\r\n\r\nexport const FitStrategy = {\r\n    CONTAIN: FitStrategyContain,\r\n    COVER: FitStrategyCover,\r\n    STRETCH: FitStrategyStretch,\r\n    NONE: FitStrategyNone,\r\n};\r\n","import { Mesh } from \"core/Meshes/mesh\";\r\nimport { CreatePlaneVertexData } from \"core/Meshes/Builders/planeBuilder\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Matrix } from \"core/Maths/math\";\r\nimport { PointerEventsCaptureBehavior } from \"./pointerEventsCaptureBehavior\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { FitStrategyType } from \"./fitStrategy\";\r\nimport { FitStrategy } from \"./fitStrategy\";\r\n\r\n/**\r\n * This class represents HTML content that we want to render as though it is part of the scene.  The HTML content is actually\r\n * rendered below the canvas, but a depth mask is created by this class that writes to the depth buffer but does not\r\n * write to the color buffer, effectively punching a hole in the canvas.  CSS transforms are used to scale, translate, and rotate\r\n * the HTML content so that it matches the camera and mesh orientation.  The class supports interactions in editable and non-editable mode.\r\n * In non-editable mode (the default), events are passed to the HTML content when the pointer is over the mask (and not occluded by other meshes\r\n * in the scene).\r\n * @see https://playground.babylonjs.com/#HVHYJC#5\r\n * @see https://playground.babylonjs.com/#B17TC7#112\r\n */\r\nexport class HtmlMesh extends Mesh {\r\n    /**\r\n     * Helps identifying a html mesh from a regular mesh\r\n     */\r\n    public get isHtmlMesh() {\r\n        return true;\r\n    }\r\n\r\n    // Override the super class's _isEnabled property so we can control when the mesh\r\n    // is enabled.  I.e., we don't want to render the mesh until there is content to show.\r\n    private _enabled = false;\r\n\r\n    // The mesh is ready when content has been set and the content size has been set\r\n    // The former is done by the user, the latter is done by the renderer.\r\n    private _ready = false;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _isCanvasOverlay = false;\r\n\r\n    private _requiresUpdate = true;\r\n\r\n    private _element?: HTMLElement;\r\n    private _width?: number;\r\n    private _height?: number;\r\n\r\n    private _inverseScaleMatrix: Matrix | null = null;\r\n\r\n    private _captureOnPointerEnter: boolean = true;\r\n    private _pointerEventCaptureBehavior: PointerEventsCaptureBehavior | null = null;\r\n\r\n    private _sourceWidth: number | null = null;\r\n    private _sourceHeight: number | null = null;\r\n\r\n    /**\r\n     * Return the source width of the content in pixels\r\n     */\r\n    public get sourceWidth() {\r\n        return this._sourceWidth;\r\n    }\r\n\r\n    /**\r\n     * Return the source height of the content in pixels\r\n     */\r\n    public get sourceHeight() {\r\n        return this._sourceHeight;\r\n    }\r\n\r\n    private _worldMatrixUpdateObserver: any;\r\n\r\n    private _fitStrategy: FitStrategyType = FitStrategy.NONE;\r\n\r\n    /**\r\n     * Contruct an instance of HtmlMesh\r\n     * @param scene\r\n     * @param id The id of the mesh.  Will be used as the id of the HTML element as well.\r\n     * @param options object with optional parameters\r\n     */\r\n    constructor(scene: Scene, id: string, { captureOnPointerEnter = true, isCanvasOverlay = false, fitStrategy = FitStrategy.NONE } = {}) {\r\n        super(id, scene);\r\n\r\n        // Requires a browser to work.  Bail if we aren't running in a browser\r\n        if (typeof document === \"undefined\") {\r\n            Logger.Warn(`Creating an instance of an HtmlMesh with id ${id} outside of a browser.  The mesh will not be visible.`);\r\n            return;\r\n        }\r\n\r\n        this._fitStrategy = fitStrategy;\r\n        this._isCanvasOverlay = isCanvasOverlay;\r\n        this._createMask();\r\n        this._element = this._createElement();\r\n\r\n        // Set enabled by default, so this will show as soon as it's ready\r\n        this.setEnabled(true);\r\n\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n\r\n        // Create a behavior to capture pointer events\r\n        this._pointerEventCaptureBehavior = new PointerEventsCaptureBehavior(this.capturePointerEvents.bind(this), this.releasePointerEvents.bind(this), {\r\n            captureOnPointerEnter: this._captureOnPointerEnter,\r\n        });\r\n        this.addBehavior(this._pointerEventCaptureBehavior);\r\n    }\r\n\r\n    /**\r\n     * The width of the content in pixels\r\n     */\r\n    public get width() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * The height of the content in pixels\r\n     */\r\n    public get height() {\r\n        return this._height;\r\n    }\r\n\r\n    /**\r\n     * The HTML element that is being rendered as a mesh\r\n     */\r\n    public get element() {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * True if the mesh has been moved, rotated, or scaled since the last time this\r\n     * property was read.  This property is reset to false after reading.\r\n     */\r\n    public get requiresUpdate() {\r\n        return this._requiresUpdate;\r\n    }\r\n\r\n    /**\r\n     * Enable capture for the pointer when entering the mesh area\r\n     */\r\n    public set captureOnPointerEnter(captureOnPointerEnter: boolean) {\r\n        this._captureOnPointerEnter = captureOnPointerEnter;\r\n        if (this._pointerEventCaptureBehavior) {\r\n            this._pointerEventCaptureBehavior.captureOnPointerEnter = captureOnPointerEnter;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes of the mesh and the HTML element\r\n     */\r\n    public override dispose() {\r\n        super.dispose();\r\n        this._element?.remove();\r\n        this._element = undefined;\r\n        if (this._pointerEventCaptureBehavior) {\r\n            this._pointerEventCaptureBehavior.dispose();\r\n            this._pointerEventCaptureBehavior = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _markAsUpdated() {\r\n        this._requiresUpdate = false;\r\n    }\r\n\r\n    /**\r\n     * Sets the content of the element to the specified content adjusting the mesh scale to match and making it visible.\r\n     * If the the specified content is undefined, then it will make the mesh invisible.  In either case it will clear the\r\n     * element content first.\r\n     * @param element The element to render as a mesh\r\n     * @param width The width of the mesh in Babylon units\r\n     * @param height The height of the mesh in Babylon units\r\n     */\r\n    setContent(element: HTMLElement, width: number, height: number) {\r\n        // If content is changed, we are no longer ready\r\n        this._setAsReady(false);\r\n\r\n        // Also invalidate the source width and height\r\n        this._sourceWidth = null;\r\n        this._sourceHeight = null;\r\n\r\n        if (!this._element) {\r\n            return;\r\n        }\r\n\r\n        this._width = width;\r\n        this._height = height;\r\n        this._requiresUpdate = true;\r\n\r\n        this.scaling.setAll(1);\r\n\r\n        if (element) {\r\n            this._element.appendChild(this._fitStrategy.wrapElement(element));\r\n\r\n            this._updateScaleIfNecessary();\r\n        }\r\n\r\n        if (this.sourceWidth && this.sourceHeight) {\r\n            this._setAsReady(true);\r\n        }\r\n    }\r\n\r\n    // Overides BABYLON.Mesh.setEnabled\r\n    public override setEnabled(enabled: boolean) {\r\n        // Capture requested enabled state\r\n        this._enabled = enabled;\r\n\r\n        // If disabling or enabling and we are ready\r\n        if (!enabled || this._ready) {\r\n            this._doSetEnabled(enabled);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the content size in pixels\r\n     * @param width width of the source\r\n     * @param height height of the source\r\n     */\r\n    public setContentSizePx(width: number, height: number) {\r\n        this._sourceWidth = width;\r\n        this._sourceHeight = height;\r\n\r\n        if (!this._element || !this._element.firstElementChild) {\r\n            return;\r\n        }\r\n\r\n        this._fitStrategy.updateSize(this._element.firstElementChild as HTMLElement, width, height);\r\n\r\n        this._updateScaleIfNecessary();\r\n\r\n        if (this.width && this.height) {\r\n            this._setAsReady(true);\r\n        }\r\n    }\r\n\r\n    protected _setAsReady(ready: boolean) {\r\n        this._ready = ready;\r\n        if (ready) {\r\n            this._doSetEnabled(this._enabled);\r\n        } else {\r\n            this._doSetEnabled(false);\r\n        }\r\n    }\r\n\r\n    protected _doSetEnabled(enabled: boolean) {\r\n        if (!this._element) {\r\n            return;\r\n        }\r\n\r\n        //if enabled, then start listening for changes to the\r\n        // scaling, rotation, and position.  otherwise stop listening\r\n        if (enabled && !this._worldMatrixUpdateObserver) {\r\n            this._worldMatrixUpdateObserver = this.onAfterWorldMatrixUpdateObservable.add(() => {\r\n                this._requiresUpdate = true;\r\n            });\r\n        } else if (!enabled) {\r\n            this._worldMatrixUpdateObserver?.remove();\r\n            this._worldMatrixUpdateObserver = null;\r\n        }\r\n\r\n        // If enabled, then revert the content element display\r\n        // otherwise hide it\r\n        this._element.style.display = enabled ? \"\" : \"none\";\r\n        // Capture the content z index\r\n        this._setElementzIndex(this.position.z * -10000);\r\n        super.setEnabled(enabled);\r\n    }\r\n\r\n    protected _updateScaleIfNecessary() {\r\n        // If we have setContent before, the content scale is baked into the mesh.  If we don't reset the vertices to\r\n        // the original size, then we will multiply the scale when we bake the scale below.  By applying the inverse, we back out\r\n        // the scaling that has been done so we are starting from the same point.\r\n        // First reset the scale to 1\r\n        this.scaling.setAll(1);\r\n        // Then back out the original vertices changes to match the content scale\r\n        if (this._inverseScaleMatrix) {\r\n            this.bakeTransformIntoVertices(this._inverseScaleMatrix);\r\n            // Clear out the matrix so it doesn't get applied again unless we scale\r\n            this._inverseScaleMatrix = null;\r\n        }\r\n\r\n        // Set scale to match content.  Note we can't just scale the mesh, because that will scale the content as well\r\n        // What we need to do is compute a scale matrix and then bake that into the mesh vertices.  This will leave the\r\n        // mesh scale at 1, so our content will stay it's original width and height until we scale the mesh.\r\n        const scaleX = this._width || 1;\r\n        const scaleY = this._height || 1;\r\n        const scaleMatrix = Matrix.Scaling(scaleX, scaleY, 1);\r\n        this.bakeTransformIntoVertices(scaleMatrix);\r\n\r\n        // Get an inverse of the scale matrix that we can use to back out the scale changes we have made so\r\n        // we don't multiply the scale.\r\n        this._inverseScaleMatrix = new Matrix();\r\n        scaleMatrix.invertToRef(this._inverseScaleMatrix);\r\n    }\r\n\r\n    protected _createMask() {\r\n        const vertexData = CreatePlaneVertexData({ width: 1, height: 1 });\r\n        vertexData.applyToMesh(this);\r\n\r\n        const scene = this.getScene();\r\n        this.checkCollisions = true;\r\n\r\n        const depthMask = new StandardMaterial(`${this.id}-mat`, scene);\r\n        if (!this._isCanvasOverlay) {\r\n            depthMask.backFaceCulling = false;\r\n            depthMask.disableColorWrite = true;\r\n            depthMask.disableLighting = true;\r\n        }\r\n\r\n        this.material = depthMask;\r\n\r\n        // Optimization - Freeze material since it never needs to change\r\n        this.material.freeze();\r\n    }\r\n\r\n    protected _setElementzIndex(zIndex: number) {\r\n        if (this._element) {\r\n            this._element.style.zIndex = `${zIndex}`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback used by the PointerEventsCaptureBehavior to capture pointer events\r\n     */\r\n    capturePointerEvents() {\r\n        if (!this._element) {\r\n            return;\r\n        }\r\n\r\n        // Enable dom content to capture pointer events\r\n        this._element.style.pointerEvents = \"auto\";\r\n\r\n        // Supress events outside of the dom content\r\n        document.getElementsByTagName(\"body\")[0].style.pointerEvents = \"none\";\r\n    }\r\n\r\n    /**\r\n     * Callback used by the PointerEventsCaptureBehavior to release pointer events\r\n     */\r\n    releasePointerEvents() {\r\n        if (!this._element) {\r\n            return;\r\n        }\r\n\r\n        // Enable pointer events on canvas\r\n        document.getElementsByTagName(\"body\")[0].style.pointerEvents = \"auto\";\r\n\r\n        // Disable pointer events on dom content\r\n        this._element.style.pointerEvents = \"none\";\r\n    }\r\n\r\n    protected _createElement() {\r\n        // Requires a browser to work.  Bail if we aren't running in a browser\r\n        if (typeof document === \"undefined\") {\r\n            return;\r\n        }\r\n        const div = document.createElement(\"div\");\r\n        div.id = this.id;\r\n        div.style.backgroundColor = this._isCanvasOverlay ? \"transparent\" : \"#000\";\r\n        div.style.zIndex = \"1\";\r\n        div.style.position = \"absolute\";\r\n        div.style.pointerEvents = \"none\";\r\n        div.style.backfaceVisibility = \"hidden\";\r\n\r\n        return div;\r\n    }\r\n}\r\n","import { _LoadScriptModuleAsync } from \"core/Misc/tools.internals\";\nimport type { Nullable } from \"core/types\";\n\nimport type { RecastInjection } from \"../types\";\n\n/**\n * Gets the RecastInjection instance (reference to the recast-navigation-js library).\n * @returns The RecastInjection instance\n * @throws Error if Recast is not initialized\n */\nexport function GetRecast(): RecastInjection {\n    if (!_Recast) {\n        throw new Error(\"Recast is not initialized. Please call InitRecast first.\");\n    }\n    return _Recast;\n}\n\n/**\n * Sets the RecastInjection instance (reference to the recast-navigation-js library).\n * @param recast The RecastInjection instance to set\n */\nexport function SetRecast(recast: RecastInjection) {\n    _Recast = recast;\n}\n\n/**\n * Reference to the recast-navigation-js library\n */\nlet _Recast: RecastInjection;\n\n/**\n * Promise to wait for the recast-navigation-js library to be ready\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nlet _InitPromise: Nullable<Promise<{ core: any; generators: any }>> = null;\n\n/**\n * Initializes the Recast navigation library.\n *\n * @param options Optional configuration. options.version: The version of Recast to use. options.instance: A custom Recast instance to inject instead of loading one.\n * @returns A promise that resolves when initialization is complete.\n */\nexport async function InitRecast(options?: { version?: string; instance?: RecastInjection }) {\n    const version = options?.version ?? \"0.43.0\";\n    const localOptions = {\n        url: \"https://unpkg.com/@recast-navigation\",\n        version,\n        ...options,\n    };\n\n    if (_Recast) {\n        return; // Already initialized\n    }\n\n    if (_InitPromise) {\n        await _InitPromise;\n        return;\n    }\n\n    if (localOptions.instance) {\n        _Recast = localOptions.instance;\n    } else {\n        _InitPromise = ImportRecast(localOptions.url, localOptions.version);\n\n        const result = await _InitPromise;\n        // eslint-disable-next-line require-atomic-updates\n        _Recast = { ...result.core, ...result.generators };\n\n        await _Recast.init();\n    }\n}\n\nasync function ImportRecast(baseUrl: string, version: string) {\n    const importMap = {\n        imports: {\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            \"@recast-navigation/core\": `${baseUrl}/core@${version}/dist/index.mjs`,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            \"@recast-navigation/wasm\": `${baseUrl}/wasm@${version}/dist/recast-navigation.wasm-compat.js`,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            \"@recast-navigation/generators\": `${baseUrl}/generators@${version}/dist/index.mjs`,\n        },\n    };\n\n    const script = document.createElement(\"script\");\n    script.type = \"importmap\";\n    script.textContent = JSON.stringify(importMap);\n    document.body.appendChild(script);\n\n    const result = await _LoadScriptModuleAsync(\n        `\n                import * as CoreModule from '${baseUrl}/core@${version}/dist/index.mjs';\n                import * as GeneratorsModule from '${baseUrl}/generators@${version}/dist/index.mjs';\n                const returnedValue =  {core: CoreModule, generators: GeneratorsModule};\n            `\n    );\n    return result;\n}\n","/* eslint-disable jsdoc/require-jsdoc */\r\n\r\nimport type { IVector2Like } from \"core/Maths/math.like\";\r\nimport type { SdfTextLine } from \"./sdf/line\";\r\nimport type { SdfGlyph } from \"./sdf/glyph\";\r\n\r\nexport interface ISdfTextParagraphMetrics {\r\n    /** @internal */\r\n    readonly paragraph: string;\r\n    /** @internal */\r\n    readonly lines: SdfTextLine[];\r\n    /** @internal */\r\n    readonly width: number;\r\n    /** @internal */\r\n    readonly height: number;\r\n    /** @internal */\r\n    readonly glyphs: SdfGlyph[];\r\n}\r\n\r\n/** @internal */\r\nexport type ParagraphOptions = {\r\n    maxWidth: number;\r\n    lineHeight: number;\r\n    letterSpacing: number;\r\n    tabSize: number;\r\n    whiteSpace: /* 'normal' | 'nowrap' | 'pre' | 'pre-wrap' | */ \"pre-line\" /* | 'break-spaces'*/;\r\n    textAlign: \"left\" | \"right\" | \"center\" /* | 'justify'*/;\r\n    translate: IVector2Like | undefined;\r\n    customLayoutEngine?: (text: string, options: ParagraphOptions) => ISdfTextParagraphMetrics;\r\n};\r\n\r\n/** @internal */\r\nexport const DefaultParagraphOptions: ParagraphOptions = {\r\n    maxWidth: Infinity,\r\n    lineHeight: 1,\r\n    letterSpacing: 1,\r\n    tabSize: 4,\r\n    whiteSpace: \"pre-line\",\r\n    textAlign: \"center\",\r\n    translate: { x: -0.5, y: -0.5 },\r\n};\r\n","/* eslint-disable babylonjs/available */\r\n/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { FontAsset } from \"../fontAsset\";\r\nimport type { ISdfTextParagraphMetrics } from \"../paragraphOptions\";\r\nimport { DefaultParagraphOptions, type ParagraphOptions } from \"../paragraphOptions\";\r\nimport type { BMFontChar } from \"./bmFont\";\r\nimport type { SdfGlyph } from \"./glyph\";\r\nimport type { SdfTextLine } from \"./line\";\r\n\r\n/** @internal */\r\nexport class SdfTextParagraph {\r\n    public readonly options: ParagraphOptions;\r\n\r\n    get lineHeight() {\r\n        return this.fontAsset._font.common.lineHeight * this.options.lineHeight;\r\n    }\r\n\r\n    readonly paragraph;\r\n    readonly lines;\r\n    readonly width;\r\n    readonly height;\r\n    readonly glyphs;\r\n\r\n    constructor(\r\n        public readonly text: string,\r\n        public readonly fontAsset: FontAsset,\r\n        options?: Partial<ParagraphOptions>\r\n    ) {\r\n        this.options = { ...DefaultParagraphOptions, ...options };\r\n\r\n        const { paragraph, lines, glyphs, width, height } = this.options.customLayoutEngine ? this.options.customLayoutEngine(text, this.options) : this._computeMetrics(text);\r\n\r\n        this.paragraph = paragraph;\r\n        this.lines = lines;\r\n        this.glyphs = glyphs;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n\r\n    private _computeMetrics(text: string): ISdfTextParagraphMetrics {\r\n        const collapsed = this._collapse(text);\r\n        const breaked = this._breakLines(collapsed);\r\n        const trimmed = breaked.map((line) => line.trim());\r\n\r\n        const lines: SdfTextLine[] = [];\r\n        for (const line of trimmed) {\r\n            lines.push(...this._wrap(line, lines.length));\r\n        }\r\n\r\n        const width = Math.max(...lines.map((line) => line.width));\r\n        const height = this.lineHeight * lines.length;\r\n\r\n        if (this.options.textAlign !== \"left\" || this.options.translate) {\r\n            lines.forEach((line) => {\r\n                const anchor = (() => {\r\n                    switch (this.options.textAlign) {\r\n                        case \"right\":\r\n                            return width - line.width;\r\n                        case \"center\":\r\n                            return (width - line.width) / 2;\r\n                        case \"left\":\r\n                        default:\r\n                            return 0;\r\n                    }\r\n                })();\r\n\r\n                const x = this.options.translate ? this.options.translate.x * width : 0;\r\n                const y = this.options.translate ? this.options.translate.y * height : 0;\r\n                for (const glyph of line.glyphs) {\r\n                    glyph.x += anchor;\r\n                    glyph.x += x;\r\n                    glyph.y += y;\r\n                }\r\n            });\r\n        }\r\n\r\n        const glyphs = lines.flatMap((line) => line.glyphs);\r\n\r\n        return {\r\n            paragraph: trimmed.join(\"\\n\"),\r\n            lines,\r\n            glyphs,\r\n            width,\r\n            height,\r\n        };\r\n    }\r\n\r\n    private _breakLines(text: string) {\r\n        return text.split(\"\\n\");\r\n    }\r\n\r\n    private _collapse(text: string) {\r\n        return text.replace(/\\t/g, \" \".repeat(this.options.tabSize)).replace(/ +/g, \" \");\r\n    }\r\n\r\n    private _wrap(text: string, lineOffset = 0) {\r\n        const lines = new Array<SdfTextLine>();\r\n\r\n        let currentLine = lineOffset;\r\n        let currentGlyphs = new Array<SdfGlyph>();\r\n        let currentCursor = 0;\r\n        let currentWidth = 0;\r\n        let lastChar: BMFontChar | undefined;\r\n        let start = 0;\r\n        let end = start;\r\n\r\n        const pushCurrentLine = () => {\r\n            lines.push({\r\n                text: text.slice(start, end),\r\n                glyphs: currentGlyphs,\r\n                start: start,\r\n                end: end,\r\n                width: currentWidth,\r\n            });\r\n        };\r\n\r\n        while (end < text.length) {\r\n            const i = end;\r\n            const charCode = text.charCodeAt(i);\r\n            const char = this.fontAsset._getChar(charCode);\r\n            const charWidth = char.width;\r\n            const kerning = lastChar ? this.fontAsset._getKerning(lastChar.id, char.id) : 0;\r\n\r\n            currentCursor += kerning;\r\n            const newWidth = currentCursor + charWidth;\r\n            const cursorProgress = char.xadvance + this.options.letterSpacing;\r\n            const nextPosition = currentCursor + cursorProgress;\r\n\r\n            const shouldBreak = nextPosition > this.options.maxWidth || newWidth > this.options.maxWidth;\r\n\r\n            if (shouldBreak) {\r\n                pushCurrentLine();\r\n\r\n                currentLine++;\r\n                lastChar = undefined;\r\n                currentCursor = 0;\r\n                currentWidth = 0;\r\n                start = end;\r\n                end = start + 1;\r\n                currentGlyphs = [];\r\n            }\r\n\r\n            const x = currentCursor;\r\n            const y = currentLine * this.lineHeight;\r\n\r\n            currentGlyphs.push({\r\n                char,\r\n                line: currentLine,\r\n                position: currentGlyphs.length,\r\n                x: x,\r\n                y: y,\r\n            });\r\n\r\n            if (!shouldBreak) {\r\n                lastChar = char;\r\n                currentCursor = nextPosition;\r\n                currentWidth = newWidth;\r\n                end++;\r\n            } else {\r\n                currentCursor = cursorProgress;\r\n            }\r\n        }\r\n\r\n        if (currentGlyphs.length > 0) {\r\n            if (lastChar) {\r\n                // currentWidth += lastChar.xadvance;\r\n            }\r\n            pushCurrentLine();\r\n        }\r\n\r\n        return lines;\r\n    }\r\n}\r\n","import type { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Buffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { ThinEngine } from \"core/Engines/thinEngine\";\r\nimport { DrawWrapper } from \"core/Materials/drawWrapper\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { IDisposable } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { SdfTextParagraph } from \"./sdf/paragraph\";\r\nimport type { FontAsset } from \"./fontAsset\";\r\nimport type { ParagraphOptions } from \"./paragraphOptions\";\r\nimport { ThinMatrix } from \"core/Maths/ThinMaths/thinMath.matrix\";\r\nimport {\r\n    CopyMatrixToArray,\r\n    CopyMatrixToRef,\r\n    IdentityMatrixToRef,\r\n    MultiplyMatricesToRef,\r\n    ScalingMatrixToRef,\r\n    TranslationMatrixToRef,\r\n} from \"core/Maths/ThinMaths/thinMath.matrix.functions\";\r\nimport type { IColor4Like, IMatrixLike } from \"core/Maths/math.like\";\r\n\r\n/**\r\n * Abstract Node class from Babylon.js\r\n */\r\nexport interface INodeLike {\r\n    getWorldMatrix(): IMatrixLike;\r\n}\r\n\r\n/**\r\n * Class used to render text using MSDF (Multi-channel Signed Distance Field) technique\r\n * Thanks a lot to the work of Bhushan_Wagh and zb_sj for their amazing work on MSDF for Babylon.js\r\n * #6RLCWP#16\r\n * Star wars scroller: #6RLCWP#29\r\n * With metrics: #6RLCWP#35\r\n * Thickness: #IABMEZ#3\r\n * Solar system: #9YCDYC#9\r\n * Stroke: #6RLCWP#37\r\n */\r\nexport class TextRenderer implements IDisposable {\r\n    private readonly _useVAO: boolean = false;\r\n    private _engine: AbstractEngine;\r\n    private _shaderLanguage: ShaderLanguage;\r\n    private _vertexBuffers: { [key: string]: VertexBuffer } = {};\r\n    private _spriteBuffer: Nullable<Buffer>;\r\n    private _worldBuffer: Nullable<Buffer>;\r\n    private _uvBuffer: Nullable<Buffer>;\r\n    private _drawWrapperBase: DrawWrapper;\r\n    private _vertexArrayObject: WebGLVertexArrayObject;\r\n    private _font: FontAsset;\r\n    private _charMatrices = new Array<number>();\r\n    private _charUvs = new Array<number>();\r\n    private _isDirty = true;\r\n    private _baseLine = 0;\r\n\r\n    // Cache\r\n    private _scalingMatrix = new ThinMatrix();\r\n    private _fontScaleMatrix = new ThinMatrix();\r\n    private _offsetMatrix = new ThinMatrix();\r\n    private _translationMatrix = new ThinMatrix();\r\n    private _baseMatrix = new ThinMatrix();\r\n    private _scaledMatrix = new ThinMatrix();\r\n    private _localMatrix = new ThinMatrix();\r\n    private _finalMatrix = new ThinMatrix();\r\n    private _lineMatrix = new ThinMatrix();\r\n    private _parentWorldMatrix = new ThinMatrix();\r\n\r\n    /**\r\n     * Gets or sets the color of the text\r\n     */\r\n    public color: IColor4Like = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\r\n\r\n    /**\r\n     * Gets or sets the color of the stroke around the text\r\n     */\r\n    public strokeColor: IColor4Like = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\r\n\r\n    /**\r\n     * Gets or sets the width of the stroke around the text (inset)\r\n     */\r\n    public strokeInsetWidth = 0;\r\n\r\n    /**\r\n     * Gets or sets the width of the stroke around the text (outset)\r\n     */\r\n    public strokeOutsetWidth = 0;\r\n\r\n    /**\r\n     * Gets or sets the thickness of the text (0 means as defined in the font)\r\n     * Value must be between -0.5 and 0.5\r\n     */\r\n    public thicknessControl = 0;\r\n\r\n    private _parent: Nullable<INodeLike> = null;\r\n\r\n    /**\r\n     * Gets or sets the parent of the text renderer\r\n     */\r\n    public get parent(): Nullable<INodeLike> {\r\n        return this._parent;\r\n    }\r\n\r\n    public set parent(value: Nullable<INodeLike>) {\r\n        this._parent = value;\r\n    }\r\n\r\n    private _transformMatrix: IMatrixLike = new ThinMatrix();\r\n\r\n    /**\r\n     * Gets or sets the transform matrix of the text renderer\r\n     * It will be applied in that order:\r\n     * parent x transform x paragraph world\r\n     */\r\n    public get transformMatrix(): IMatrixLike {\r\n        return this._transformMatrix;\r\n    }\r\n\r\n    public set transformMatrix(value: IMatrixLike) {\r\n        this._transformMatrix = value;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if the text is billboarded\r\n     */\r\n    public isBillboard = false;\r\n\r\n    /**\r\n     * Gets or sets if the text is screen projected\r\n     * This will work only if the text is billboarded\r\n     */\r\n    public isBillboardScreenProjected = false;\r\n\r\n    /**\r\n     * Gets the number of characters in the text renderer\r\n     */\r\n    public get characterCount(): number {\r\n        return this._charMatrices.length / 16;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if the text renderer should ignore the depth buffer\r\n     * Default is false\r\n     */\r\n    public ignoreDepthBuffer = false;\r\n\r\n    private constructor(engine: AbstractEngine, shaderLanguage: ShaderLanguage = ShaderLanguage.GLSL, font: FontAsset) {\r\n        this._engine = engine;\r\n        this._shaderLanguage = shaderLanguage;\r\n        this._font = font;\r\n        this._baseLine = font._font.common.lineHeight * font.scale;\r\n\r\n        this._useVAO = engine.getCaps().vertexArrayObject && !engine.disableVertexArrayObjects;\r\n\r\n        // Main vertex buffer\r\n        const spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);\r\n        this._spriteBuffer = new Buffer(engine, spriteData, false, 2);\r\n        this._vertexBuffers[\"offsets\"] = this._spriteBuffer.createVertexBuffer(\"offsets\", 0, 2);\r\n\r\n        // Instances\r\n        this._resizeBuffers(128);\r\n    }\r\n\r\n    private _resizeBuffers(capacity: number) {\r\n        if (this._worldBuffer) {\r\n            this._worldBuffer.dispose();\r\n            this._worldBuffer = null;\r\n        }\r\n\r\n        if (this._uvBuffer) {\r\n            this._uvBuffer.dispose();\r\n            this._uvBuffer = null;\r\n        }\r\n\r\n        this._worldBuffer = new Buffer(this._engine, new Float32Array(capacity * 16), true, 16);\r\n        this._vertexBuffers[\"world0\"] = this._worldBuffer.createVertexBuffer(\"world0\", 0, 4, 16, true);\r\n        this._vertexBuffers[\"world1\"] = this._worldBuffer.createVertexBuffer(\"world1\", 4, 4, 16, true);\r\n        this._vertexBuffers[\"world2\"] = this._worldBuffer.createVertexBuffer(\"world2\", 8, 4, 16, true);\r\n        this._vertexBuffers[\"world3\"] = this._worldBuffer.createVertexBuffer(\"world3\", 12, 4, 16, true);\r\n\r\n        this._uvBuffer = new Buffer(this._engine, new Float32Array(capacity * 4), true, 4);\r\n        this._vertexBuffers[\"uvs\"] = this._uvBuffer.createVertexBuffer(\"uvs\", 0, 4, 4, true);\r\n    }\r\n\r\n    private _setShaders(vertex: string, fragment: string) {\r\n        this._drawWrapperBase?.dispose();\r\n\r\n        this._drawWrapperBase = new DrawWrapper(this._engine);\r\n\r\n        if (this._drawWrapperBase.drawContext) {\r\n            this._drawWrapperBase.drawContext.useInstancing = true;\r\n        }\r\n\r\n        const defines = \"\";\r\n\r\n        this._drawWrapperBase.effect = this._engine.createEffect(\r\n            {\r\n                vertexSource: vertex,\r\n                fragmentSource: fragment,\r\n            },\r\n            [\"offsets\", \"world0\", \"world1\", \"world2\", \"world3\", \"uvs\"],\r\n            [\"parentWorld\", \"view\", \"projection\", \"uColor\", \"thickness\", \"uStrokeColor\", \"uStrokeInsetWidth\", \"uStrokeOutsetWidth\", \"mode\", \"transform\"],\r\n            [\"fontAtlas\"],\r\n            defines,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this._shaderLanguage\r\n        );\r\n\r\n        this._drawWrapperBase.effect._refCount++;\r\n    }\r\n\r\n    /**\r\n     * Add a paragraph of text to the renderer\r\n     * @param text define the text to add\r\n     * @param options define the options to use for the paragraph (optional)\r\n     * @param worldMatrix define the world matrix to use for the paragraph (optional)\r\n     */\r\n    public addParagraph(text: string, options?: Partial<ParagraphOptions>, worldMatrix?: IMatrixLike) {\r\n        const paragraph = new SdfTextParagraph(text, this._font, options);\r\n\r\n        const fontScale = this._font.scale;\r\n\r\n        const texWidth = this._font._font.common.scaleW;\r\n        const texHeight = this._font._font.common.scaleH;\r\n        const glyphs = paragraph.glyphs.filter((g) => g.char.page >= 0);\r\n\r\n        let worldMatrixToUse = worldMatrix;\r\n\r\n        if (!worldMatrixToUse) {\r\n            const lineHeight = paragraph.lineHeight * fontScale;\r\n            const lineOffset = (paragraph.lines.length * lineHeight) / 2;\r\n            TranslationMatrixToRef(0, this._baseLine - lineOffset, 0, this._lineMatrix);\r\n            worldMatrixToUse = this._lineMatrix;\r\n        }\r\n\r\n        ScalingMatrixToRef(fontScale, fontScale, 1.0, this._fontScaleMatrix);\r\n        TranslationMatrixToRef(0.5, -0.5, 0, this._offsetMatrix);\r\n\r\n        const charsUvsBase = this._charUvs.length;\r\n        const matricesBase = this._charMatrices.length;\r\n        glyphs.forEach((g, i) => {\r\n            this._charUvs[charsUvsBase + i * 4 + 0] = g.char.x / texWidth;\r\n            this._charUvs[charsUvsBase + i * 4 + 1] = g.char.y / texHeight;\r\n            this._charUvs[charsUvsBase + i * 4 + 2] = g.char.width / texWidth;\r\n            this._charUvs[charsUvsBase + i * 4 + 3] = g.char.height / texHeight;\r\n\r\n            const x = g.x + g.char.xoffset;\r\n            const y = 1.0 - (g.y + g.char.yoffset);\r\n\r\n            ScalingMatrixToRef(g.char.width, g.char.height, 1.0, this._scalingMatrix);\r\n            MultiplyMatricesToRef(this._offsetMatrix, this._scalingMatrix, this._baseMatrix);\r\n\r\n            TranslationMatrixToRef(x * fontScale, y * fontScale, 0.0, this._translationMatrix);\r\n            MultiplyMatricesToRef(this._baseMatrix, this._fontScaleMatrix, this._scaledMatrix);\r\n            MultiplyMatricesToRef(this._scaledMatrix, this._translationMatrix, this._localMatrix);\r\n\r\n            MultiplyMatricesToRef(this._localMatrix, worldMatrixToUse, this._finalMatrix);\r\n            CopyMatrixToArray(this._finalMatrix, this._charMatrices, matricesBase + i * 16);\r\n        });\r\n\r\n        this._isDirty = true;\r\n\r\n        this._baseLine -= paragraph.lineHeight * fontScale * paragraph.lines.length;\r\n    }\r\n\r\n    /**\r\n     * Render the text using the provided view and projection matrices\r\n     * @param viewMatrix define the view matrix to use\r\n     * @param projectionMatrix define the projection matrix to use\r\n     */\r\n    public render(viewMatrix: IMatrixLike, projectionMatrix: IMatrixLike): void {\r\n        const drawWrapper = this._drawWrapperBase;\r\n\r\n        const effect = drawWrapper.effect!;\r\n\r\n        // Check\r\n        if (!effect.isReady()) {\r\n            return;\r\n        }\r\n        const engine = this._engine;\r\n\r\n        engine.setState(false);\r\n        engine.enableEffect(drawWrapper);\r\n\r\n        if (this.ignoreDepthBuffer) {\r\n            engine.setDepthBuffer(false);\r\n        }\r\n\r\n        if (this._parent) {\r\n            CopyMatrixToRef(this._parent.getWorldMatrix(), this._parentWorldMatrix);\r\n        } else {\r\n            IdentityMatrixToRef(this._parentWorldMatrix);\r\n        }\r\n\r\n        effect.setInt(\"mode\", this.isBillboard ? (this.isBillboardScreenProjected ? 2 : 1) : 0);\r\n        effect.setMatrix(\"parentWorld\", this._parentWorldMatrix);\r\n        effect.setMatrix(\"view\", viewMatrix);\r\n        effect.setMatrix(\"projection\", projectionMatrix);\r\n        effect.setMatrix(\"transform\", this.transformMatrix);\r\n\r\n        // Texture\r\n        effect.setTexture(\"fontAtlas\", this._font.textures[0]);\r\n        effect.setDirectColor4(\"uColor\", this.color);\r\n        effect.setDirectColor4(\"uStrokeColor\", this.strokeColor);\r\n        effect.setFloat(\"thickness\", this.thicknessControl * 0.9);\r\n        effect.setFloat(\"uStrokeInsetWidth\", this.strokeInsetWidth);\r\n        effect.setFloat(\"uStrokeOutsetWidth\", this.strokeOutsetWidth);\r\n\r\n        const instanceCount = this._charMatrices.length / 16;\r\n\r\n        // Need update?\r\n        if (this._isDirty) {\r\n            this._isDirty = false;\r\n\r\n            if (this._worldBuffer!.getBuffer()!.capacity / 4 < instanceCount * 16) {\r\n                this._resizeBuffers(instanceCount);\r\n            }\r\n\r\n            this._worldBuffer!.update(this._charMatrices);\r\n            this._uvBuffer!.update(this._charUvs);\r\n        }\r\n\r\n        if (this._useVAO) {\r\n            if (!this._vertexArrayObject) {\r\n                this._vertexArrayObject = (engine as ThinEngine).recordVertexArrayObject(this._vertexBuffers, null, effect);\r\n            }\r\n            (engine as ThinEngine).bindVertexArrayObject(this._vertexArrayObject, null);\r\n        } else {\r\n            // VBOs\r\n            engine.bindBuffers(this._vertexBuffers, null, effect);\r\n        }\r\n\r\n        engine.setAlphaMode(Constants.ALPHA_COMBINE);\r\n        engine.drawArraysType(Constants.MATERIAL_TriangleStripDrawMode, 0, 4, instanceCount);\r\n        engine.unbindInstanceAttributes();\r\n        engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        if (this.ignoreDepthBuffer) {\r\n            engine.setDepthBuffer(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._worldBuffer) {\r\n            this._worldBuffer.dispose();\r\n            this._worldBuffer = null;\r\n        }\r\n\r\n        if (this._uvBuffer) {\r\n            this._uvBuffer.dispose();\r\n            this._uvBuffer = null;\r\n        }\r\n\r\n        if (this._spriteBuffer) {\r\n            this._spriteBuffer.dispose();\r\n            this._spriteBuffer = null;\r\n        }\r\n\r\n        if (this._vertexArrayObject) {\r\n            (this._engine as ThinEngine).releaseVertexArrayObject(this._vertexArrayObject);\r\n            (<any>this._vertexArrayObject) = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextRenderer instance asynchronously\r\n     * @param font define the font asset to use\r\n     * @param engine define the engine to use\r\n     * @returns a promise that resolves to the created TextRenderer instance\r\n     */\r\n    public static async CreateTextRendererAsync(font: FontAsset, engine: AbstractEngine) {\r\n        if (!engine.getCaps().instancedArrays || !engine._features.supportSpriteInstancing) {\r\n            throw new Error(\"Instanced arrays are required for MSDF text rendering.\");\r\n        }\r\n\r\n        let shaderLanguage = ShaderLanguage.GLSL;\r\n        let vertex: string = \"\";\r\n        let fragment: string = \"\";\r\n        if (engine.isWebGPU) {\r\n            shaderLanguage = ShaderLanguage.WGSL;\r\n            vertex = (await import(\"./shadersWGSL/msdf.vertex\")).msdfVertexShaderWGSL.shader;\r\n            fragment = (await import(\"./shadersWGSL/msdf.fragment\")).msdfPixelShaderWGSL.shader;\r\n        } else {\r\n            vertex = (await import(\"./shaders/msdf.vertex\")).msdfVertexShader.shader;\r\n            fragment = (await import(\"./shaders/msdf.fragment\")).msdfPixelShader.shader;\r\n        }\r\n\r\n        const textRenderer = new TextRenderer(engine, shaderLanguage, font);\r\n        textRenderer._setShaders(vertex, fragment);\r\n\r\n        return textRenderer;\r\n    }\r\n}\r\n","import type { NavMesh, NavMeshCreateParams, OffMeshConnectionParams, TileCache, UnsignedCharArray, UnsignedShortArray } from \"@recast-navigation/core\";\n\nimport { GetRecast } from \"../factory/common\";\n\n/**\n * Creates a default tile cache mesh process function\n * @param offMeshConnections offMeshConnections\n * @param area the area to be set for each poly\n * @param flags the flags to be set for each poly\n * @returns the tile cache mesh process function\n */\nexport function CreateDefaultTileCacheMeshProcess(offMeshConnections: OffMeshConnectionParams[] = [], area = 0, flags = 1) {\n    return new (GetRecast().TileCacheMeshProcess)((navMeshCreateParams: NavMeshCreateParams, polyAreas: UnsignedCharArray, polyFlags: UnsignedShortArray) => {\n        for (let i = 0; i < navMeshCreateParams.polyCount(); ++i) {\n            polyAreas.set(i, area);\n            polyFlags.set(i, flags);\n        }\n\n        if (offMeshConnections.length > 0) {\n            navMeshCreateParams.setOffMeshConnections(offMeshConnections);\n        }\n    });\n}\n\n/**\n * Waits until the tile cache is fully updated\n * @param navMesh The NavMesh\n * @param tileCache THe TileCache\n */\nexport function WaitForFullTileCacheUpdate(navMesh: NavMesh, tileCache: TileCache) {\n    let upToDate = false;\n    while (!upToDate) {\n        const result = tileCache.update(navMesh);\n        upToDate = result.upToDate;\n    }\n}\n","import type { SoloNavMeshGeneratorConfig, TileCacheGeneratorConfig, TiledNavMeshGeneratorConfig } from \"@recast-navigation/generators\";\nimport type { CrowdAgentParams } from \"@recast-navigation/core\";\n\nimport { Logger } from \"core/Misc/logger\";\n\nimport type { IAgentParametersV2, INavMeshParametersV2 } from \"../types\";\nimport { CreateDefaultTileCacheMeshProcess } from \"./tile-cache\";\n\nexport const DefaultMaxObstacles = 128;\n\n/**\n * Creates a SoloNavMesh configuration based on the provided parameters.\n * @param parameters The parameters used to configure the SoloNavMesh generation.\n * @returns A configuration object for generating a SoloNavMesh.\n * @see https://docs.recast-navigation-js.isaacmason.com/types/index.RecastConfig.html\n */\nexport function CreateSoloNavMeshConfig(parameters: INavMeshParametersV2): Partial<SoloNavMeshGeneratorConfig> {\n    return ToSoloNavMeshGeneratorConfig(parameters);\n}\n\n/**\n * Creates a TiledNavMesh configuration based on the provided parameters.\n * @param parameters The parameters used to configure the TiledNavMesh generation.\n * @returns A configuration object for generating a TiledNavMesh.\n */\nexport function CreateTiledNavMeshConfig(parameters: INavMeshParametersV2): Partial<TiledNavMeshGeneratorConfig> {\n    const cfg: Partial<TiledNavMeshGeneratorConfig> = {\n        ...CreateSoloNavMeshConfig(parameters),\n        tileSize: parameters.tileSize ?? 32,\n    };\n    return cfg;\n}\n\n/**\n * Creates a TileCacheNavMesh configuration based on the provided parameters.\n * @param parameters The parameters used to configure the TileCacheNavMesh generation.\n * @returns A configuration object for generating a TileCacheNavMesh.\n */\nexport function CreateTileCacheNavMeshConfig(parameters: INavMeshParametersV2): Partial<TileCacheGeneratorConfig> {\n    const cfg: Partial<TileCacheGeneratorConfig> = {\n        ...CreateTiledNavMeshConfig(parameters),\n        expectedLayersPerTile: parameters.expectedLayersPerTile ?? 1,\n        maxObstacles: parameters.maxObstacles ?? DefaultMaxObstacles,\n    };\n\n    if (parameters.tileCacheMeshProcess) {\n        cfg.tileCacheMeshProcess = parameters.tileCacheMeshProcess;\n    } else if (parameters.offMeshConnections) {\n        Logger.Warn(\"offMeshConnections are required but no tileCacheMeshProcess is set. Using fallback DefaultTileCacheMeshProcess.\");\n        cfg.tileCacheMeshProcess = CreateDefaultTileCacheMeshProcess(parameters.offMeshConnections);\n    }\n\n    return cfg;\n}\n\n/**\n * Convert IAgentParameters to Recast CrowdAgentParams\n * @param config Agent parameters\n * @returns Recast crowd agent paramaters\n */\nexport function ToSoloNavMeshGeneratorConfig(config: INavMeshParametersV2): Partial<SoloNavMeshGeneratorConfig> {\n    return Object.fromEntries(Object.entries(config).filter(([_, v]) => v !== undefined));\n}\n\n/**\n * Convert IAgentParameters to Recast CrowdAgentParams\n * @param agentParams Agent parameters\n * @returns Recast crowd agent paramaters\n */\nexport function ToCrowdAgentParams(agentParams: IAgentParametersV2): Partial<CrowdAgentParams> {\n    return Object.fromEntries(Object.entries(agentParams).filter(([_, v]) => v !== undefined));\n}\n","import type { Crowd } from \"@recast-navigation/core\";\n\nimport type { Nullable } from \"core/types\";\nimport type { IVector3Like } from \"core/Maths/math.like\";\nimport type { TransformNode } from \"core/Meshes/transformNode\";\nimport type { ICrowd } from \"core/Navigation/INavigationEngine\";\nimport { Vector3 } from \"core/Maths/math.vector\";\nimport { Epsilon } from \"core/Maths/math.constants\";\nimport type { Observer } from \"core/Misc/observable\";\nimport { Observable } from \"core/Misc/observable\";\nimport type { Scene } from \"core/scene\";\n\nimport type { RecastNavigationJSPluginV2 } from \"./RecastNavigationJSPlugin\";\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\nimport { ToCrowdAgentParams } from \"../common/config\";\nimport type { IAgentParametersV2 } from \"../types\";\nimport { GetRecast } from \"../factory/common\";\n\n/**\n * Recast Detour crowd implementation\n * This class provides methods to manage a crowd of agents, allowing them to navigate a navigation mesh.\n * It supports adding agents, updating their parameters, moving them to destinations, and checking their states.\n * The crowd is updated in the scene's animation loop, and it notifies observers when agents reach their destinations.\n */\nexport class RecastJSCrowd implements ICrowd {\n    /**\n     * Recast plugin\n     */\n    public get navigationPlugin(): RecastNavigationJSPluginV2 {\n        return this._navigationPlugin;\n    }\n\n    /**\n     * Link to the detour crowd\n     */\n    public get recastCrowd(): Crowd {\n        return this._recastCrowd;\n    }\n\n    /**\n     * One transform per agent\n     */\n    public get transforms(): TransformNode[] {\n        return this._transforms;\n    }\n\n    /**\n     * All agents created\n     */\n    public get agents(): readonly number[] {\n        return Object.freeze(this._agents);\n    }\n\n    /**\n     * Agents reach radius\n     */\n    public get reachRadii(): readonly number[] {\n        return Object.freeze(this._reachRadii);\n    }\n\n    private _navigationPlugin: RecastNavigationJSPluginV2;\n    private _recastCrowd: Crowd;\n    private _transforms: TransformNode[] = [];\n    private _agents: number[] = [];\n    private _reachRadii: number[] = [];\n\n    /**\n     * true when a destination is active for an agent and notifier hasn't been notified of reach\n     */\n    private _agentDestinationArmed: boolean[] = new Array<boolean>();\n    /**\n     * agent current target\n     */\n    private _agentDestination: Vector3[] = new Array<Vector3>();\n    /**\n     * Link to the scene is kept to unregister the crowd from the scene\n     */\n    private _scene: Scene;\n\n    private _engine: AbstractEngine;\n\n    /**\n     * Observer for crowd updates\n     */\n    private _onBeforeAnimationsObserver: Nullable<Observer<Scene>> = null;\n\n    /**\n     * Fires each time an agent is in reach radius of its destination\n     */\n    public onReachTargetObservable = new Observable<{\n        /**\n         *\n         */\n        agentIndex: number;\n        /**\n         *\n         */\n        destination: Vector3;\n    }>();\n\n    /**\n     * Constructor\n     * @param plugin recastJS plugin\n     * @param maxAgents the maximum agent count in the crowd\n     * @param maxAgentRadius the maximum radius an agent can have\n     * @param scene to attach the crowd to\n     * @returns the crowd you can add agents to\n     */\n    public constructor(plugin: RecastNavigationJSPluginV2, maxAgents: number, maxAgentRadius: number, scene: Scene) {\n        this._navigationPlugin = plugin;\n\n        if (!plugin.navMesh) {\n            throw new Error(\"There is no NavMesh generated.\");\n        }\n\n        this._recastCrowd = new (GetRecast().Crowd)(plugin.navMesh, {\n            maxAgents,\n            maxAgentRadius,\n        });\n\n        this._scene = scene;\n        this._engine = scene.getEngine();\n\n        this._onBeforeAnimationsObserver = scene.onBeforeAnimationsObservable.add(() => {\n            this.update(this._engine.getDeltaTime() * 0.001 * plugin.timeFactor);\n        });\n    }\n\n    /**\n     * Add a new agent to the crowd with the specified parameter a corresponding transformNode.\n     * You can attach anything to that node. The node position is updated in the scene update tick.\n     * @param pos world position that will be constrained by the navigation mesh\n     * @param parameters agent parameters\n     * @param transform hooked to the agent that will be update by the scene\n     * @returns agent index\n     */\n    public addAgent(pos: IVector3Like, parameters: IAgentParametersV2, transform: TransformNode): number {\n        const agentParams = ToCrowdAgentParams(parameters);\n\n        const agent = this._recastCrowd.addAgent({ x: pos.x, y: pos.y, z: pos.z }, agentParams);\n\n        this._transforms.push(transform);\n        this._agents.push(agent.agentIndex);\n        this._reachRadii.push(parameters.reachRadius ? parameters.reachRadius : parameters.radius);\n        this._agentDestinationArmed.push(false);\n        this._agentDestination.push(new Vector3(0, 0, 0));\n\n        return agent.agentIndex;\n    }\n\n    /**\n     * Returns the agent position in world space\n     * @param index agent index returned by addAgent\n     * @returns world space position\n     */\n    public getAgentPosition(index: number): Vector3 {\n        const agentPos = this._recastCrowd.getAgent(index)?.position() ?? Vector3.ZeroReadOnly;\n        return new Vector3(agentPos.x, agentPos.y, agentPos.z);\n    }\n\n    /**\n     * Returns the agent position result in world space\n     * @param index agent index returned by addAgent\n     * @param result output world space position\n     */\n    public getAgentPositionToRef(index: number, result: Vector3): void {\n        const agentPos = this._recastCrowd.getAgent(index)?.position() ?? Vector3.ZeroReadOnly;\n        result.set(agentPos.x, agentPos.y, agentPos.z);\n    }\n\n    /**\n     * Returns the agent velocity in world space\n     * @param index agent index returned by addAgent\n     * @returns world space velocity\n     */\n    public getAgentVelocity(index: number): Vector3 {\n        const agentVel = this._recastCrowd.getAgent(index)?.velocity() ?? Vector3.ZeroReadOnly;\n        return new Vector3(agentVel.x, agentVel.y, agentVel.z);\n    }\n\n    /**\n     * Returns the agent velocity result in world space\n     * @param index agent index returned by addAgent\n     * @param result output world space velocity\n     */\n    public getAgentVelocityToRef(index: number, result: Vector3): void {\n        const agentVel = this._recastCrowd.getAgent(index)?.velocity() ?? Vector3.ZeroReadOnly;\n        result.set(agentVel.x, agentVel.y, agentVel.z);\n    }\n\n    /**\n     * Returns the agent next target point on the path\n     * @param index agent index returned by addAgent\n     * @returns world space position\n     */\n    public getAgentNextTargetPath(index: number): Vector3 {\n        const pathTargetPos = this._recastCrowd.getAgent(index)?.nextTargetInPath() ?? Vector3.ZeroReadOnly;\n        return new Vector3(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n    }\n\n    /**\n     * Returns the agent next target point on the path\n     * @param index agent index returned by addAgent\n     * @param result output world space position\n     */\n    public getAgentNextTargetPathToRef(index: number, result: Vector3): void {\n        const pathTargetPos = this._recastCrowd.getAgent(index)?.nextTargetInPath() ?? Vector3.ZeroReadOnly;\n        result.set(pathTargetPos.x, pathTargetPos.y, pathTargetPos.z);\n    }\n\n    /**\n     * Gets the agent state\n     * @param index agent index returned by addAgent\n     * @returns agent state, 0 = DT_CROWDAGENT_STATE_INVALID, 1 = DT_CROWDAGENT_STATE_WALKING, 2 = DT_CROWDAGENT_STATE_OFFMESH\n     */\n    public getAgentState(index: number): number {\n        return this._recastCrowd.getAgent(index)?.state() ?? 0; // invalid\n    }\n\n    /**\n     * returns true if the agent in over an off mesh link connection\n     * @param index agent index returned by addAgent\n     * @returns true if over an off mesh link connection\n     */\n    public overOffmeshConnection(index: number): boolean {\n        return this._recastCrowd.getAgent(index)?.overOffMeshConnection() ?? false;\n    }\n\n    /**\n     * Asks a particular agent to go to a destination. That destination is constrained by the navigation mesh\n     * @param index agent index returned by addAgent\n     * @param destination targeted world position\n     */\n    public agentGoto(index: number, destination: IVector3Like): void {\n        this._recastCrowd.getAgent(index)?.requestMoveTarget(destination);\n\n        // arm observer\n        const item = this._agents.indexOf(index);\n        if (item > -1) {\n            this._agentDestinationArmed[item] = true;\n            this._agentDestination[item].set(destination.x, destination.y, destination.z);\n        }\n    }\n\n    /**\n     * Teleport the agent to a new position\n     * @param index agent index returned by addAgent\n     * @param destination targeted world position\n     */\n    public agentTeleport(index: number, destination: IVector3Like): void {\n        this._recastCrowd.getAgent(index)?.teleport(destination);\n    }\n\n    /**\n     * Update agent parameters\n     * @param index agent index returned by addAgent\n     * @param parameters agent parameters\n     */\n    public updateAgentParameters(index: number, parameters: IAgentParametersV2): void {\n        const agent = this._recastCrowd.getAgent(index);\n        if (!agent) {\n            return;\n        }\n\n        const agentParams = agent.parameters();\n\n        if (!agentParams) {\n            return;\n        }\n\n        if (parameters.radius !== undefined) {\n            agentParams.radius = parameters.radius;\n        }\n        if (parameters.height !== undefined) {\n            agentParams.height = parameters.height;\n        }\n        if (parameters.maxAcceleration !== undefined) {\n            agentParams.maxAcceleration = parameters.maxAcceleration;\n        }\n        if (parameters.maxSpeed !== undefined) {\n            agentParams.maxSpeed = parameters.maxSpeed;\n        }\n        if (parameters.collisionQueryRange !== undefined) {\n            agentParams.collisionQueryRange = parameters.collisionQueryRange;\n        }\n        if (parameters.pathOptimizationRange !== undefined) {\n            agentParams.pathOptimizationRange = parameters.pathOptimizationRange;\n        }\n        if (parameters.separationWeight !== undefined) {\n            agentParams.separationWeight = parameters.separationWeight;\n        }\n\n        agent.updateParameters(agentParams);\n    }\n\n    /**\n     * remove a particular agent previously created\n     * @param index agent index returned by addAgent\n     */\n    public removeAgent(index: number): void {\n        this._recastCrowd.removeAgent(index);\n\n        const item = this._agents.indexOf(index);\n        if (item > -1) {\n            this._agents.splice(item, 1);\n            this._transforms.splice(item, 1);\n            this._reachRadii.splice(item, 1);\n            this._agentDestinationArmed.splice(item, 1);\n            this._agentDestination.splice(item, 1);\n        }\n    }\n\n    /**\n     * get the list of all agents attached to this crowd\n     * @returns list of agent indices\n     */\n    public getAgents(): number[] {\n        return this._agents;\n    }\n\n    /**\n     * Tick update done by the Scene. Agent position/velocity/acceleration is updated by this function\n     * @param deltaTime in seconds\n     */\n    public update(deltaTime: number): void {\n        if (deltaTime <= Epsilon) {\n            return;\n        }\n\n        // update crowd\n        const timeStep = this._navigationPlugin.getTimeStep();\n        const maxStepCount = this._navigationPlugin.getMaximumSubStepCount();\n        if (timeStep <= Epsilon) {\n            this._recastCrowd.update(deltaTime);\n        } else {\n            let iterationCount = Math.floor(deltaTime / timeStep);\n            if (maxStepCount && iterationCount > maxStepCount) {\n                iterationCount = maxStepCount;\n            }\n            if (iterationCount < 1) {\n                iterationCount = 1;\n            }\n\n            const step = deltaTime / iterationCount;\n            for (let i = 0; i < iterationCount; i++) {\n                this._recastCrowd.update(step);\n            }\n        }\n\n        // update transforms\n        for (let index = 0; index < this._agents.length; index++) {\n            // update transform position\n            const agentIndex = this._agents[index];\n            const agentPosition = this.getAgentPosition(agentIndex);\n            this._transforms[index].position = agentPosition;\n            // check agent reach destination\n            if (this._agentDestinationArmed[index]) {\n                const dx = agentPosition.x - this._agentDestination[index].x;\n                const dz = agentPosition.z - this._agentDestination[index].z;\n                const radius = this._reachRadii[index];\n                const groundY = this._agentDestination[index].y - this._reachRadii[index];\n                const ceilingY = this._agentDestination[index].y + this._reachRadii[index];\n                const distanceXZSquared = dx * dx + dz * dz;\n                if (agentPosition.y > groundY && agentPosition.y < ceilingY && distanceXZSquared < radius * radius) {\n                    this._agentDestinationArmed[index] = false;\n                    this.onReachTargetObservable.notifyObservers({\n                        agentIndex: agentIndex,\n                        destination: this._agentDestination[index],\n                    });\n                }\n            }\n        }\n    }\n\n    /**\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n     * The queries will try to find a solution within those bounds\n     * default is (1,1,1)\n     * @param extent x,y,z value that define the extent around the queries point of reference\n     */\n    setDefaultQueryExtent(extent: IVector3Like): void {\n        this._navigationPlugin.setDefaultQueryExtent(extent);\n    }\n\n    /**\n     * Get the Bounding box extent specified by setDefaultQueryExtent\n     * @returns the box extent values\n     */\n    getDefaultQueryExtent(): Vector3 {\n        const p = this._navigationPlugin.getDefaultQueryExtent();\n        return new Vector3(p.x, p.y, p.z);\n    }\n\n    /**\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\n     * @param result output the box extent values\n     */\n    getDefaultQueryExtentToRef(result: Vector3): void {\n        const p = this._navigationPlugin.getDefaultQueryExtent();\n        result.set(p.x, p.y, p.z);\n    }\n\n    /**\n     * Get the next corner points composing the path (max 4 points)\n     * @param index agent index returned by addAgent\n     * @returns array containing world position composing the path\n     */\n    public getCorners(index: number): Vector3[] {\n        const corners = this._recastCrowd.getAgent(index)?.corners();\n        if (!corners) {\n            return [];\n        }\n\n        const positions = [];\n        for (let i = 0; i < corners.length; i++) {\n            positions.push(new Vector3(corners[i].x, corners[i].y, corners[i].z));\n        }\n        return positions;\n    }\n\n    /**\n     * Release all resources\n     */\n    public dispose(): void {\n        this._recastCrowd.destroy();\n\n        if (this._onBeforeAnimationsObserver) {\n            this._scene.onBeforeAnimationsObservable.remove(this._onBeforeAnimationsObserver);\n            this._onBeforeAnimationsObserver = null;\n        }\n\n        this.onReachTargetObservable.clear();\n    }\n}\n","import { Vector3 } from \"core/Maths/math.vector\";\nimport { Logger } from \"core/Misc/logger\";\n\nimport type { ComputePathResult } from \"../types\";\n\n/**\n *  Converts navigation path points to a Vector3 array.\n *  @param navPath The navigation path containing points and success status.\n *  @returns An array of Vector3 points representing the navigation path.\n */\nexport function ConvertNavPathPoints(navPath: ComputePathResult): Vector3[] {\n    const positions = [];\n\n    if (navPath.success) {\n        const pointCount = navPath.path.length;\n        for (let pt = 0; pt < pointCount; pt++) {\n            const p = navPath.path[pt];\n            positions.push(new Vector3(p.x, p.y, p.z));\n        }\n    } else {\n        Logger.Warn(\"Unable to convert navigation path point, because navPath generation has failed.\");\n    }\n\n    return positions;\n}\n","import type { NavMesh, NavMeshQuery, TileCache, TileCacheMeshProcess } from \"@recast-navigation/core\";\nimport type { SoloNavMeshGeneratorIntermediates, TileCacheGeneratorIntermediates, TiledNavMeshGeneratorIntermediates } from \"@recast-navigation/generators\";\n\nimport type { IVector3Like } from \"core/Maths/math.like\";\nimport type { Vector3 } from \"core/Maths/math.vector\";\nimport type { IAgentParameters, INavMeshParameters } from \"core/Navigation/INavigationEngine\";\nimport type { Nullable } from \"core/types\";\n\n/**\n * Recast injection type\n */\nexport type RecastInjection = any; // typeof import(\"@recast-navigation/core\") & typeof import(\"@recast-navigation/generators\");\n\n/**\n * Off-mesh connection data\n */\nexport interface IOffMeshConnection {\n    /**\n     * The start position of the off-mesh connection.\n     */\n    startPosition: IVector3Like;\n    /**\n     * The end position of the off-mesh connection.\n     */\n    endPosition: IVector3Like;\n    /**\n     * The radius of the off-mesh connection.\n     */\n    radius: number;\n    /**\n     * The type of the off-mesh connection.\n     */\n    bidirectional: boolean;\n    /**\n     * The area type of the off-mesh connection.\n     */\n    area: number;\n    /**\n     * The flags of the off-mesh connection.\n     */\n    flags: number;\n    /**\n     * The user ID of the off-mesh connection.\n     * @remarks This can be used to associate the off-mesh connection with a specific user\n     */\n    userId?: number;\n}\n\n/**\n * Result of a navigation mesh creation.\n */\nexport type CreateNavMeshResult = Nullable<{\n    /**\n     * Navigation mesh\n     */\n    navMesh: NavMesh;\n    /**\n     * Navigation mesh query\n     */\n    navMeshQuery: NavMeshQuery;\n    /**\n     * Intermediates generated during the NavMesh creation process.\n     * @remarks This is only available if the `keepIntermediates` parameter is set to true in the `INavMeshParametersV2`.\n     * It can be used for debugging or visualization purposes.\n     */\n    intermediates?: GeneratorIntermediates;\n    /**\n     * Tile cache generated during the NavMesh creation process.\n     * @remarks This is only available if the `maxObstacles` parameter is set to a value greater than 0 in the `INavMeshParametersV2`. Defaults `maxObstacles` to 128.\n     * It can be used for obstacle avoidance and dynamic navigation mesh updates.\n     * @see {@link INavMeshParametersV2}\n     */\n    tileCache?: TileCache;\n}>;\n\n/**\n * Agent parameters\n * For actual limits and default values check the recast-navigation-js docs.\n * @see https://docs.recast-navigation-js.isaacmason.com/types/index.CrowdAgentParams.html\n */\nexport interface IAgentParametersV2 extends IAgentParameters {\n    /**\n     * Flags that impact steering behavior.\n     */\n    updateFlags: number;\n    /**\n     * The index of the avoidance configuration to use for the agent. [Limits: 0 to #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS inclusive]\n     */\n    obstacleAvoidanceType: number;\n    /**\n     * The index of the query filter used by this agent.\n     */\n    queryFilterType: number;\n    /**\n     * User defined data attached to the agent.\n     */\n    userData: unknown;\n}\n\n/**\n * NavMesh parameters\n * For actual limits and default values check the recast-navigation-js docs.\n * @see https://docs.recast-navigation-js.isaacmason.com/types/index.RecastConfig.html\n */\nexport interface INavMeshParametersV2 extends INavMeshParameters {\n    /**\n     * OffMeshConnections - Teleports\n     */\n    offMeshConnections?: IOffMeshConnection[];\n    /**\n     * Whether to keep intermediate navigation mesh data for debug visualization. Default is false.\n     */\n    keepIntermediates?: boolean;\n    /**\n     * The maximum number of obstacles that can be added to the navigation mesh. Default is 32.\n     * If this value is greater then 0, the navigation mesh will be generated with a tile cache.\n     */\n    maxObstacles?: number;\n    /**\n     * The size of each tile in the tiled navigation mesh. Default is 32.\n     */\n    expectedLayersPerTile?: number;\n    /**\n     * Function which is sets the polyAreas and polyFlags for the tile cache mesh. Defaults to a function that sets all areas to 0 and flags to 1.\n     */\n    tileCacheMeshProcess?: TileCacheMeshProcess;\n    /**\n     * Don't reverse indices of the source mesh\n     */\n    doNotReverseIndices?: boolean;\n}\n\n/**\n * Result of a steer target computation.\n */\nexport type SteerTargetResult =\n    | {\n          /**\n           * Indicates whether the steering target computation was successful.\n           */\n          success: false;\n      }\n    | {\n          /**\n           * Indicates whether the steering target computation was successful.\n           */\n          success: true;\n          /**\n           * The position to steer towards.\n           */\n          steerPos: Vector3;\n          /**\n           * The flag indicating the type of steering position.\n           */\n          steerPosFlag: number;\n          /**\n           * The reference to the polygon that the steering position is associated with.\n           */\n          steerPosRef: number;\n          /**\n           * The points that make up the path to the steering position.\n           */\n          points: Vector3[];\n      };\n\n/**\n * Error types for path computation.\n */\nexport const ComputePathError = {\n    START_NEAREST_POLY_FAILED: \"START_NEAREST_POLY_FAILED\",\n    END_NEAREST_POLY_FAILED: \"END_NEAREST_POLY_FAILED\",\n    FIND_PATH_FAILED: \"FIND_PATH_FAILED\",\n    NO_POLYGON_PATH_FOUND: \"NO_POLYGON_PATH_FOUND\",\n    NO_CLOSEST_POINT_ON_LAST_POLYGON_FOUND: \"NO_CLOSEST_POINT_ON_LAST_POLYGON_FOUND\",\n};\n\nexport type ComputePathErrorType = (typeof ComputePathError)[keyof typeof ComputePathError];\n\n/**\n * Result of a path computation.\n */\nexport type ComputePathResult = {\n    /**\n     * Indicates whether the path computation was successful.\n     */\n    success: boolean;\n    /**\n     * The error message if the path computation failed.\n     */\n    error?: {\n        /**\n         * A descriptive error message.\n         */\n        name?: string;\n        /**\n         * The type of error that occurred during path computation.\n         * @remarks This will be one of the values from `ComputePathError`\n         */\n        type?: ComputePathErrorType;\n        /**\n         * Statusring describing the error.\n         */\n        status?: number;\n    };\n    /**\n     * The computed path as an array of Vector3 points.\n     */\n    path: IVector3Like[];\n};\n\n/**\n * Intermediates generated during the NavMesh creation process.\n * @remarks This is only available if the `keepIntermediates` parameter is set to true in the `INavMeshParametersV2`.\n * It can be used for debugging or visualization purposes.\n */\nexport type GeneratorIntermediates = SoloNavMeshGeneratorIntermediates | TiledNavMeshGeneratorIntermediates | TileCacheGeneratorIntermediates | null;\n","import type { NavMeshQuery, NavMesh, QueryFilter } from \"@recast-navigation/core\";\n\nimport type { IVector3Like } from \"core/Maths/math.like\";\nimport { Vector3 } from \"core/Maths/math.vector\";\n\nimport { ConvertNavPathPoints } from \"./convert\";\nimport type { RecastInjection, SteerTargetResult } from \"../types\";\nimport { ComputePathError, type ComputePathResult } from \"../types\";\nimport { GetRecast } from \"../factory/common\";\n\nconst _DELTA = new Vector3();\nconst _MOVE_TARGET = new Vector3();\n\n/**\n * Compute a smooth navigation path from start to end. Returns an empty array if no path can be computed\n * @param navMesh the navigation mesh to use\n * @param navmeshQuery the navigation mesh query to use\n * @param start world position\n * @param end world position\n * @param options options object\n * @returns array containing world position composing the path\n */\nexport function ComputeSmoothPath(\n    navMesh: NavMesh,\n    navmeshQuery: NavMeshQuery,\n    start: IVector3Like,\n    end: IVector3Like,\n    options?: {\n        filter?: QueryFilter;\n        halfExtents?: IVector3Like;\n\n        /**\n         * @default 256\n         */\n        maxPathPolys?: number;\n\n        /**\n         * @default 2048\n         */\n        maxSmoothPathPoints?: number;\n\n        /**\n         * @default 0.5\n         */\n        stepSize?: number;\n\n        /**\n         * @default 0.01\n         */\n        slop?: number;\n    }\n): Vector3[] {\n    return ConvertNavPathPoints(ComputeSmoothPathImpl(navMesh, navmeshQuery, start, end, options));\n}\n\nfunction ComputeSmoothPathImpl(\n    navMesh: NavMesh,\n    navMeshQuery: NavMeshQuery,\n    start: IVector3Like,\n    end: IVector3Like,\n    options?: {\n        filter?: QueryFilter;\n        halfExtents?: IVector3Like;\n        maxPathPolys?: number;\n        maxSmoothPathPoints?: number;\n        stepSize?: number;\n        slop?: number;\n    }\n): ComputePathResult {\n    const recast = GetRecast();\n    const filter = options?.filter ?? navMeshQuery.defaultFilter;\n    const halfExtents = options?.halfExtents ?? navMeshQuery.defaultQueryHalfExtents;\n    const maxSmoothPathPoints = options?.maxSmoothPathPoints ?? 2048;\n    const maxPathPolys = options?.maxPathPolys ?? 256;\n    const stepSize = options?.stepSize ?? 0.5;\n    const slop = options?.slop ?? 0.01;\n\n    // find nearest polygons for start and end positions\n    const startNearestPolyResult = navMeshQuery.findNearestPoly(start, {\n        filter,\n        halfExtents,\n    });\n\n    if (!startNearestPolyResult.success) {\n        return {\n            success: false,\n            error: {\n                type: ComputePathError.START_NEAREST_POLY_FAILED,\n                status: startNearestPolyResult.status,\n            },\n            path: [],\n        };\n    }\n\n    const endNearestPolyResult = navMeshQuery.findNearestPoly(end, {\n        filter,\n        halfExtents,\n    });\n\n    if (!endNearestPolyResult.success) {\n        return {\n            success: false,\n            error: {\n                type: ComputePathError.END_NEAREST_POLY_FAILED,\n                status: endNearestPolyResult.status,\n            },\n            path: [],\n        };\n    }\n\n    const startRef = startNearestPolyResult.nearestRef;\n    const endRef = endNearestPolyResult.nearestRef;\n\n    // find polygon path\n    const findPathResult = navMeshQuery.findPath(startRef, endRef, start, end, {\n        filter,\n        maxPathPolys,\n    });\n\n    if (!findPathResult.success) {\n        return {\n            success: false,\n            error: {\n                type: ComputePathError.FIND_PATH_FAILED,\n                status: findPathResult.status,\n            },\n            path: [],\n        };\n    }\n\n    if (findPathResult.polys.size <= 0) {\n        return {\n            success: false,\n            error: {\n                type: ComputePathError.NO_POLYGON_PATH_FOUND,\n            },\n            path: [],\n        };\n    }\n\n    const lastPoly = findPathResult.polys.get(findPathResult.polys.size - 1);\n\n    let closestEnd = end;\n\n    if (lastPoly !== endRef) {\n        const lastPolyClosestPointResult = navMeshQuery.closestPointOnPoly(lastPoly, end);\n\n        if (!lastPolyClosestPointResult.success) {\n            return {\n                success: false,\n                error: {\n                    type: ComputePathError.NO_CLOSEST_POINT_ON_LAST_POLYGON_FOUND,\n                    status: lastPolyClosestPointResult.status,\n                },\n                path: [],\n            };\n        }\n\n        closestEnd = lastPolyClosestPointResult.closestPoint;\n    }\n\n    // Iterate over the path to find a smooth path on the detail mesh\n    const iterPos = new Vector3(start.x, start.y, start.z);\n    const targetPos = new Vector3(closestEnd.x, closestEnd.y, closestEnd.z);\n\n    const polys = Array.from(findPathResult.polys.getHeapView());\n    const smoothPath: Vector3[] = [];\n\n    smoothPath.push(iterPos.clone());\n\n    while (polys.length > 0 && smoothPath.length < maxSmoothPathPoints) {\n        // Find location to steer towards\n        const steerTarget = getSteerTarget(navMeshQuery, iterPos, targetPos, slop, polys, recast);\n\n        if (!steerTarget.success) {\n            break;\n        }\n\n        const isEndOfPath = steerTarget.steerPosFlag & recast.Detour.DT_STRAIGHTPATH_END;\n        const isOffMeshConnection = steerTarget.steerPosFlag & recast.Detour.DT_STRAIGHTPATH_OFFMESH_CONNECTION;\n\n        // Find movement delta.\n        const steerPos = steerTarget.steerPos;\n        const delta = _DELTA.copyFrom(steerPos).subtract(iterPos);\n        let len = Math.sqrt(delta.dot(delta));\n\n        // If the steer target is the end of the path or an off-mesh connection, do not move past the location.\n        if ((isEndOfPath || isOffMeshConnection) && len < stepSize) {\n            len = 1;\n        } else {\n            len = stepSize / len;\n        }\n\n        const moveTarget = _MOVE_TARGET.copyFrom(iterPos).addInPlace(delta.scale(len));\n\n        // Move\n        const moveAlongSurface = navMeshQuery.moveAlongSurface(polys[0], iterPos, moveTarget, { filter, maxVisitedSize: 16 });\n\n        if (!moveAlongSurface.success) {\n            break;\n        }\n\n        const result = moveAlongSurface.resultPosition;\n\n        fixupCorridor(polys, maxPathPolys, moveAlongSurface.visited);\n        fixupShortcuts(polys, navMesh, recast);\n\n        const polyHeightResult = navMeshQuery.getPolyHeight(polys[0], result);\n\n        if (polyHeightResult.success) {\n            result.y = polyHeightResult.height;\n        }\n\n        iterPos.copyFromFloats(result.x, result.y, result.z);\n\n        // Handle end of path and off-mesh links when close enough\n        if (isEndOfPath && inRange(iterPos, steerTarget.steerPos, slop, 1.0)) {\n            // Reached end of path\n            iterPos.copyFrom(targetPos);\n\n            if (smoothPath.length < maxSmoothPathPoints) {\n                smoothPath.push(new Vector3(iterPos.x, iterPos.y, iterPos.z));\n            }\n\n            break;\n        } else if (isOffMeshConnection && inRange(iterPos, steerTarget.steerPos, slop, 1.0)) {\n            // Reached off-mesh connection.\n\n            // Advance the path up to and over the off-mesh connection.\n            const offMeshConRef = steerTarget.steerPosRef;\n\n            // Advance the path up to and over the off-mesh connection.\n            let prevPolyRef = 0;\n            let polyRef = polys[0];\n            let npos = 0;\n            while (npos < polys.length && polyRef !== offMeshConRef) {\n                prevPolyRef = polyRef;\n                polyRef = polys[npos];\n                npos++;\n            }\n\n            for (let i = npos; i < polys.length; i++) {\n                polys[i - npos] = polys[i];\n            }\n            polys.splice(npos, polys.length - npos);\n\n            // Handle the connection\n            const offMeshConnectionPolyEndPoints = navMesh.getOffMeshConnectionPolyEndPoints(prevPolyRef, polyRef);\n\n            if (offMeshConnectionPolyEndPoints.success) {\n                if (smoothPath.length < maxSmoothPathPoints) {\n                    smoothPath.push(new Vector3(iterPos.x, iterPos.y, iterPos.z));\n\n                    // Hack to make the dotted path not visible during off-mesh connection.\n                    if (smoothPath.length & 1) {\n                        smoothPath.push(new Vector3(iterPos.x, iterPos.y, iterPos.z));\n                    }\n\n                    // Move position at the other side of the off-mesh link.\n                    iterPos.copyFromFloats(offMeshConnectionPolyEndPoints.end.x, offMeshConnectionPolyEndPoints.end.y, offMeshConnectionPolyEndPoints.end.z);\n\n                    const endPositionPolyHeight = navMeshQuery.getPolyHeight(polys[0], iterPos);\n\n                    if (endPositionPolyHeight.success) {\n                        iterPos.y = endPositionPolyHeight.height;\n                    }\n                }\n            }\n        }\n\n        // Store results.\n        if (smoothPath.length < maxSmoothPathPoints) {\n            smoothPath.push(new Vector3(iterPos.x, iterPos.y, iterPos.z));\n        }\n    }\n\n    return {\n        success: true,\n        path: smoothPath,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getSteerTarget(navMeshQuery: NavMeshQuery, start: Vector3, end: Vector3, minTargetDist: number, pathPolys: number[], recast: RecastInjection): SteerTargetResult {\n    const maxSteerPoints = 3;\n    const straightPath = navMeshQuery.findStraightPath(start, end, pathPolys, {\n        maxStraightPathPoints: maxSteerPoints,\n    });\n\n    if (!straightPath.success) {\n        return {\n            success: false,\n        };\n    }\n\n    const outPoints: Vector3[] = [];\n    for (let i = 0; i < straightPath.straightPathCount; i++) {\n        const point = new Vector3(straightPath.straightPath.get(i * 3), straightPath.straightPath.get(i * 3 + 1), straightPath.straightPath.get(i * 3 + 2));\n\n        outPoints.push(point);\n    }\n\n    // Find vertex far enough to steer to\n    let ns = 0;\n    while (ns < outPoints.length) {\n        // Stop at Off-Mesh link or when point is further than slop away\n        if (straightPath.straightPathFlags.get(ns) & recast.Detour.DT_STRAIGHTPATH_OFFMESH_CONNECTION) {\n            break;\n        }\n\n        const posA = outPoints[ns];\n        const posB = start;\n\n        if (!inRange(posA, posB, minTargetDist, 1000.0)) {\n            break;\n        }\n\n        ns++;\n    }\n\n    // Failed to find good point to steer to\n    if (ns >= straightPath.straightPathCount) {\n        return {\n            success: false,\n        };\n    }\n\n    const steerPos = outPoints[ns];\n    const steerPosFlag = straightPath.straightPathFlags.get(ns);\n    const steerPosRef = straightPath.straightPathRefs.get(ns);\n\n    return {\n        success: true,\n        steerPos,\n        steerPosFlag,\n        steerPosRef,\n        points: outPoints,\n    };\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction inRange(a: Vector3, b: Vector3, r: number, h: number) {\n    const dx = b.x - a.x;\n    const dy = b.y - a.y;\n    const dz = b.z - a.z;\n    return dx * dx + dz * dz < r && Math.abs(dy) < h;\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction fixupCorridor(pathPolys: number[], maxPath: number, visitedPolyRefs: number[]) {\n    let furthestPath = -1;\n    let furthestVisited = -1;\n\n    // Find furthest common polygon.\n    for (let i = pathPolys.length - 1; i >= 0; i--) {\n        let found = false;\n        for (let j = visitedPolyRefs.length - 1; j >= 0; j--) {\n            if (pathPolys[i] === visitedPolyRefs[j]) {\n                furthestPath = i;\n                furthestVisited = j;\n                found = true;\n            }\n        }\n        if (found) {\n            break;\n        }\n    }\n\n    // If no intersection found just return current path.\n    if (furthestPath === -1 || furthestVisited === -1) {\n        return pathPolys;\n    }\n\n    // Concatenate paths.\n\n    // Adjust beginning of the buffer to include the visited.\n    const req = visitedPolyRefs.length - furthestVisited;\n    const orig = Math.min(furthestPath + 1, pathPolys.length);\n\n    let size = Math.max(0, pathPolys.length - orig);\n\n    if (req + size > maxPath) {\n        size = maxPath - req;\n    }\n    if (size) {\n        pathPolys.splice(req, size, ...pathPolys.slice(orig, orig + size));\n    }\n\n    // Store visited\n    for (let i = 0; i < req; i++) {\n        pathPolys[i] = visitedPolyRefs[visitedPolyRefs.length - (1 + i)];\n    }\n\n    return pathPolys;\n}\n\n/**\n * This function checks if the path has a small U-turn, that is,\n * a polygon further in the path is adjacent to the first polygon\n * in the path. If that happens, a shortcut is taken.\n * This can happen if the target (T) location is at tile boundary,\n * and we're (S) approaching it parallel to the tile edge.\n * The choice at the vertex can be arbitrary,\n *  +---+---+\n *  |:::|:::|\n *  +-S-+-T-+\n *  |:::|   | -- the step can end up in here, resulting U-turn path.\n *  +---+---+\n * @param pathPolys The path polygons to check for U-turns.\n * @param navMesh The navigation mesh used to check adjacency.\n * @param recast The recast injection to use.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction fixupShortcuts(pathPolys: number[], navMesh: NavMesh, recast: RecastInjection) {\n    if (pathPolys.length < 3) {\n        return;\n    }\n\n    // Get connected polygons\n    const maxNeis = 16;\n    let nneis = 0;\n    const neis: number[] = [];\n\n    const tileAndPoly = navMesh.getTileAndPolyByRef(pathPolys[0]);\n\n    if (!tileAndPoly.success) {\n        return;\n    }\n\n    const poly = tileAndPoly.poly;\n    const tile = tileAndPoly.tile;\n    for (let k = poly.firstLink(); k !== recast.Detour.DT_NULL_LINK; k = tile.links(k).next()) {\n        const link = tile.links(k);\n\n        if (link.ref() !== 0) {\n            if (nneis < maxNeis) {\n                neis.push(link.ref());\n                nneis++;\n            }\n        }\n    }\n\n    // If any of the neighbour polygons is within the next few polygons\n    // in the path, short cut to that polygon directly.\n    const maxLookAhead = 6;\n    let cut = 0;\n    for (let i = Math.min(maxLookAhead, pathPolys.length) - 1; i > 1 && cut === 0; i--) {\n        for (let j = 0; j < nneis; j++) {\n            if (pathPolys[i] === neis[j]) {\n                cut = i;\n                break;\n            }\n        }\n    }\n\n    if (cut > 1) {\n        pathPolys.splice(1, cut - 1);\n    }\n}\n","import { VertexBuffer } from \"core/Buffers/buffer\";\nimport { Matrix, Vector3 } from \"core/Maths/math.vector\";\nimport { Mesh } from \"core/Meshes/mesh\";\n\n/**\n *  Extracts positions and indices from an array of meshes.\n *  @param meshes The array of meshes from which to extract positions and indices.\n *  @returns A tuple containing a Float32Array of positions and a Uint32Array of\n */\nexport function GetPositionsAndIndices(\n    meshes: Mesh[],\n    options?: {\n        doNotReverseIndices?: boolean;\n    }\n): [positions: Float32Array, indices: Uint32Array] {\n    let offset = 0;\n    let index: number;\n    let tri: number;\n    let pt: number;\n    const positions: number[] = [];\n    const indices: number[] = [];\n\n    for (index = 0; index < meshes.length; index++) {\n        if (meshes[index]) {\n            const mesh = meshes[index];\n\n            const meshIndices = options?.doNotReverseIndices ? mesh.getIndices(false, true) : GetReversedIndices(mesh);\n            if (!meshIndices) {\n                continue;\n            }\n\n            const meshPositions = mesh.getVerticesData(VertexBuffer.PositionKind, false, false);\n            if (!meshPositions) {\n                continue;\n            }\n\n            const worldMatrices: Matrix[] = [];\n            const worldMatrix = mesh.computeWorldMatrix(true);\n\n            if (mesh.hasThinInstances) {\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\n                for (let instanceIndex = 0; instanceIndex < thinMatrices.length; instanceIndex++) {\n                    const tmpMatrix = new Matrix();\n                    const thinMatrix = thinMatrices[instanceIndex];\n                    thinMatrix.multiplyToRef(worldMatrix, tmpMatrix);\n                    worldMatrices.push(tmpMatrix);\n                }\n            } else {\n                worldMatrices.push(worldMatrix);\n            }\n\n            const transformed = Vector3.Zero();\n            const position = Vector3.Zero();\n\n            for (let matrixIndex = 0; matrixIndex < worldMatrices.length; matrixIndex++) {\n                const wm = worldMatrices[matrixIndex];\n                for (tri = 0; tri < meshIndices.length; tri++) {\n                    indices.push(meshIndices[tri] + offset);\n                }\n\n                for (pt = 0; pt < meshPositions.length; pt += 3) {\n                    Vector3.FromArrayToRef(meshPositions, pt, position);\n                    Vector3.TransformCoordinatesToRef(position, wm, transformed);\n                    positions.push(transformed.x, transformed.y, transformed.z);\n                }\n\n                offset += meshPositions.length / 3;\n            }\n        }\n    }\n    return [Float32Array.from(positions), Uint32Array.from(indices)];\n}\n\n/**\n * Reverses the order of vertices in each triangle (3 indices per face) to ensure\n * that the winding order is consistent with the Recast Navigation requirements.\n * This is necessary because Recast Navigation expects the indices to be in a specific winding order.\n * @param meshOrIndices The mesh from which to extract indices or the indices themselves.\n * @returns Array of indices with reversed winding order.\n */\nexport function GetReversedIndices(\n    meshOrIndices: Mesh | Uint32Array | number[]\n): Uint32Array<ArrayBufferLike> | number[] | Int32Array<ArrayBufferLike> | Uint16Array<ArrayBufferLike> | null {\n    const indices = meshOrIndices instanceof Mesh ? meshOrIndices.getIndices(false, true) : meshOrIndices;\n\n    if (indices) {\n        for (let i = 0; i < indices.length; i += 3) {\n            // Swap the second and third index to reverse the winding order\n            [indices[i + 1], indices[i + 2]] = [indices[i + 2], indices[i + 1]];\n        }\n    }\n\n    return indices;\n}\n","import type { NavMesh } from \"@recast-navigation/core\";\n\nimport type { Scene } from \"core/scene\";\nimport type { Node } from \"core/node\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\n\nimport { GetReversedIndices } from \"../common/getters\";\nimport { GetRecast } from \"../factory/common\";\n\n/**\n * Creates a debug mesh for visualizing a NavMesh in the scene.\n * @param navMesh The NavMesh to visualize.\n * @param scene The scene in which to create the debug mesh.\n * @param parent Optional parent node for the debug mesh.\n * @param flags Poly flags to filter by, defaults to undefined to include all polys\n * @returns The created debug mesh.\n */\nexport function CreateDebugNavMesh(navMesh: NavMesh, scene: Scene, parent?: Node, flags?: number) {\n    const [positions, indices] = GetRecast().getNavMeshPositionsAndIndices(navMesh, flags);\n\n    const mesh = new Mesh(\"NavMeshDebug\", scene);\n    const vertexData = new VertexData();\n\n    vertexData.indices = GetReversedIndices(indices);\n    vertexData.positions = positions;\n    vertexData.applyToMesh(mesh, false);\n\n    parent && (mesh.parent = parent);\n\n    return mesh;\n}\n","import type { SoloNavMeshGeneratorConfig, TileCacheGeneratorConfig, TiledNavMeshGeneratorConfig } from \"@recast-navigation/generators\";\n\nimport { Logger } from \"core/Misc/logger\";\nimport type { Mesh } from \"core/Meshes/mesh\";\n\nimport type { INavMeshParametersV2 } from \"../types\";\nimport { GetPositionsAndIndices } from \"../common/getters\";\nimport { CreateSoloNavMeshConfig, CreateTileCacheNavMeshConfig, CreateTiledNavMeshConfig } from \"../common/config\";\nimport { GetRecast } from \"../factory/common\";\n\n/**\n * Builds a NavMesh and NavMeshQuery from meshes using provided parameters.\n * @param meshes The array of meshes used to create the NavMesh.\n * @param parameters The parameters used to configure the NavMesh generation.\n * @returns An object containing the NavMesh and NavMeshQuery.\n * @remarks This function generates a NavMesh based on the provided meshes and parameters.\n * It supports different configurations such as solo, tiled, and tile cache nav meshes.\n * If you need obstacles, ensure that `maxObstacles` is set to a value greater than 0.\n * Recommended values for `tileSize` are between 32 and 64 when using obstacles/tile cache.\n * If you need a tiled nav mesh, ensure that `tileSize` is set to a value greater than 0.\n * @throws Error if the NavMesh data is invalid or cannot be deserialized.\n */\nexport function GenerateNavMesh(meshes: Array<Mesh>, parameters: INavMeshParametersV2) {\n    const recast = GetRecast();\n\n    if (meshes.length === 0) {\n        throw new Error(\"At least one mesh is needed to create the nav mesh.\");\n    }\n\n    const [positions, indices] = GetPositionsAndIndices(meshes, { doNotReverseIndices: parameters.doNotReverseIndices });\n    if (!positions || !indices) {\n        throw new Error(\"Unable to get nav mesh. No vertices or indices.\");\n    }\n\n    // Decide on the type of nav mesh to generate based on parameters\n    // If tileSize is set, we will generate a tiled nav mesh\n    // If maxObstacles is set, we will generate a tile cache nav mesh\n    // Otherwise, we will generate a solo nav mesh\n    // Note: tileSize is only used for tiled nav meshes, not tile cache nav meshes\n    // If both tileSize and maxObstacles are set, we will generate a tile cache\n    const tileSize = parameters.tileSize ?? 0;\n    const needsTileCache = (parameters.maxObstacles ?? 0) > 0;\n    const needsTiledNavMesh = tileSize > 0;\n    if (needsTileCache) {\n        if (tileSize < 32 || tileSize > 64) {\n            Logger.Warn(\"NavigationPlugin: Tile cache is enabled. Recommended tileSize is 32 to 64. Other values may lead to unexpected behavior.\");\n        }\n    }\n\n    // Create the appropriate configuration based on the parameters\n    const config = needsTileCache ? CreateTileCacheNavMeshConfig(parameters) : needsTiledNavMesh ? CreateTiledNavMeshConfig(parameters) : CreateSoloNavMeshConfig(parameters);\n    const result = needsTileCache\n        ? recast.generateTileCache(positions, indices, config as TileCacheGeneratorConfig, parameters.keepIntermediates)\n        : needsTiledNavMesh\n          ? recast.generateTiledNavMesh(positions, indices, config as TiledNavMeshGeneratorConfig, parameters.keepIntermediates)\n          : recast.generateSoloNavMesh(positions, indices, config as SoloNavMeshGeneratorConfig, parameters.keepIntermediates);\n\n    if (!result.success) {\n        throw new Error(`Unable to generateSoloNavMesh: ${result.error}`);\n    }\n\n    return {\n        navMesh: result.navMesh,\n        intermediates: result.intermediates,\n        navMeshQuery: new recast.NavMeshQuery(result.navMesh),\n        tileCache: \"tileCache\" in result ? result.tileCache : undefined,\n    };\n}\n","import type { Mesh } from \"core/Meshes/mesh\";\n\nimport type { RecastNavigationJSPluginV2 } from \"../plugin/RecastNavigationJSPlugin\";\nimport type { INavMeshParametersV2 } from \"../types\";\nimport { GenerateNavMesh } from \"./generator.single-thread\";\n\n/**\n * Injects the navigation mesh generation methods into the navigation plugin.\n * @param navigationPlugin The navigation plugin to inject the methods into.\n */\nexport function InjectGenerators(navigationPlugin: RecastNavigationJSPluginV2) {\n    navigationPlugin.createNavMeshImpl = (meshes: Mesh[], parameters: INavMeshParametersV2) => {\n        return GenerateNavMesh(meshes, parameters);\n    };\n\n    navigationPlugin.createNavMeshAsyncImpl = async (meshes: Mesh[], parameters: INavMeshParametersV2) => {\n        return await new Promise((resolve) => {\n            resolve(GenerateNavMesh(meshes, parameters));\n        });\n    };\n}\n","import type { TileCacheMeshProcess, NavMesh, QueryFilter, TileCache, NavMeshQuery } from \"@recast-navigation/core\";\n\nimport type { ICrowd, INavigationEnginePlugin, IObstacle } from \"core/Navigation/INavigationEngine\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { Mesh } from \"core/Meshes/mesh\";\nimport type { Scene } from \"core/scene\";\nimport { TmpVectors, Vector3 } from \"core/Maths/math\";\nimport type { IVector3Like } from \"core/Maths/math.like\";\nimport type { Nullable } from \"core/types\";\n\nimport type { CreateNavMeshResult, GeneratorIntermediates, INavMeshParametersV2, RecastInjection } from \"../types\";\nimport { RecastJSCrowd } from \"./RecastJSCrowd\";\nimport { ConvertNavPathPoints } from \"../common/convert\";\nimport { ComputeSmoothPath } from \"../common/smooth-path\";\nimport { CreateDebugNavMesh } from \"../debug/simple-debug\";\nimport { GetRecast } from \"../factory/common\";\nimport { InjectGenerators } from \"../generator/injection\";\nimport { DefaultMaxObstacles } from \"../common/config\";\nimport { CreateDefaultTileCacheMeshProcess, WaitForFullTileCacheUpdate } from \"../common/tile-cache\";\n\n/**\n * Navigation plugin for Babylon.js. It is a simple wrapper around the recast-navigation-js library. Not all features are implemented.\n * @remarks This plugin provides navigation mesh generation and pathfinding capabilities using the recast-navigation-js library\n * @remarks It supports both single-threaded and multi-threaded generation of navigation meshes.\n * @remarks The plugin can be used to create navigation meshes from meshes in a scene, compute paths, and manage crowd agents, etc.\n * @remarks It also provides methods for creating obstacles and querying the navigation mesh.\n * @see https://github.com/isaac-mason/recast-navigation-js\n */\nexport class RecastNavigationJSPluginV2 implements INavigationEnginePlugin {\n    /**\n     *  Creates a navigation mesh - will be injected by the factory\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @returns the created navmesh and navmesh query\n     */\n    createNavMeshImpl: (meshes: Array<Mesh>, parameters: INavMeshParametersV2) => CreateNavMeshResult;\n\n    /**\n     * Creates a navigation mesh - will be injected by the factory\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @returns the created navmesh and navmesh query\n     */\n    createNavMeshAsyncImpl: (meshes: Array<Mesh>, parameters: INavMeshParametersV2) => Promise<CreateNavMeshResult>;\n\n    /**\n     * recast-navigation-js injection\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public bjsRECAST: RecastInjection;\n\n    /**\n     * plugin name\n     */\n    public name: string = \"RecastNavigationJSPlugin\";\n\n    /**\n     * the navmesh created\n     */\n    public navMesh?: NavMesh;\n\n    /**\n     * The navmesh query created from the navmesh\n     * @remarks This is used to query the navmesh for pathfinding and other navigation tasks\n     */\n    public get navMeshQuery(): NavMeshQuery {\n        return this._navMeshQuery;\n    }\n\n    private _navMeshQuery!: NavMeshQuery;\n\n    /**\n     * Intermediates generated during the navmesh creation\n     * @remarks This is used for debugging and visualization purposes.\n     * @remarks You have access to vertices, indices and vertex colors to visusalize the navmesh creation process.\n     * @remarks This is only available if the `keepIntermediates` parameter is set\n     * @remarks to true during navmesh generation.\n     */\n    private _intermediates?: GeneratorIntermediates;\n\n    /**\n     * Gets the intermediates generated during the navmesh creation\n     * @returns The generator intermediates, or undefined if not available\n     */\n    public get intermediates(): GeneratorIntermediates | undefined {\n        return this._intermediates;\n    }\n\n    /**\n     * Tile cache used for tiled navigation meshes\n     * @remarks This is used to store and manage tiles of the navigation mesh for efficient path and when obstacles are used.\n     */\n    private _tileCache?: TileCache;\n\n    /**\n     * Gets the tile cache used for tiled navigation meshes\n     * @returns The tile cache instance, or undefined if not available\n     */\n    public get tileCache(): TileCache | undefined {\n        return this._tileCache;\n    }\n\n    // Crowd specific properties\n    private _maximumSubStepCount: number = 10;\n    private _timeStep: number = 1 / 60;\n    private _timeFactor: number = 1;\n\n    private _crowd?: ICrowd;\n\n    /**\n     * Creates a RecastNavigationJSPluginV2 instance\n     * @param recastInjection The recast-navigation-js injection containing core and generators\n     */\n    public constructor(recastInjection?: RecastInjection) {\n        if (!recastInjection) {\n            recastInjection = GetRecast();\n            InjectGenerators(this);\n        }\n\n        this.bjsRECAST = recastInjection;\n\n        if (!this.isSupported()) {\n            Logger.Error(\"RecastJS is not available. Please make sure you included the js file.\");\n            return;\n        }\n        this.setTimeStep();\n    }\n\n    /**\n     * Set the time step of the navigation tick update.\n     * Default is 1/60.\n     * A value of 0 will disable fixed time update\n     * @param newTimeStep the new timestep to apply to this world.\n     */\n    public setTimeStep(newTimeStep: number = 1 / 60): void {\n        this._timeStep = newTimeStep;\n    }\n\n    /**\n     * Get the time step of the navigation tick update.\n     * @returns the current time step\n     */\n    public getTimeStep(): number {\n        return this._timeStep;\n    }\n\n    /**\n     * If delta time in navigation tick update is greater than the time step\n     * a number of sub iterations are done. If more iterations are need to reach deltatime\n     * they will be discarded.\n     * A value of 0 will set to no maximum and update will use as many substeps as needed\n     * @param newStepCount the maximum number of iterations\n     */\n    public setMaximumSubStepCount(newStepCount: number = 10): void {\n        this._maximumSubStepCount = newStepCount;\n    }\n\n    /**\n     * Get the maximum number of iterations per navigation tick update\n     * @returns the maximum number of iterations\n     */\n    public getMaximumSubStepCount(): number {\n        return this._maximumSubStepCount;\n    }\n\n    /**\n     * Time factor applied when updating crowd agents (default 1). A value of 0 will pause crowd updates.\n     * @param value the time factor applied at update\n     */\n    public set timeFactor(value: number) {\n        this._timeFactor = Math.max(value, 0);\n    }\n\n    /**\n     * Get the time factor used for crowd agent update\n     * @returns the time factor\n     */\n    public get timeFactor(): number {\n        return this._timeFactor;\n    }\n\n    /**\n     * Creates a navigation mesh - will be injected by the factory\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @returns the created navmesh and navmesh query\n     * @throws Error if the function is not injected yet or if the navmesh is not created\n     */\n    public createNavMesh(meshes: Array<Mesh>, parameters: INavMeshParametersV2): CreateNavMeshResult {\n        if (!this.createNavMeshImpl) {\n            throw new Error(\"Function not injected yet. Use the factory to create the plugin.\");\n        }\n\n        this._preprocessParameters(parameters);\n\n        const result = this.createNavMeshImpl(meshes, parameters);\n        return this._processNavMeshResult(result);\n    }\n\n    /**\n     * Creates a navigation mesh asynchronously - will be injected by the factory\n     * @param meshes array of all the geometry used to compute the navigation mesh\n     * @param parameters bunch of parameters used to filter geometry\n     * @returns the created navmesh and navmesh query\n     * @throws Error if the function is not injected yet or if the navmesh is not created\n     */\n    public async createNavMeshAsync(meshes: Array<Mesh>, parameters: INavMeshParametersV2): Promise<CreateNavMeshResult> {\n        if (!this.createNavMeshAsyncImpl) {\n            throw new Error(\"Function not injected yet. Use the factory to create the plugin.\");\n        }\n\n        this._preprocessParameters(parameters);\n\n        const result = await this.createNavMeshAsyncImpl(meshes, parameters);\n        return this._processNavMeshResult(result);\n    }\n\n    /**\n     * Create a navigation mesh debug mesh\n     * @param scene is where the mesh will be added\n     * @returns debug display mesh\n     */\n    public createDebugNavMesh(scene: Scene): Mesh {\n        if (!this.navMesh) {\n            throw new Error(\"There is no navMesh generated.\");\n        }\n\n        if (this.navMesh && this._tileCache) {\n            WaitForFullTileCacheUpdate(this.navMesh, this._tileCache);\n        }\n\n        return CreateDebugNavMesh(this.navMesh, scene);\n    }\n\n    /**\n     * Get a navigation mesh constrained position, closest to the parameter position\n     * @param position world position\n     * @returns the closest point to position constrained by the navigation mesh\n     */\n    public getClosestPoint(\n        position: IVector3Like,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n        }\n    ): Vector3 {\n        const ret = this._navMeshQuery.findClosestPoint(position, options);\n        const pr = new Vector3(ret.point.x, ret.point.y, ret.point.z);\n        return pr;\n    }\n\n    /**\n     * Get a navigation mesh constrained position, closest to the parameter position\n     * @param position world position\n     * @param result output the closest point to position constrained by the navigation mesh\n     */\n    public getClosestPointToRef(\n        position: IVector3Like,\n        result: Vector3,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n        }\n    ): void {\n        const ret = this._navMeshQuery.findClosestPoint(position, options);\n        result.set(ret.point.x, ret.point.y, ret.point.z);\n    }\n\n    /**\n     * Get a navigation mesh constrained position, within a particular radius\n     * @param position world position\n     * @param maxRadius the maximum distance to the constrained world position\n     * @returns the closest point to position constrained by the navigation mesh\n     */\n    public getRandomPointAround(\n        position: IVector3Like,\n        maxRadius: number,\n        options?: {\n            startRef?: number;\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n        }\n    ): Vector3 {\n        const ret = this._navMeshQuery.findRandomPointAroundCircle(position, maxRadius, options);\n        const pr = new Vector3(ret.randomPoint.x, ret.randomPoint.y, ret.randomPoint.z);\n        return pr;\n    }\n\n    /**\n     * Get a navigation mesh constrained position, within a particular radius\n     * @param position world position\n     * @param maxRadius the maximum distance to the constrained world position\n     * @param result output the closest point to position constrained by the navigation mesh\n     */\n    public getRandomPointAroundToRef(\n        position: IVector3Like,\n        maxRadius: number,\n        result: Vector3,\n        options?: {\n            startRef?: number;\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n        }\n    ): void {\n        const ret = this._navMeshQuery.findRandomPointAroundCircle(position, maxRadius, options);\n        result.set(ret.randomPoint.x, ret.randomPoint.y, ret.randomPoint.z);\n    }\n\n    /**\n     * Compute the final position from a segment made of destination-position\n     * @param position position to start from\n     * @param destination position to go to\n     * @param startRef the reference id of the start polygon\n     * @param options options for the function\n     * @returns the resulting point along the navmesh\n     */\n    public moveAlong(\n        position: IVector3Like,\n        destination: IVector3Like,\n        startRef = 0,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * The maximum number of polygons the output visited array can hold.\n             */\n            maxVisitedSize?: number;\n        }\n    ): Vector3 {\n        const ret = this._navMeshQuery.moveAlongSurface(startRef, position, destination, options);\n        const pr = new Vector3(ret.resultPosition.x, ret.resultPosition.y, ret.resultPosition.z);\n        return pr;\n    }\n\n    /**\n     * Compute the final position from a segment made of destination-position\n     * @param position world position\n     * @param destination world position\n     * @param result output the resulting point along the navmesh\n     * @param startRef the reference id of the start polygon.\n     * @param options options for the function\n     */\n    public moveAlongToRef(\n        position: IVector3Like,\n        destination: IVector3Like,\n        result: Vector3,\n        startRef = 0,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            maxVisitedSize?: number;\n        }\n    ): void {\n        const ret = this._navMeshQuery.moveAlongSurface(startRef, position, destination, options);\n        result.set(ret.resultPosition.x, ret.resultPosition.y, ret.resultPosition.z);\n    }\n\n    /**\n     * Compute a navigation path from start to end. Returns an empty array if no path can be computed\n     * Path is straight.\n     * @param start world position\n     * @param end world position\n     * @param options options for the function\n     * @returns array containing world position composing the path\n     */\n    public computePath(\n        start: IVector3Like,\n        end: IVector3Like,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n            maxPathPolys?: number;\n            maxStraightPathPoints?: number;\n        }\n    ): Vector3[] {\n        return ConvertNavPathPoints(this._navMeshQuery.computePath(start, end, options));\n    }\n\n    /**\n     * Creates a navigation mesh - will be injected by the factory\n     * @param start the start position of the navmesh\n     * @param end the end position of the navmesh\n     * @param options options to configure the path computation\n     * @returns array containing world position composing the path\n     */\n    public computePathSmooth(\n        start: Vector3,\n        end: Vector3,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n            maxPathPolys?: number;\n            maxSmoothPathPoints?: number;\n            stepSize?: number;\n            slop?: number;\n        }\n    ): Vector3[] {\n        if (!this.navMesh) {\n            Logger.Error(\"No navmesh available. Cannot compute smooth path.\");\n            return [];\n        }\n        return ComputeSmoothPath(this.navMesh, this._navMeshQuery, start, end, options);\n    }\n\n    /**\n     * Create a new Crowd so you can add agents\n     * @param maxAgents the maximum agent count in the crowd\n     * @param maxAgentRadius the maximum radius an agent can have\n     * @param scene to attach the crowd to\n     * @returns the crowd you can add agents to\n     */\n    public createCrowd(maxAgents: number, maxAgentRadius: number, scene: Scene): ICrowd {\n        const crowd = new RecastJSCrowd(this, maxAgents, maxAgentRadius, scene);\n        this._crowd = crowd;\n        return crowd;\n    }\n\n    /**\n     * Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround, ...)\n     * The queries will try to find a solution within those bounds\n     * default is (1,1,1)\n     * @param extent x,y,z value that define the extent around the queries point of reference\n     */\n    public setDefaultQueryExtent(extent: IVector3Like): void {\n        this._navMeshQuery.defaultQueryHalfExtents = extent;\n    }\n\n    /**\n     * Get the Bounding box extent specified by setDefaultQueryExtent\n     * @returns the box extent values\n     */\n    public getDefaultQueryExtent(): Vector3 {\n        return new Vector3(this._navMeshQuery.defaultQueryHalfExtents.x, this._navMeshQuery.defaultQueryHalfExtents.y, this._navMeshQuery.defaultQueryHalfExtents.z);\n    }\n\n    /**\n     * Get the Bounding box extent result specified by setDefaultQueryExtent\n     * @param result output the box extent values\n     */\n    public getDefaultQueryExtentToRef(result: Vector3): void {\n        result.set(this._navMeshQuery.defaultQueryHalfExtents.x, this._navMeshQuery.defaultQueryHalfExtents.y, this._navMeshQuery.defaultQueryHalfExtents.z);\n    }\n\n    /**\n     * build the navmesh from a previously saved state using getNavmeshData\n     * @param data the Uint8Array returned by getNavmeshData\n     */\n    public buildFromNavmeshData(data: Uint8Array): void {\n        const result = this.bjsRECAST.importNavMesh(data);\n        this.navMesh = result.navMesh;\n        this._navMeshQuery = new this.bjsRECAST.NavMeshQuery(this.navMesh);\n    }\n\n    /**\n     * returns the navmesh data that can be used later. The navmesh must be built before retrieving the data\n     * @returns data the Uint8Array that can be saved and reused\n     */\n    public getNavmeshData(): Uint8Array {\n        if (!this.navMesh) {\n            throw new Error(\"There is no NavMesh generated.\");\n        }\n        return this.bjsRECAST.exportNavMesh(this.navMesh);\n    }\n\n    /**\n     * build the tile cache from a previously saved state using getTileCacheData\n     * @param tileCacheData the data returned by getTileCacheData\n     * @param tileCacheMeshProcess optional process to apply to each tile created\n     */\n    public buildFromTileCacheData(tileCacheData: Uint8Array, tileCacheMeshProcess?: TileCacheMeshProcess): void {\n        const result = this.bjsRECAST.importTileCache(tileCacheData, tileCacheMeshProcess ?? CreateDefaultTileCacheMeshProcess([]));\n        this.navMesh = result.navMesh;\n        this._tileCache = result.tileCache;\n        this._navMeshQuery = new this.bjsRECAST.NavMeshQuery(this.navMesh);\n    }\n\n    /**\n     * returns the tile cache data that can be used later. The tile cache must be built before retrieving the data\n     * @returns the tile cache data that can be used later. The tile cache must be built before retrieving the data\n     * @throws Error if there is no TileCache generated\n     * @remarks The returned data can be used to rebuild the tile cache later using buildFromTileCacheData\n     */\n    public getTileCacheData(): Uint8Array {\n        if (!this.navMesh || !this._tileCache) {\n            throw new Error(\"There is no TileCache generated.\");\n        }\n        return this.bjsRECAST.exportTileCache(this.navMesh, this._tileCache);\n    }\n\n    /**\n     * Disposes\n     */\n    public dispose() {\n        this._crowd?.dispose();\n        this.navMesh?.destroy();\n        this._navMeshQuery?.destroy();\n        this._tileCache?.destroy();\n    }\n\n    /**\n     * Creates a cylinder obstacle and add it to the navigation\n     * @param position world position\n     * @param radius cylinder radius\n     * @param height cylinder height\n     * @param doNotWaitForCacheUpdate if true the function will not wait for the tile cache to be fully updated before returning\n     * @returns the obstacle freshly created\n     */\n    public addCylinderObstacle(position: IVector3Like, radius: number, height: number, doNotWaitForCacheUpdate = false): Nullable<IObstacle> {\n        const obstacleResult = this._tileCache?.addCylinderObstacle(position, radius, height);\n        if (!obstacleResult?.success) {\n            return null;\n        }\n\n        if (!doNotWaitForCacheUpdate && this.navMesh && this._tileCache) {\n            WaitForFullTileCacheUpdate(this.navMesh, this._tileCache);\n        }\n\n        return (obstacleResult.obstacle as IObstacle) ?? null;\n    }\n\n    /**\n     * Creates an oriented box obstacle and add it to the navigation\n     * @param position world position\n     * @param extent box size\n     * @param angle angle in radians of the box orientation on Y axis\n     * @param doNotWaitForCacheUpdate if true the function will not wait for the tile cache to be fully updated before returning\n     * @returns the obstacle freshly created\n     */\n    public addBoxObstacle(position: IVector3Like, extent: IVector3Like, angle: number, doNotWaitForCacheUpdate = false): Nullable<IObstacle> {\n        const obstacleResult = this._tileCache?.addBoxObstacle(position, extent, angle);\n        if (!obstacleResult?.success) {\n            return null;\n        }\n\n        if (!doNotWaitForCacheUpdate && this.navMesh && this._tileCache) {\n            WaitForFullTileCacheUpdate(this.navMesh, this._tileCache);\n        }\n\n        return (obstacleResult.obstacle as IObstacle) ?? null;\n    }\n\n    /**\n     * Removes an obstacle created by addCylinderObstacle or addBoxObstacle\n     * @param obstacle obstacle to remove from the navigation\n     * @param doNotWaitForCacheUpdate if true the function will not wait for the tile cache to be fully updated before returning\n     *\n     */\n    public removeObstacle(obstacle: IObstacle, doNotWaitForCacheUpdate = false): void {\n        this._tileCache?.removeObstacle(obstacle);\n\n        if (!doNotWaitForCacheUpdate && this.navMesh && this._tileCache) {\n            WaitForFullTileCacheUpdate(this.navMesh, this._tileCache);\n        }\n    }\n\n    /**\n     * If this plugin is supported\n     * @returns true if plugin is supported\n     */\n    public isSupported(): boolean {\n        return !!this.bjsRECAST;\n    }\n\n    /**\n     * Returns the seed used for randomized functions like `getRandomPointAround`\n     * @returns seed number\n     */\n    public getRandomSeed(): number {\n        return this.bjsRECAST.getRandomSeed();\n    }\n\n    /**\n     * Set the seed used for randomized functions like `getRandomPointAround`\n     * @param seed number used as seed for random functions\n     */\n    public setRandomSeed(seed: number): void {\n        this.bjsRECAST.setRandomSeed(seed);\n    }\n\n    // New funccntions beyond the INavigationEnginePlugin interface\n\n    /**\n     * Perform a raycast on the navmesh\n     * @param start start position\n     * @param end end position\n     * @returns if a direct path exists between start and end, and the hit point if any\n     */\n    public raycast(start: IVector3Like, end: IVector3Like) {\n        const nearestStartPoly = this._navMeshQuery.findNearestPoly(start);\n        const raycastResult = this._navMeshQuery.raycast(nearestStartPoly.nearestRef, start, end);\n\n        const hit = 0 < raycastResult.t && raycastResult.t < 1.0;\n        if (!hit) {\n            return {\n                hit: false,\n            };\n        } else {\n            TmpVectors.Vector3[0].set(start.x, start.y, start.z);\n            TmpVectors.Vector3[1].set(end.x, end.y, end.z);\n\n            const distanceToHitBorder = Vector3.Distance(TmpVectors.Vector3[0], TmpVectors.Vector3[1]) * (raycastResult?.t ?? 0);\n            const direction = TmpVectors.Vector3[1].subtract(TmpVectors.Vector3[0]).normalize();\n            const hitPoint = TmpVectors.Vector3[0].add(direction.multiplyByFloats(distanceToHitBorder, distanceToHitBorder, distanceToHitBorder));\n\n            return {\n                hit: true,\n                hitPoint,\n            };\n        }\n    }\n\n    /**\n     * Compute the final position from a segment made of destination-position, and return the height of the polygon\n     * This is a more sophisiticated version of moveAlong that will use the height of the polygon at the end position\n     * @param position world position to start from\n     * @param velocity wvelocity of the movement\n     * @param options options for the function\n     * @returns the resulting point along the navmesh, the polygon reference id and the height of the polygon\n     */\n    public moveAlongWithVelocity(\n        position: IVector3Like,\n        velocity: IVector3Like,\n        options?: {\n            /**\n             * The polygon filter to apply to the query.\n             */\n            filter?: QueryFilter;\n            /**\n             * Half extents for the search box\n             */\n            halfExtents?: IVector3Like;\n            /**\n             * The maximum number of polygons the output visited array can hold.\n             */\n            maxVisitedSize?: number;\n        }\n    ) {\n        const { point, polyRef } = this._navMeshQuery.findClosestPoint(\n            {\n                x: position.x,\n                y: position.y,\n                z: position.z,\n            },\n            options\n        );\n\n        const { resultPosition } = this._navMeshQuery.moveAlongSurface(\n            polyRef,\n            point,\n            {\n                x: point.x + velocity.x,\n                y: point.y + velocity.y,\n                z: point.z + velocity.z,\n            },\n            options\n        );\n        const polyHeightResult = this._navMeshQuery.getPolyHeight(polyRef, resultPosition);\n\n        return {\n            position: { x: resultPosition.x, y: polyHeightResult.success ? polyHeightResult.height : resultPosition.y, z: resultPosition.z },\n            polyRef: polyRef,\n            height: polyHeightResult.height,\n        };\n    }\n\n    /**\n     * Handles common post-processing and validation of navmesh creation results\n     * @param result The partial result from navmesh creation\n     * @returns The validated and complete CreateNavMeshresult\n     */\n    private _processNavMeshResult(result: Nullable<Partial<CreateNavMeshResult>>): CreateNavMeshResult {\n        if (!result?.navMesh || !result?.navMeshQuery) {\n            throw new Error(\"Unable to create navmesh. No navMesh or navMeshQuery returned.\");\n        }\n\n        this.navMesh = result.navMesh;\n        this._navMeshQuery = result.navMeshQuery;\n        this._intermediates = result.intermediates;\n        this._tileCache = result.tileCache;\n\n        return {\n            navMesh: result.navMesh,\n            navMeshQuery: result.navMeshQuery,\n            intermediates: result.intermediates,\n            tileCache: result.tileCache, // tileCache is optional\n        };\n    }\n\n    private _preprocessParameters(parameters: INavMeshParametersV2) {\n        // if maxObstacles is not defined, set it to a default value and set a default tile size if not defined\n        if (parameters.maxObstacles === undefined) {\n            parameters.tileSize = parameters.tileSize ?? 32; // maxObstacles will trigger tile cache creation, so we need a tile size\n            parameters.maxObstacles = DefaultMaxObstacles;\n        }\n\n        parameters.walkableSlopeAngle = Math.max(0.1, parameters.walkableSlopeAngle ?? 60);\n    }\n}\n","import { InjectGenerators } from \"../generator/injection\";\nimport { RecastNavigationJSPluginV2 } from \"../plugin/RecastNavigationJSPlugin\";\nimport type { RecastInjection } from \"../types\";\nimport { GetRecast, InitRecast } from \"./common\";\n\n/**\n * Creates a navigation plugin for the given scene.\n * @returns A promise that resolves to the created navigation plugin.\n * @param options Optional configuration. options.version: The version of Recast to use. options.instance: A custom Recast instance to inject instead of loading one.\n * @remarks This function initializes the Recast module and sets up the navigation plugin.\n */\nexport async function CreateNavigationPluginAsync(options?: { version?: string; instance?: RecastInjection }) {\n    await InitRecast(options);\n\n    const navigationPlugin = new RecastNavigationJSPluginV2(GetRecast());\n    InjectGenerators(navigationPlugin);\n\n    return navigationPlugin;\n}\n","import type { IVector3Like } from \"core/Maths/math.like\";\nimport { Vector3 } from \"core/Maths/math.vector\";\n\n/**\n * Utility function based on Chaikin's alogrithm for navigation path smoothing and segment generation.\n * @param points Array of points to be smoothed, where each point is an object with x, y, and z properties.\n * @param iterations Number of smoothing iterations to apply. Default 1.\n * @returns A new array of smoothed points after applying the Chaikin's algorithm.\n */\nexport function GetChaikinSmoothPath(points: IVector3Like[], iterations = 1) {\n    for (let i = 0; i < iterations; i++) {\n        const smoothed = [];\n        for (let j = 0; j < points.length - 1; j++) {\n            const p0 = points[j];\n            const p1 = points[j + 1];\n\n            smoothed.push({\n                x: 0.75 * p0.x + 0.25 * p1.x,\n                y: 0.75 * p0.y + 0.25 * p1.y,\n                z: 0.75 * p0.z + 0.25 * p1.z,\n            });\n\n            smoothed.push({\n                x: 0.25 * p0.x + 0.75 * p1.x,\n                y: 0.25 * p0.y + 0.75 * p1.y,\n                z: 0.25 * p0.z + 0.75 * p1.z,\n            });\n        }\n\n        if (points[0].x === points[points.length - 1].x && points[0].y === points[points.length - 1].y && points[0].z === points[points.length - 1].z) {\n            smoothed.push(smoothed[0]);\n        }\n\n        points = smoothed;\n    }\n    return points;\n}\n\n/**\n *  Generates a series of points that create an L-shaped path between each pair of points in the input navigation segment.\n *  The path consists of a horizontal segment followed by a vertical segment, or vice versa,\n *  depending on the relative distances between the x and z coordinates of the points.\n * @param navSegment An array of Vector3 points representing the navigation segment.\n * @returns An array of Vector3 points representing the L-shaped path.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function GetLShapedPath(navSegment: Vector3[]) {\n    const points = [];\n    for (let j = 0; j < navSegment.length - 1; j++) {\n        const p0 = navSegment[j];\n        const p1 = navSegment[j + 1];\n        const p01 = getLShapedPoint(p0, p1);\n        points.push(p0, new Vector3(p01.x, p1.y, p01.z), p1);\n    }\n    return points;\n}\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getLShapedPoint(pointA: IVector3Like, pointB: IVector3Like) {\n    const { x: x1, z: y1 } = pointA;\n    const { x: x2, z: y2 } = pointB;\n\n    let pointC;\n\n    // Determine turn direction automatically based on the offset\n    if (Math.abs(x2 - x1) >= Math.abs(y2 - y1)) {\n        // Horizontal-then-vertical turn\n        pointC = { x: x2, z: y1 };\n    } else {\n        // Vertical-then-horizontal turn\n        pointC = { x: x1, z: y2 };\n    }\n\n    return pointC;\n}\n","import type { TileCacheMeshProcess } from \"@recast-navigation/core\";\n\nimport { GetRecast } from \"../factory/common\";\n\n/**\n *  Builds a NavMesh and NavMeshQuery from serialized data.\n *  @param data The serialized NavMesh data.\n *  @returns An object containing the NavMesh and NavMeshQuery.\n *  @remarks This function deserializes the NavMesh data and creates a NavMeshQuery\n *  instance for querying the NavMesh.\n *  @throws Error if the NavMesh data is invalid or cannot be deserialized.\n */\nexport function BuildFromNavmeshData(data: Uint8Array) {\n    const recast = GetRecast();\n    const result = recast.importNavMesh(data);\n\n    if (!result.navMesh) {\n        throw new Error(`Unable to deserialize NavMesh.`);\n    }\n\n    return {\n        navMesh: result.navMesh,\n        navMeshQuery: new recast.NavMeshQuery(result.navMesh),\n        tileCache: undefined,\n    };\n}\n\n/**\n * Builds a TileCache and NavMeshQuery from serialized data.\n * @param data The serialized TileCache data.\n * @param tileCacheMeshProcess Optional function to process the TileCache mesh.\n * @returns An object containing the TileCache, NavMesh, and NavMeshQuery.\n */\nexport function BuildFromTileCacheData(data: Uint8Array, tileCacheMeshProcess: TileCacheMeshProcess) {\n    const recast = GetRecast();\n    const result = recast.importTileCache(data, tileCacheMeshProcess);\n\n    if (!result.tileCache) {\n        throw new Error(`Unable to deserialize TileCache.`);\n    }\n\n    return {\n        navMesh: result.navMesh,\n        navMeshQuery: new recast.NavMeshQuery(result.navMesh),\n        tileCache: result.tileCache,\n    };\n}\n","import type {\n    DebugDrawerPrimitive,\n    DebugDrawerPrimitiveType,\n    NavMesh,\n    NavMeshQuery,\n    RecastCompactHeightfield,\n    RecastContourSet,\n    RecastHeightfield,\n    RecastHeightfieldLayer,\n    RecastHeightfieldLayerSet,\n    RecastPolyMesh,\n    RecastPolyMeshDetail,\n    DebugDrawerUtils,\n} from \"@recast-navigation/core\";\n\nimport type { GreasedLineMaterialOptions } from \"core/Materials/GreasedLine/greasedLineMaterialInterfaces\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\nimport { Color3 } from \"core/Maths/math.color\";\nimport { Matrix } from \"core/Maths/math.vector\";\nimport { CreateGreasedLine } from \"core/Meshes/Builders/greasedLineBuilder\";\nimport type { GreasedLineBaseMesh, GreasedLineMeshOptions } from \"core/Meshes/GreasedLine/greasedLineBaseMesh\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\nimport { TransformNode } from \"core/Meshes/transformNode\";\nimport type { Scene } from \"core/scene\";\nimport type { Nullable } from \"core/types\";\nimport { CreateBox } from \"core/Meshes/Builders/boxBuilder\";\nimport { Logger } from \"core/Misc/logger\";\n\nimport type { GeneratorIntermediates } from \"../types\";\nimport { GetRecast } from \"../factory/common\";\n\n// TODO: Enum?\nexport const DebugLayerOption = {\n    HEIGHTFIELD_SOLID: \"heightfield solid\",\n    HEIGHTFIELD_WALKABLE: \"heightfield walkable\",\n    COMPACT_HEIGHTFIELD_SOLID: \"compact heightfield solid\",\n    COMPACT_HEIGHTFIELD_REGIONS: \"compact heightfield regions\",\n    COMPACT_HEIGHTFIELD_DISTANCE: \"compact heightfield distance\",\n    RAW_CONTOURS: \"raw contours\",\n    CONTOURS: \"contours\",\n    POLY_MESH: \"poly mesh\",\n    POLY_MESH_DETAIL: \"poly mesh detail\",\n    NAVMESH: \"navmesh\",\n    NAVMESH_BV_TREE: \"navmesh bv tree\",\n};\n\nexport type DebugLayerOptions = (typeof DebugLayerOption)[keyof typeof DebugLayerOption];\n\n/**\n * NavigationDebugger is a utility class for visualizing navigation meshes and related data in a Babylon.js scene.\n * It provides methods to draw various navigation-related primitives such as points, lines, triangles, and quads.\n * It also supports drawing heightfields, compact heightfields, contours, poly meshes, and nav meshes.\n */\nexport class NavigationDebugger {\n    /**\n     *  The name of the debug mesh used for navigation debugging.\n     *  This is used to group all navigation debug meshes under a single name for easier management\n     */\n    public static NAV_MESH_DEBUG_NAME = \"nav-mesh-debug\";\n\n    /**\n     * The name of the debug mesh used for visualization of the navigation mesh using points.\n     */\n    public static NAV_MESH_DEBUG_NAME_POINTS = \"nav-mesh-debug-points\";\n\n    /**\n     * The name of the debug mesh used for visualization of the navigation mesh using triangles.\n     */\n    public static NAV_MESH_DEBUG_NAME_TRIS = \"nav-mesh-debug-tris\";\n\n    /**\n     * The name of the debug mesh used for visualization of the navigation mesh using quads.\n     */\n    public static NAV_MESH_DEBUG_NAME_QUADS = \"nav-mesh-debug-quads\";\n\n    /**\n     * The name of the debug mesh used for visualization of the navigation mesh using lines.\n     */\n    public static NAV_MESH_DEBUG_NAME_LINES = \"nav-mesh-debug-lines\";\n\n    /**\n     * The material used for rendering triangles in the navigation debug visualization.\n     */\n    public triMaterial: StandardMaterial;\n    /**\n     * The material used for rendering points in the navigation debug visualization.\n     */\n    public pointMaterial: StandardMaterial;\n\n    /**\n     * The list of line materials used in the navigation debug visualization.\n     */\n    public lineMaterials: StandardMaterial[] = [];\n\n    /**\n     * The parent node for the debug drawer.\n     */\n    public debugDrawerParentNode: TransformNode;\n\n    /**\n     * * Gets or sets the primitive types to be drawn by the debug drawer.\n     * * This allows you to control which types of primitives (points, lines, tris, quads) are rendered in the navigation debug visualization.\n     * * The default value is `[\"points\", \"lines\", \"tris\", \"quads\"]`.\n     * * You can modify this property to include or exclude specific primitive types based on your debugging needs.\n     * @returns An array of primitive types that the debug drawer will render.\n     */\n    public get primitiveTypes(): DebugDrawerPrimitiveType[] {\n        return this._primitiveTypes;\n    }\n\n    public set primitiveTypes(value: DebugDrawerPrimitiveType[]) {\n        this._primitiveTypes = value;\n    }\n\n    private _lineMaterialOptions: {\n        greasedLineMaterialOptions: Partial<GreasedLineMaterialOptions>;\n        greasedLineMeshOptions: Partial<GreasedLineMeshOptions>;\n    };\n    private _pointMesh: Mesh;\n    private _debugDrawerUtils: DebugDrawerUtils;\n    private _primitiveTypes: DebugDrawerPrimitiveType[];\n\n    constructor(\n        private _scene: Scene,\n        options?: {\n            parent?: {\n                node?: TransformNode | string;\n            };\n            primitiveTypes?: DebugDrawerPrimitiveType[];\n            materials?: {\n                triMaterial?: StandardMaterial;\n                pointMaterial?: StandardMaterial;\n                lineMaterialOptions: {\n                    greasedLineMaterialOptions: Partial<GreasedLineMaterialOptions>;\n                    greasedLineMeshOptions: Partial<GreasedLineMeshOptions>;\n                };\n            };\n        }\n    ) {\n        this._debugDrawerUtils = new (GetRecast().DebugDrawerUtils)();\n\n        this._primitiveTypes = options?.primitiveTypes ?? [\"points\", \"lines\", \"tris\", \"quads\"];\n\n        this.debugDrawerParentNode =\n            options?.parent?.node instanceof TransformNode ? options.parent.node : new TransformNode((options?.parent?.node as string) ?? \"nav-mesh-debug-parent\", this._scene);\n\n        const materials = options?.materials;\n        if (materials?.triMaterial) {\n            this.triMaterial = materials.triMaterial;\n        } else {\n            this.triMaterial = new StandardMaterial(\"nav-debug-tris-material\");\n            this.triMaterial.backFaceCulling = false;\n            this.triMaterial.specularColor = Color3.Black();\n            this.triMaterial.alpha = 0.5;\n        }\n\n        if (materials?.pointMaterial) {\n            this.pointMaterial = materials.pointMaterial;\n        } else {\n            this.pointMaterial = new StandardMaterial(\"nav-debug-points-material\");\n            this.pointMaterial.backFaceCulling = false;\n            this.pointMaterial.specularColor = Color3.Black();\n        }\n\n        if (materials?.lineMaterialOptions) {\n            this._lineMaterialOptions = materials.lineMaterialOptions;\n        } else {\n            this._lineMaterialOptions = {\n                greasedLineMaterialOptions: {\n                    width: 2,\n                    sizeAttenuation: true,\n                },\n                greasedLineMeshOptions: {},\n            };\n        }\n\n        this._pointMesh = CreateBox(NavigationDebugger.NAV_MESH_DEBUG_NAME_POINTS, { size: 0.02 });\n    }\n\n    /**\n     * Resets the debug drawer by disposing of all child meshes in the debug drawer parent node.\n     * This is useful for clearing the debug visualization before drawing new primitives.\n     */\n    public clear() {\n        for (const child of this.debugDrawerParentNode.getChildMeshes()) {\n            child.dispose();\n        }\n    }\n\n    /**\n     * Disposes of the debug drawer, including all meshes and materials used for rendering.\n     * This method should be called when the debug drawer is no longer needed to free up resources.\n     */\n    public dispose() {\n        this.clear();\n        this._debugDrawerUtils.dispose();\n        this._pointMesh.dispose();\n        this.triMaterial.dispose();\n        this.pointMaterial.dispose();\n    }\n\n    /**\n     * This method iterates through the provided primitives and draws them based on their type.\n     * It supports drawing points, lines, triangles, and quads, depending on the primitive type.\n     * @param primitives An array of debug drawer primitives to be drawn.\n     * @param options Optional parameters to control the drawing behavior, such as whether to join meshes.\n     */\n    public drawPrimitives(primitives: DebugDrawerPrimitive[], options?: { joinMeshes?: boolean }) {\n        let linesInstance = null;\n\n        for (const primitive of primitives) {\n            // draw only the primitives that are in the primitiveTypes array\n            if (!this._primitiveTypes.includes(primitive.type)) {\n                continue;\n            }\n\n            switch (primitive.type) {\n                case \"points\":\n                    this._drawPoints(primitive);\n                    break;\n                case \"lines\": {\n                    const line = this._drawLines(primitive, linesInstance);\n                    if (!linesInstance) {\n                        linesInstance = line;\n                    }\n                    break;\n                }\n                case \"tris\":\n                    this._drawTris(primitive);\n                    break;\n                case \"quads\":\n                    this._drawQuads(primitive);\n                    break;\n            }\n        }\n\n        linesInstance?.updateLazy();\n\n        if (options?.joinMeshes ?? true) {\n            // Join the debug meshes into a single mesh for better performance\n            this._joinDebugMeshes();\n        }\n    }\n\n    /**\n     * Draws a heightfield as solid using the debug drawer utilities.\n     * @param hf The heightfield to draw as solid.\n     */\n    public drawHeightfieldSolid(hf: RecastHeightfield): void {\n        const primitives = this._debugDrawerUtils.drawHeightfieldSolid(hf);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws a heightfield as walkable using the debug drawer utilities.\n     * @param hf The heightfield to draw as walkable.\n     */\n    public drawHeightfieldWalkable(hf: RecastHeightfield): void {\n        const primitives = this._debugDrawerUtils.drawHeightfieldWalkable(hf);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws a compact heightfield as solid using the debug drawer utilities.\n     * @param chf The compact heightfield to draw as solid.\n     */\n    public drawCompactHeightfieldSolid(chf: RecastCompactHeightfield): void {\n        const primitives = this._debugDrawerUtils.drawCompactHeightfieldSolid(chf);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws the regions of a compact heightfield using the debug drawer utilities.\n     * @param chf The compact heightfield to draw regions for.\n     */\n    public drawCompactHeightfieldRegions(chf: RecastCompactHeightfield): void {\n        const primitives = this._debugDrawerUtils.drawCompactHeightfieldRegions(chf);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws the distance field of a compact heightfield using the debug drawer utilities.\n     * @param chf The compact heightfield to draw the distance for.\n     */\n    public drawCompactHeightfieldDistance(chf: RecastCompactHeightfield): void {\n        const primitives = this._debugDrawerUtils.drawCompactHeightfieldDistance(chf);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws a heightfield layer using the debug drawer utilities.\n     * @param layer The heightfield layer to draw.\n     * @param idx The index of the layer to draw.\n     */\n    public drawHeightfieldLayer(layer: RecastHeightfieldLayer, idx: number): void {\n        const primitives = this._debugDrawerUtils.drawHeightfieldLayer(layer, idx);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws the layers of a heightfield using the debug drawer utilities.\n     * @param lset The heightfield layer set containing the layers to draw.\n     */\n    public drawHeightfieldLayers(lset: RecastHeightfieldLayerSet): void {\n        const primitives = this._debugDrawerUtils.drawHeightfieldLayers(lset);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws the region connections of a RecastContourSet using the debug drawer utilities.\n     * @param cset RecastContourSet to draw\n     * @param alpha The alpha value for the drawn contours, default is 1.\n     */\n    public drawRegionConnections(cset: RecastContourSet, alpha: number = 1): void {\n        const primitives = this._debugDrawerUtils.drawRegionConnections(cset, alpha);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws raw contours from a RecastContourSet using the debug drawer utilities.\n     * @param cset RecastContourSet to draw\n     * @param alpha The alpha value for the drawn contours, default is 1.\n     */\n    public drawRawContours(cset: RecastContourSet, alpha: number = 1): void {\n        const primitives = this._debugDrawerUtils.drawRawContours(cset, alpha);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws contours from a RecastContourSet using the debug drawer utilities.\n     * @param cset RecastContourSet to draw\n     * @param alpha The alpha value for the drawn contours, default is 1.\n     */\n    public drawContours(cset: RecastContourSet, alpha: number = 1): void {\n        const primitives = this._debugDrawerUtils.drawContours(cset, alpha);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws a poly mesh using the debug drawer utilities.\n     * @param mesh RecastPolyMesh to draw\n     */\n    public drawPolyMesh(mesh: RecastPolyMesh): void {\n        const primitives = this._debugDrawerUtils.drawPolyMesh(mesh);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws a poly mesh detail using the debug drawer utilities.\n     * @param dmesh RecastPolyMeshDetail to draw\n     */\n    public drawPolyMeshDetail(dmesh: RecastPolyMeshDetail): void {\n        const primitives = this._debugDrawerUtils.drawPolyMeshDetail(dmesh);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws a NavMesh using the debug drawer utilities.\n     * @param mesh NavMesh to draw\n     * @param flags Flags to control the drawing behavior, default is 0.\n     */\n    public drawNavMesh(mesh: NavMesh, flags: number = 0): void {\n        const primitives = this._debugDrawerUtils.drawNavMesh(mesh, flags);\n        this.drawPrimitives(primitives);\n    }\n\n    // todo:\n    // - drawTileCacheLayerAreas\n    // - drawTileCacheLayerRegions\n    // - drawTileCacheContours\n    // - drawTileCachePolyMesh\n\n    /**\n     * Draws a NavMesh with closed list using the debug drawer utilities.\n     * @param mesh NavMesh to draw\n     * @param query NavMeshQuery to use for drawing the closed list.\n     * @param flags Flags to control the drawing behavior, default is 0.\n     */\n    public drawNavMeshWithClosedList(mesh: NavMesh, query: NavMeshQuery, flags: number = 0): void {\n        const primitives = this._debugDrawerUtils.drawNavMeshWithClosedList(mesh, query, flags);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws the nodes of a NavMesh using the debug drawer utilities.\n     * @param query NavMeshQuery to use for drawing the nodes.\n     */\n    public drawNavMeshNodes(query: NavMeshQuery): void {\n        const primitives = this._debugDrawerUtils.drawNavMeshNodes(query);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws the bounding volume tree of a NavMesh using the debug drawer utilities.\n     * @param mesh NavMesh to draw the bounding volume tree for.\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public drawNavMeshBVTree(mesh: NavMesh): void {\n        const primitives = this._debugDrawerUtils.drawNavMeshBVTree(mesh);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws the portals of a NavMesh using the debug drawer utilities.\n     * @param mesh NavMesh to draw the portals for.\n     */\n    public drawNavMeshPortals(mesh: NavMesh): void {\n        const primitives = this._debugDrawerUtils.drawNavMeshPortals(mesh);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws polygons of a NavMesh with specific flags using the debug drawer utilities.\n     * @param mesh NavMesh to draw the polygons with specific flags.\n     * @param flags The flags to filter the polygons to be drawn.\n     * @param col The color to use for the drawn polygons, represented as a number.\n     */\n    public drawNavMeshPolysWithFlags(mesh: NavMesh, flags: number, col: number): void {\n        const primitives = this._debugDrawerUtils.drawNavMeshPolysWithFlags(mesh, flags, col);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     * Draws polygons of a NavMesh with specific reference and color using the debug drawer utilities.\n     * @param mesh NavMesh to draw the polygons with specific reference and color.\n     * @param ref The reference number of the polygons to be drawn.\n     * @param col The color to use for the drawn polygons, represented as a number.\n     */\n    public drawNavMeshPoly(mesh: NavMesh, ref: number, col: number): void {\n        const primitives = this._debugDrawerUtils.drawNavMeshPoly(mesh, ref, col);\n        this.drawPrimitives(primitives);\n    }\n\n    /**\n     *  Get the intermediates from the generator\n     *  @param intermediates - The generator intermediates\n     *  @returns An object containing lists of heightfields, compact heightfields, contour sets\n     */\n    public getIntermediates = (intermediates: GeneratorIntermediates) => {\n        const heightfieldList: RecastHeightfield[] = [];\n        const compactHeightfieldList: RecastCompactHeightfield[] = [];\n        const contourSetList: RecastContourSet[] = [];\n        const polyMeshList: RecastPolyMesh[] = [];\n        const polyMeshDetailList: RecastPolyMeshDetail[] = [];\n\n        if (intermediates) {\n            if (intermediates.type === \"solo\") {\n                if (intermediates.heightfield) {\n                    heightfieldList.push(intermediates.heightfield);\n                }\n\n                if (intermediates.compactHeightfield) {\n                    compactHeightfieldList.push(intermediates.compactHeightfield);\n                }\n\n                if (intermediates.contourSet) {\n                    contourSetList.push(intermediates.contourSet);\n                }\n\n                if (intermediates.polyMesh) {\n                    polyMeshList.push(intermediates.polyMesh);\n                }\n\n                if (intermediates.polyMeshDetail) {\n                    polyMeshDetailList.push(intermediates.polyMeshDetail);\n                }\n            } else if (intermediates.type === \"tiled\") {\n                for (const tile of intermediates.tileIntermediates) {\n                    if (tile.heightfield) {\n                        heightfieldList.push(tile.heightfield);\n                    }\n\n                    if (tile.compactHeightfield) {\n                        compactHeightfieldList.push(tile.compactHeightfield);\n                    }\n\n                    if (tile.contourSet) {\n                        contourSetList.push(tile.contourSet);\n                    }\n\n                    if (tile.polyMesh) {\n                        polyMeshList.push(tile.polyMesh);\n                    }\n\n                    if (tile.polyMeshDetail) {\n                        polyMeshDetailList.push(tile.polyMeshDetail);\n                    }\n                }\n            } else if (intermediates.type === \"tilecache\") {\n                for (const tile of intermediates.tileIntermediates) {\n                    if (tile.heightfield) {\n                        heightfieldList.push(tile.heightfield);\n                    }\n\n                    if (tile.compactHeightfield) {\n                        compactHeightfieldList.push(tile.compactHeightfield);\n                    }\n                }\n            }\n        }\n\n        return {\n            heightfieldList,\n            compactHeightfieldList,\n            contourSetList,\n            polyMeshList,\n            polyMeshDetailList,\n        };\n    };\n\n    /**\n     *  Draw debug information based on the selected option\n     *  @param navMesh - The navigation mesh to draw\n     *  @param intermediates - The generator intermediates containing the data to draw\n     *  @param scene - The scene to draw in\n     *  @param option - The debug drawer option to use\n     *  @remarks This method will reset the debug drawer before drawing.\n     */\n    public draw(navMesh: NavMesh, intermediates: GeneratorIntermediates, scene: Scene, option: DebugLayerOptions) {\n        this.clear();\n\n        const { heightfieldList, compactHeightfieldList, contourSetList, polyMeshList, polyMeshDetailList } = this.getIntermediates(intermediates);\n\n        if (option === DebugLayerOption.HEIGHTFIELD_SOLID) {\n            for (const heightfield of heightfieldList) {\n                this.drawHeightfieldSolid(heightfield);\n            }\n        } else if (option === DebugLayerOption.HEIGHTFIELD_WALKABLE) {\n            for (const heightfield of heightfieldList) {\n                this.drawHeightfieldWalkable(heightfield);\n            }\n        } else if (option === DebugLayerOption.COMPACT_HEIGHTFIELD_SOLID) {\n            for (const compactHeightfield of compactHeightfieldList) {\n                this.drawCompactHeightfieldSolid(compactHeightfield);\n            }\n        } else if (option === DebugLayerOption.COMPACT_HEIGHTFIELD_REGIONS) {\n            for (const compactHeightfield of compactHeightfieldList) {\n                this.drawCompactHeightfieldRegions(compactHeightfield);\n            }\n        } else if (option === DebugLayerOption.COMPACT_HEIGHTFIELD_DISTANCE) {\n            for (const compactHeightfield of compactHeightfieldList) {\n                this.drawCompactHeightfieldDistance(compactHeightfield);\n            }\n        } else if (option === DebugLayerOption.RAW_CONTOURS) {\n            for (const contourSet of contourSetList) {\n                this.drawRawContours(contourSet);\n            }\n        } else if (option === DebugLayerOption.CONTOURS) {\n            for (const contourSet of contourSetList) {\n                this.drawContours(contourSet);\n            }\n        } else if (option === DebugLayerOption.POLY_MESH) {\n            for (const polyMesh of polyMeshList) {\n                this.drawPolyMesh(polyMesh);\n            }\n        } else if (option === DebugLayerOption.POLY_MESH_DETAIL) {\n            for (const polyMeshDetail of polyMeshDetailList) {\n                this.drawPolyMeshDetail(polyMeshDetail);\n            }\n        } else if (option === DebugLayerOption.NAVMESH) {\n            this.drawNavMesh(navMesh);\n        } else if (option === DebugLayerOption.NAVMESH_BV_TREE) {\n            this.drawNavMeshBVTree(navMesh);\n        }\n    }\n\n    private _drawPoints(primitive: DebugDrawerPrimitive): void {\n        if (primitive.vertices.length === 0) {\n            return;\n        }\n\n        const matricesData = new Float32Array(16 * primitive.vertices.length);\n        const colorData = new Float32Array(4 * primitive.vertices.length);\n\n        for (let i = 0; i < primitive.vertices.length; i++) {\n            const [x, y, z, r, g, b, a] = primitive.vertices[i];\n\n            colorData[i * 4] = r;\n            colorData[i * 4 + 1] = g;\n            colorData[i * 4 + 2] = b;\n            colorData[i * 4 + 3] = a;\n\n            const matrix = Matrix.Translation(x, y, z);\n            matrix.copyToArray(matricesData, i * 16);\n        }\n\n        this._pointMesh.thinInstanceSetBuffer(\"matrix\", matricesData, 16);\n        this._pointMesh.thinInstanceSetBuffer(\"color\", colorData, 4);\n\n        this._pointMesh.parent = this.debugDrawerParentNode;\n    }\n\n    private _drawLines(primitive: DebugDrawerPrimitive, instance: Nullable<GreasedLineBaseMesh>): Nullable<GreasedLineBaseMesh> {\n        if (primitive.vertices.length === 0) {\n            return null;\n        }\n\n        const points: number[][] = [];\n        const colors: Color3[] = [];\n\n        for (let i = 0; i < primitive.vertices.length; i += 2) {\n            const [x1, y1, z1, r1, g1, b1] = primitive.vertices[i];\n            const [x2, y2, z2, r2, g2, b2] = primitive.vertices[i + 1];\n\n            points.push([x1, y1, z1, x2, y2, z2]);\n\n            colors.push(new Color3(r1, g1, b1));\n            colors.push(new Color3(r2, g2, b2));\n        }\n\n        const options = { ...this._lineMaterialOptions.greasedLineMeshOptions, points, instance: instance ?? undefined };\n        const materialOptions = { ...this._lineMaterialOptions.greasedLineMaterialOptions, colors };\n\n        const lines = CreateGreasedLine(NavigationDebugger.NAV_MESH_DEBUG_NAME_LINES, options, materialOptions);\n\n        lines.parent = this.debugDrawerParentNode;\n        this.lineMaterials.push(lines.material as StandardMaterial);\n\n        return lines;\n    }\n\n    private _drawTris(primitive: DebugDrawerPrimitive): void {\n        if (primitive.vertices.length === 0) {\n            return;\n        }\n\n        const positions = new Float32Array(primitive.vertices.length * 3);\n        const colors = new Float32Array(primitive.vertices.length * 4);\n\n        for (let i = 0; i < primitive.vertices.length; i++) {\n            const [x, y, z, r, g, b] = primitive.vertices[i];\n            positions[i * 3 + 0] = x;\n            positions[i * 3 + 1] = y;\n            positions[i * 3 + 2] = z;\n\n            colors[i * 4 + 0] = r;\n            colors[i * 4 + 1] = g;\n            colors[i * 4 + 2] = b;\n            colors[i * 4 + 3] = 1;\n        }\n\n        const vertexData = new VertexData();\n\n        vertexData.positions = positions;\n        vertexData.colors = colors;\n\n        const customMesh = new Mesh(NavigationDebugger.NAV_MESH_DEBUG_NAME_TRIS);\n        customMesh.isUnIndexed = true;\n        vertexData.applyToMesh(customMesh);\n\n        customMesh.material = this.triMaterial;\n        customMesh.parent = this.debugDrawerParentNode;\n    }\n\n    private _drawQuads(primitive: DebugDrawerPrimitive): void {\n        if (primitive.vertices.length === 0) {\n            return;\n        }\n\n        const positions: number[] = [];\n        const colors: number[] = [];\n        for (let i = 0; i < primitive.vertices.length; i += 4) {\n            const vertices = [\n                primitive.vertices[i],\n                primitive.vertices[i + 1],\n                primitive.vertices[i + 2],\n                primitive.vertices[i],\n                primitive.vertices[i + 2],\n                primitive.vertices[i + 3],\n            ];\n            for (const [x, y, z, r, g, b] of vertices) {\n                positions.push(x, y, z);\n                colors.push(r, g, b, 1);\n            }\n        }\n\n        const vertexData = new VertexData();\n\n        vertexData.positions = positions;\n        vertexData.colors = colors;\n\n        const customMesh = new Mesh(NavigationDebugger.NAV_MESH_DEBUG_NAME_QUADS);\n        customMesh.isUnIndexed = true;\n        vertexData.applyToMesh(customMesh);\n\n        customMesh.material = this.triMaterial;\n        customMesh.parent = this.debugDrawerParentNode;\n    }\n\n    /**\n     * Merge the debug meshes for better performance\n     */\n    private _joinDebugMeshes() {\n        const debugMeshes = this._scene.meshes.filter((m) => m.name === NavigationDebugger.NAV_MESH_DEBUG_NAME) as Mesh[];\n\n        // only indexed meshes can be merged\n        debugMeshes.forEach((m) => {\n            this._convertUnindexedToIndexed(m);\n        });\n\n        const merged = Mesh.MergeMeshes(debugMeshes, true);\n        if (merged) {\n            merged.name = NavigationDebugger.NAV_MESH_DEBUG_NAME;\n            merged.parent = this.debugDrawerParentNode;\n        }\n    }\n\n    private _convertUnindexedToIndexed(mesh: Mesh): void {\n        const vertexData = VertexData.ExtractFromMesh(mesh);\n        const positions = vertexData.positions;\n\n        if (!positions || positions.length % 9 !== 0) {\n            Logger.Warn(\"Mesh must be fully unindexed with triangles.\");\n            return;\n        }\n\n        const vertexCount = positions.length / 3;\n        const indices = Array.from({ length: vertexCount }, (_, i) => i);\n\n        const newVertexData = new VertexData();\n        newVertexData.positions = positions;\n        newVertexData.indices = indices;\n\n        newVertexData.applyToMesh(mesh, true);\n    }\n}\n","import * as addons from \"addons/index\";\r\n\r\nexport { addons };\r\nexport default addons;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","name","shader","ShaderStore","ShadersStore","msdfVertexShader","ShadersStoreWGSL","msdfPixelShaderWGSL","msdfPixelShader","msdfVertexShaderWGSL","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","extendStatics","b","setPrototypeOf","__proto__","Array","p","__extends","TypeError","String","__","constructor","create","__assign","assign","t","s","i","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","f","y","_","label","sent","trys","ops","g","Iterator","verb","iterator","v","op","pop","push","__spreadArray","to","from","pack","ar","l","slice","concat","SuppressedError","OriginOffsetUniformName","useAerialPerspectiveLut","APPLY_AERIAL_PERSPECTIVE_INTENSITY","APPLY_AERIAL_PERSPECTIVE_RADIANCE_BIAS","SAMPLE_TRANSMITTANCE_LUT","EXCLUDE_RAY_MARCHING_FUNCTIONS","USE_AERIAL_PERSPECTIVE_LUT","MaterialDefines","InverseViewportSizeUniformName","UboArray","size","type","OriginOffsetKm","x","z","material","_atmosphere","_isAerialPerspectiveEnabled","USE_CUSTOM_REFLECTION","diffuseSkyIrradianceLut","CUSTOM_FRAGMENT_BEFORE_FOG","isAerialPerspectiveLutEnabled","aerialPerspectiveIntensity","aerialPerspectiveRadianceBias","doNotSerialize","_pluginManager","_addPlugin","getUniformBuffersNames","_ubos","uniformBuffer","useUbo","getUniforms","atmosphere","ubo","fragment","externalUniforms","getUniformNames","isReadyForSubMesh","isReady","aerialPerspectiveLutRenderTarget","transmittanceLutRenderTarget","transmittanceLut","renderTarget","getActiveTextures","_activeTextures","bindForSubMesh","scene","engine","getEngine","effect","currentEffect","bindUniformBufferToEffect","updateVector3","floatingOriginMode","Vector3ScaleToRef","floatingOriginOffset","Vector3FromFloatsToRef","physicalProperties","planetRadius","width","getRenderWidth","height","getRenderHeight","updateFloat2","setTexture","prepareDefines","defines","lastUseAerialPerspectiveLut","lastApplyAerialPerspectiveIntensity","lastApplyAerialPerspectiveRadianceBias","markAllAsDirty","getSamplers","samplers","getCustomCode","shaderType","directionToLightSnippet","supportsUniformBuffers","atmosphereImportSnippet","CUSTOM_FRAGMENT_DEFINITIONS","CUSTOM_LIGHT0_COLOR","CUSTOM_REFLECTION","MaterialPluginBase","TempRay","Ray","Vector3","Zero","_inverseViewProjectionMatrixWithoutTranslation","Matrix","Identity","_directionToLightRelativeToCameraGeocentricNormal","Up","_cosAngleLightToZenith","_cameraRadius","_clampedCameraRadius","_cameraHeight","_clampedCameraHeight","_cameraPositionGlobal","_clampedCameraPositionGlobal","_cosCameraHorizonAngleFromZenith","_sinCameraAtmosphereHorizonAngleFromNadir","_cameraGeocentricNormal","_cameraForward","Down","_cameraNearPlane","_cameraPosition","_viewport","Vector4","_lastViewMatrix","_lastProjectionMatrix","_inverseViewMatrixWithoutTranslation","_inverseProjectionMatrix","update","camera","planetRadiusWithOffset","atmosphereRadius","directionToLight","originHeight","minZ","copyFrom","getForwardRayToRef","direction","getScene","copyFromFloats","viewMatrix","getViewMatrix","projectionMatrix","getProjectionMatrix","lastViewMatrix","lastProjectionMatrix","equals","setTranslation","ZeroReadOnly","invertToRef","multiplyToRef","cameraPositionGlobal","globalPosition","scaleToRef","normalizeToRef","scaleAndAddToRef","ComputeCosHorizonAngleFromZenith","Math","min","Vector3Dot","lightZenithSinAngle","sqrt","max","normalize","radius","sinHorizonAngleFromNadir","DefaultPeakRayleighScattering","DefaultPeakMieScattering","DefaultPeakMieAbsorption","DefaultPeakOzoneAbsorption","options","onChangedObservable","Observable","_peakRayleighScattering","_peakMieScattering","_peakMieAbsorption","_peakOzoneAbsorption","_planetRadiusWithOffset","_planetRadiusSquared","_atmosphereRadius","_atmosphereRadiusSquared","_horizonDistanceToAtmosphereEdge","_horizonDistanceToAtmosphereEdgeSquared","_rayleighScattering","_mieScattering","_mieAbsorption","_mieExtinction","_ozoneAbsorption","_planetRadius","_planetRadiusOffset","planetRadiusOffset","_atmosphereThickness","atmosphereThickness","_rayleighScatteringScale","rayleighScatteringScale","peakRayleighScattering","_mieScatteringScale","mieScatteringScale","peakMieScattering","_mieAbsorptionScale","mieAbsorptionScale","peakMieAbsorption","_ozoneAbsorptionScale","ozoneAbsorptionScale","peakOzoneAbsorption","_recomputeDimensionalParameters","_recomputeRayleighScattering","_recomputeMieScattering","_recomputeMieAbsorption","_recomputeOzoneAbsorption","notifyObservers","_recomputeMieExtinction","addToRef","MakeTempColor4Like","Number","NaN","TmpColor1","TmpColor2","TmpColor3","TmpColor4","Sample2DRgbaToRef","u","widthPx","heightPx","data","normalizeFunc","Error","expectedLength","Clamp","fractionalTexelX","fractionalTexelY","xLeft","floor","xRight","yBottom","yTop","lowerLeftColor","TexelFetch2DRgbaToRef","upperLeftColor","lowerRightColor","upperRightColor","tX","tY","oneMinusTX","oneMinusTY","w0","w1","w2","w3","clampedTexelX","index","IncludesShadersStore","UvTemp","Color4Temp","_renderTarget","_effectWrapper","_effectRenderer","_isDirty","_isDisposed","_lutData","Uint16Array","textureType","getCaps","textureHalfFloatRender","Constants","TEXTURETYPE_HALF_FLOAT","TEXTURETYPE_UNSIGNED_BYTE","RenderTargetTexture","generateMipMaps","samplingMode","TEXTURE_BILINEAR_SAMPLINGMODE","generateDepthBuffer","gammaSpace","wrapU","TEXTURE_CLAMP_ADDRESSMODE","wrapV","anisotropicFilteringLevel","skipInitialClear","atmosphereUbo","heightParam","isWebGPU","EffectWrapper","vertexShader","fragmentShader","attributeNames","uniformNames","uniformBuffers","useShaderStore","EffectRenderer","indices","positions","environmentTexture","irradianceTexture","environmentIntensity","isRenderTarget","getDiffuseSkyIrradianceToRef","cameraGeocentricNormal","lightIrradiance","additionalDiffuseSkyIrradiance","properties","cosAngleLightToZenith","unitX","unitY","ComputeLutUVToRef","FromHalfFloat","intensity","diffuseSkyIrradianceIntensity","render","effectWrapper","bindFramebuffer","effectRenderer","applyEffectWrapper","saveStates","setViewport","bindBuffers","multiScatteringLutRenderTarget","setFloat","draw","restoreStates","restoreDefaultFramebuffer","readPixels","markDirty","dispose","TransmittanceHorizonRange","Uv","LightColorTemp","DirectionToLightTemp","onUpdatedObservable","Uint8Array","getTransmittedColorToRef","pointRadius","pointGeocentricNormal","lutData","positionDistanceToOrigin","uv","radiusSquared","distanceToHorizon","planetRadiusSquared","discriminant","atmosphereRadiusSquared","distanceToAtmosphereEdge","minDistanceToAtmosphereEdge","maxDistanceToAtmosphereEdge","horizonDistanceToAtmosphereEdge","cosAngleLightToZenithCoordinate","distanceToHorizonCoordinate","weight","SmoothStep","SampleLutToRef","updateLightParameters","light","lightDirection","diffuse","specular","CharCode","MaterialPlugin","UniqueId","lights","_directionToLight","_tempSceneAmbient","Color3","_additionalDiffuseSkyIrradiance","_atmosphereUbo","_minimumMultiScattering","_cameraAtmosphereVariables","AtmospherePerCameraVariables","_lightRadianceAtCamera","_linearLightColor","_atmosphereUniformBufferAsArray","_isEnabled","_aerialPerspectiveLutHasBeenRendered","_hasRenderedMultiScatteringLut","_multiScatteringEffectWrapper","_multiScatteringLutRenderTarget","_aerialPerspectiveLutEffectWrapper","_aerialPerspectiveLutEffectRenderer","_aerialPerspectiveLutRenderTarget","_skyViewLutEffectWrapper","_skyViewLutEffectRenderer","_skyViewLutRenderTarget","_aerialPerspectiveCompositorEffectWrapper","_skyCompositorEffectWrapper","_globeAtmosphereCompositorEffectWrapper","_onBeforeCameraRenderObserver","_onBeforeDrawPhaseObserver","_onAfterRenderingGroupObserver","uniqueId","onAfterUpdateVariablesForCameraObservable","onBeforeLightVariablesUpdateObservable","onBeforeRenderLutsForCameraObservable","onAfterRenderLutsForCameraObservable","depthTexture","_transmittanceLut","_diffuseSkyIrradianceLut","_engine","version","_physicalProperties","AtmospherePhysicalProperties","add","_lights","_exposure","exposure","_isLinearSpaceLight","isLinearSpaceLight","_isLinearSpaceComposition","isLinearSpaceComposition","_applyApproximateTransmittance","applyApproximateTransmittance","_aerialPerspectiveRadianceBias","_aerialPerspectiveTransmittanceScale","aerialPerspectiveTransmittanceScale","_aerialPerspectiveSaturation","aerialPerspectiveSaturation","_aerialPerspectiveIntensity","_diffuseSkyIrradianceDesaturationFactor","diffuseSkyIrradianceDesaturationFactor","_diffuseSkyIrradianceIntensity","_additionalDiffuseSkyIrradianceIntensity","additionalDiffuseSkyIrradianceIntensity","_multiScatteringIntensity","multiScatteringIntensity","_minimumMultiScatteringIntensity","minimumMultiScatteringIntensity","_isSkyViewLutEnabled","isSkyViewLutEnabled","_isAerialPerspectiveLutEnabled","_originHeight","_additionalDiffuseSkyIrradianceColor","additionalDiffuseSkyIrradianceColor","_groundAlbedo","groundAlbedo","set","minimumMultiScatteringColor","_minimumMultiScatteringColor","_skyRenderingGroup","skyRenderingGroup","_aerialPerspectiveRenderingGroup","aerialPerspectiveRenderingGroup","_globeAtmosphereRenderingGroup","globeAtmosphereRenderingGroup","TransmittanceLut","CreateRenderTargetTexture","isDiffuseSkyIrradianceLutEnabled","DiffuseSkyIrradianceLut","skyViewLutRenderTarget","onBeforeCameraRenderObservable","_updatePerCameraVariables","_renderLutsForCamera","renderingManager","getRenderingGroup","onBeforeDrawPhaseObservable","_empty","onAfterRenderingGroupObservable","group","groupId","renderingGroupId","drawSkyCompositor","drawAerialPerspectiveCompositor","drawGlobeAtmosphereCompositor","onDisposeObservable","addOnce","removeExternalData","addExternalData","UnregisterMaterialPlugin","RegisterMaterialPlugin","getClassName","AtmospherePBRMaterialPlugin","IsSupported","_badOS","minimumScatteringColor","newValue","_disposeSkyCompositor","_disposeGlobeAtmosphereCompositor","coordinatesMode","TEXTURE_EQUIRECTANGULAR_MODE","CreateSkyViewEffectWrapper","_disposeAerialPerspectiveCompositor","layers","CreateAerialPerspectiveEffectWrapper","hasDefineChanged","UniformBuffer","addUniform","remove","isEnabled","setEnabled","enabled","_createMultiScatteringEffectWrapper","BlackReadOnly","samplerNames","_drawMultiScatteringLut","DrawEffect","clampedCameraRadius","CreateAerialPerspectiveCompositorEffectWrapper","skyViewLut","multiScatteringLut","aerialPerspectiveLut","ALPHA_PREMULTIPLIED_PORTERDUFF","ALPHA_ONEONE","ALWAYS","CreateSkyCompositorEffectWrapper","EQUAL","CreateGlobeAtmosphereCompositorEffectWrapper","scaleInPlace","cameraAtmosphereVariables","toGammaSpaceToRef","ambientColor","updateUniformBuffer","renderGlobalLuts","isDirty","_drawSkyViewLut","_drawAerialPerspectiveLut","_clearAerialPerspectiveLut","bindToEffect","bindUniformBuffer","rayleighScattering","updateFloat","mieScattering","mieAbsorption","mieExtinction","ozoneAbsorption","horizonDistanceToAtmosphereEdgeSquared","updateMatrix","inverseViewProjectionMatrixWithoutTranslation","directionToLightRelativeToCameraGeocentricNormal","cameraRadius","updateColor3","getScaledIntensity","clampedCameraPositionGlobal","cameraForward","clampedCameraHeight","cameraPosition","cosCameraHorizonAngleFromZenith","updateVector4","viewport","cameraHeight","cameraNearPlane","sinCameraAtmosphereHorizonAngleFromNadir","layer","clearColor","clear","CreateEffectWrapper","defineNames","map","defineName","caps","textureFloatRender","TEXTURETYPE_FLOAT","rtOptions","generateStencilBuffer","format","TEXTUREFORMAT_RGBA","drawCallback","depth","alphaMode","depthTest","depthWrite","depthFunction","ALPHA_DISABLE","LEQUAL","currentDepthWrite","getDepthWrite","setDepthWrite","currentDepthFunction","getDepthFunction","setDepthFunction","currentAlphaMode","getAlphaMode","setAlphaMode","textures","hasDepthTexture","BabylonUnitsToPixels","RenderOrderFunc","defaultRenderOrder","subMeshA","subMeshB","meshA","getMesh","meshB","meshIsHtmlMeshA","meshIsHtmlMeshB","absolutePosition","parentContainerId","_containerId","enableOverlayRender","defaultOpaqueRenderOrder","RenderingGroup","PainterSortCompare","defaultAlphaTestRenderOrder","defaultTransparentRenderOrder","defaultTransparentSortCompare","_cache","cameraData","fov","position","style","htmlMeshData","WeakMap","_width","_height","_heightHalf","_temp","scaleTransform","rotationTransform","Quaternion","positionTransform","objectMatrix","cameraWorldMatrix","cameraRotationMatrix","cameraWorldMatrixAsArray","_lastDevicePixelRatio","window","devicePixelRatio","_cameraMatrixUpdated","_previousCanvasDocumentPosition","top","left","_renderObserver","_onCameraMatrixChanged","_cameraWorldMatrix","getWorldMatrix","document","_init","_overlayElements","container","_inSceneElements","parentContainer","getElementById","inSceneContainerId","_createRenderLayerElements","insertBefore","firstChild","overlayContainerId","zIndex","getRenderingCanvas","pointerEvents","projectionObs","matrixObs","clientRect","getRenderingCanvasClientRect","_setSize","onResizeObservable","observeCamera","activeCamera","onProjectionMatrixChangedObservable","onViewMatrixChangedObservable","onActiveCameraChanged","opaqueRenderOrder","alphaTestRenderOrder","transparentRenderOrder","setRenderingOrder","onBeforeRenderObservable","_render","containerId","existingContainer","createElement","id","domElement","overflow","cameraElement","webkitTransformStyle","transformStyle","appendChild","_getSize","dom","_getCameraCssMatrix","matrix","elements","m","_epsilon","_getHtmlContentCssMatrix","useRightHandedSystem","_getTransformationMatrix","htmlMesh","objectWorldMatrix","widthScaleFactor","heightScaleFactor","sourceWidth","sourceHeight","scaledAndTranslatedObjectMatrix","decompose","ComposeToRef","getAbsolutePosition","setRowFromFloats","HtmlMeshRenderer","PROJECTION_SCALE_FACTOR","multiplyAtIndex","_renderHtmlMesh","element","firstElementChild","_isCanvasOverlay","parentNode","requiresUpdate","_updateBaseScaleFactor","billboardMode","TransformNode","BILLBOARDMODE_NONE","webkitTransform","transform","_markAsUpdated","needsUpdate","_updateContainerPositionIfNeeded","Logger","Log","meshesNeedingUpdate","meshes","filter","mesh","source","mode","Camera","PERSPECTIVE_CAMERA","el","webkitPerspective","perspective","parent","computeWorldMatrix","cameraMatrixWorld","getRotationMatrix","transposeToRef","cameraMatrixWorldAsArray","copyToArray","FromArrayToRef","screenWidth","screenHeight","htmlMeshAspectRatio","setContentSizePx","canvasRect","scrollTop","scrollY","scrollLeft","scrollX","canvasDocumentTop","canvasDocumentLeft","containerParent","offsetParent","parentRect","getBoundingClientRect","parentDocumentTop","parentDocumentLeft","ancestorMarginsAndPadding","_getAncestorMarginsAndPadding","bodyStyle","getComputedStyle","bodyMarginTop","parseInt","marginTop","bodyMarginLeft","marginLeft","paddingTop","paddingLeft","Warn","abs","documentElement","CaptureRequestQueue","PendingRequestCallbacks","Map","UnmatchedReleaseRequests","CurrentOwner","requestRelease","requestId","DebugLog","CancelRequest","delete","includes","TransferPointerEventsOwnership","removed","newOwnerId","NextCaptureRequest","DoRelease","DoCapture","release","capture","shift","message","Tools","performance","now","LocalScene","CaptureOnEnterCount","MeshToBehaviorMap","StartCaptureOnEnter","addEventListener","OnPointerMove","DoStopCaptureOnEnter","removeEventListener","StopCaptureOnEnter","evt","pickedMesh","touches","clientX","clientY","pointerScreenX","pointerScreenY","pickResult","pick","pointerCaptureBehavior","_captureOnPointerEnter","hit","capturingIdAsInt","capturePointerEvents","_captureCallback","_releaseCallback","captureOnPointerEnter","_attachedMesh","init","attach","attachedMesh","detach","releasePointerEvents","toString","captureCallback","releaseCallback","RemoveUnmatchedRequest","EnqueueCaptureRequest","FitStrategy","CONTAIN","wrapElement","sizingElement","display","justifyContent","alignItems","scalingElement","visibility","updateSize","offsetWidth","offsetHeight","childWidth","childHeight","scale","COVER","STRETCH","NONE","isCanvasOverlay","fitStrategy","_enabled","_ready","_requiresUpdate","_inverseScaleMatrix","_pointerEventCaptureBehavior","_sourceWidth","_sourceHeight","_fitStrategy","_createMask","_element","_createElement","PointerEventsCaptureBehavior","bind","addBehavior","setContent","_setAsReady","scaling","setAll","_updateScaleIfNecessary","_doSetEnabled","ready","_worldMatrixUpdateObserver","onAfterWorldMatrixUpdateObservable","_setElementzIndex","bakeTransformIntoVertices","scaleX","scaleY","scaleMatrix","Scaling","CreatePlaneVertexData","applyToMesh","checkCollisions","depthMask","StandardMaterial","backFaceCulling","disableColorWrite","disableLighting","freeze","getElementsByTagName","div","backgroundColor","backfaceVisibility","Mesh","_Recast","definitionData","textureUrl","_chars","_kernings","_font","JSON","parse","pages","chars","forEach","char","kernings","kerning","submap","first","second","amount","_charsRegex","RegExp","c","replace","join","_updateFallbacks","info","page","texture","Texture","noMipmap","invertY","has","SPACE","xoffset","yoffset","xadvance","chnl","TOFU","_getChar","charCode","_getKerning","_unsupportedChars","text","DefaultParagraphOptions","maxWidth","Infinity","lineHeight","letterSpacing","tabSize","whiteSpace","textAlign","translate","fontAsset","customLayoutEngine","_computeMetrics","paragraph","lines","glyphs","common","collapsed","_collapse","trimmed","_breakLines","line","trim","_wrap","anchor","glyph","flatMap","split","repeat","lineOffset","lastChar","currentLine","currentGlyphs","currentCursor","currentWidth","start","end","pushCurrentLine","charCodeAt","charWidth","newWidth","cursorProgress","nextPosition","shouldBreak","shaderLanguage","font","_useVAO","_vertexBuffers","_charMatrices","_charUvs","_baseLine","_scalingMatrix","ThinMatrix","_fontScaleMatrix","_offsetMatrix","_translationMatrix","_baseMatrix","_scaledMatrix","_localMatrix","_finalMatrix","_lineMatrix","_parentWorldMatrix","color","strokeColor","strokeInsetWidth","strokeOutsetWidth","thicknessControl","_parent","_transformMatrix","isBillboard","isBillboardScreenProjected","ignoreDepthBuffer","_shaderLanguage","vertexArrayObject","disableVertexArrayObjects","spriteData","Float32Array","_spriteBuffer","Buffer","createVertexBuffer","_resizeBuffers","capacity","_worldBuffer","_uvBuffer","_setShaders","vertex","_drawWrapperBase","DrawWrapper","drawContext","useInstancing","createEffect","vertexSource","fragmentSource","_refCount","addParagraph","worldMatrix","SdfTextParagraph","fontScale","texWidth","scaleW","texHeight","scaleH","worldMatrixToUse","TranslationMatrixToRef","ScalingMatrixToRef","charsUvsBase","matricesBase","MultiplyMatricesToRef","CopyMatrixToArray","drawWrapper","setState","enableEffect","setDepthBuffer","CopyMatrixToRef","IdentityMatrixToRef","setInt","setMatrix","transformMatrix","setDirectColor4","instanceCount","getBuffer","_vertexArrayObject","recordVertexArrayObject","bindVertexArrayObject","ALPHA_COMBINE","drawArraysType","MATERIAL_TriangleStripDrawMode","unbindInstanceAttributes","releaseVertexArrayObject","CreateTextRendererAsync","instancedArrays","_features","supportSpriteInstancing","textRenderer","TextRenderer","GetRecast","_InitPromise","InitRecast","localOptions","url","instance","baseUrl","importMap","imports","script","textContent","stringify","_LoadScriptModuleAsync","ImportRecast","core","generators","CreateDefaultTileCacheMeshProcess","offMeshConnections","area","flags","navMeshCreateParams","polyAreas","polyFlags","polyCount","setOffMeshConnections","WaitForFullTileCacheUpdate","navMesh","tileCache","upToDate","DefaultMaxObstacles","CreateSoloNavMeshConfig","parameters","ToSoloNavMeshGeneratorConfig","CreateTiledNavMeshConfig","tileSize","CreateTileCacheNavMeshConfig","cfg","expectedLayersPerTile","maxObstacles","tileCacheMeshProcess","config","fromEntries","entries","ToCrowdAgentParams","agentParams","plugin","maxAgents","maxAgentRadius","_transforms","_agents","_reachRadii","_agentDestinationArmed","_agentDestination","_onBeforeAnimationsObserver","onReachTargetObservable","_navigationPlugin","_recastCrowd","_scene","onBeforeAnimationsObservable","getDeltaTime","timeFactor","addAgent","pos","agent","agentIndex","reachRadius","getAgentPosition","agentPos","getAgent","getAgentPositionToRef","getAgentVelocity","agentVel","velocity","getAgentVelocityToRef","getAgentNextTargetPath","pathTargetPos","nextTargetInPath","getAgentNextTargetPathToRef","getAgentState","state","overOffmeshConnection","overOffMeshConnection","agentGoto","destination","requestMoveTarget","item","indexOf","agentTeleport","teleport","updateAgentParameters","maxAcceleration","maxSpeed","collisionQueryRange","pathOptimizationRange","separationWeight","updateParameters","removeAgent","splice","getAgents","deltaTime","Epsilon","timeStep","getTimeStep","maxStepCount","getMaximumSubStepCount","iterationCount","agentPosition","dx","dz","groundY","ceilingY","distanceXZSquared","setDefaultQueryExtent","extent","getDefaultQueryExtent","getDefaultQueryExtentToRef","getCorners","corners","destroy","ConvertNavPathPoints","navPath","success","pointCount","path","pt","ComputePathError","START_NEAREST_POLY_FAILED","END_NEAREST_POLY_FAILED","FIND_PATH_FAILED","NO_POLYGON_PATH_FOUND","NO_CLOSEST_POINT_ON_LAST_POLYGON_FOUND","_DELTA","_MOVE_TARGET","ComputeSmoothPath","navmeshQuery","navMeshQuery","recast","defaultFilter","halfExtents","defaultQueryHalfExtents","maxSmoothPathPoints","maxPathPolys","stepSize","slop","startNearestPolyResult","findNearestPoly","error","status","endNearestPolyResult","startRef","nearestRef","endRef","findPathResult","findPath","polys","lastPoly","closestEnd","lastPolyClosestPointResult","closestPointOnPoly","closestPoint","iterPos","targetPos","getHeapView","smoothPath","clone","steerTarget","getSteerTarget","isEndOfPath","steerPosFlag","Detour","DT_STRAIGHTPATH_END","isOffMeshConnection","DT_STRAIGHTPATH_OFFMESH_CONNECTION","steerPos","delta","subtract","len","dot","moveTarget","addInPlace","moveAlongSurface","maxVisitedSize","resultPosition","fixupCorridor","visited","fixupShortcuts","polyHeightResult","getPolyHeight","inRange","offMeshConRef","steerPosRef","prevPolyRef","polyRef","npos","offMeshConnectionPolyEndPoints","getOffMeshConnectionPolyEndPoints","endPositionPolyHeight","ComputeSmoothPathImpl","minTargetDist","pathPolys","straightPath","findStraightPath","maxStraightPathPoints","outPoints","straightPathCount","point","ns","straightPathFlags","straightPathRefs","points","h","dy","maxPath","visitedPolyRefs","furthestPath","furthestVisited","found","j","req","orig","nneis","neis","tileAndPoly","getTileAndPolyByRef","poly","tile","k","firstLink","DT_NULL_LINK","links","link","ref","cut","GetPositionsAndIndices","tri","offset","meshIndices","doNotReverseIndices","getIndices","GetReversedIndices","meshPositions","getVerticesData","VertexBuffer","PositionKind","worldMatrices","hasThinInstances","thinMatrices","thinInstanceGetWorldMatrices","instanceIndex","tmpMatrix","transformed","matrixIndex","wm","TransformCoordinatesToRef","Uint32Array","meshOrIndices","CreateDebugNavMesh","getNavMeshPositionsAndIndices","vertexData","VertexData","GenerateNavMesh","needsTileCache","needsTiledNavMesh","generateTileCache","keepIntermediates","generateTiledNavMesh","generateSoloNavMesh","intermediates","NavMeshQuery","InjectGenerators","navigationPlugin","createNavMeshImpl","createNavMeshAsyncImpl","recastInjection","_maximumSubStepCount","_timeStep","_timeFactor","bjsRECAST","isSupported","setTimeStep","_navMeshQuery","_intermediates","_tileCache","newTimeStep","setMaximumSubStepCount","newStepCount","createNavMesh","_preprocessParameters","_processNavMeshResult","createNavMeshAsync","createDebugNavMesh","getClosestPoint","ret","findClosestPoint","getClosestPointToRef","getRandomPointAround","maxRadius","findRandomPointAroundCircle","randomPoint","getRandomPointAroundToRef","moveAlong","moveAlongToRef","computePath","computePathSmooth","createCrowd","crowd","RecastJSCrowd","_crowd","buildFromNavmeshData","importNavMesh","getNavmeshData","exportNavMesh","buildFromTileCacheData","tileCacheData","importTileCache","getTileCacheData","exportTileCache","addCylinderObstacle","doNotWaitForCacheUpdate","obstacleResult","obstacle","addBoxObstacle","angle","removeObstacle","getRandomSeed","setRandomSeed","seed","raycast","nearestStartPoly","raycastResult","TmpVectors","distanceToHitBorder","Distance","hitPoint","multiplyByFloats","moveAlongWithVelocity","walkableSlopeAngle","CreateNavigationPluginAsync","RecastNavigationJSPluginV2","GetChaikinSmoothPath","iterations","smoothed","p0","p1","GetLShapedPath","navSegment","p01","pointB","x1","y1","x2","y2","pointA","BuildFromNavmeshData","BuildFromTileCacheData","DebugLayerOption","HEIGHTFIELD_SOLID","HEIGHTFIELD_WALKABLE","COMPACT_HEIGHTFIELD_SOLID","COMPACT_HEIGHTFIELD_REGIONS","COMPACT_HEIGHTFIELD_DISTANCE","RAW_CONTOURS","CONTOURS","POLY_MESH","POLY_MESH_DETAIL","NAVMESH","NAVMESH_BV_TREE","lineMaterials","getIntermediates","heightfieldList","compactHeightfieldList","contourSetList","polyMeshList","polyMeshDetailList","heightfield","compactHeightfield","contourSet","polyMesh","polyMeshDetail","tileIntermediates","_debugDrawerUtils","_primitiveTypes","primitiveTypes","debugDrawerParentNode","node","materials","triMaterial","specularColor","Black","alpha","pointMaterial","lineMaterialOptions","_lineMaterialOptions","greasedLineMaterialOptions","sizeAttenuation","greasedLineMeshOptions","_pointMesh","CreateBox","NavigationDebugger","NAV_MESH_DEBUG_NAME_POINTS","getChildMeshes","drawPrimitives","primitives","linesInstance","primitive","_drawPoints","_drawLines","_drawTris","_drawQuads","updateLazy","joinMeshes","_joinDebugMeshes","drawHeightfieldSolid","hf","drawHeightfieldWalkable","drawCompactHeightfieldSolid","chf","drawCompactHeightfieldRegions","drawCompactHeightfieldDistance","drawHeightfieldLayer","idx","drawHeightfieldLayers","lset","drawRegionConnections","cset","drawRawContours","drawContours","drawPolyMesh","drawPolyMeshDetail","dmesh","drawNavMesh","drawNavMeshWithClosedList","query","drawNavMeshNodes","drawNavMeshBVTree","drawNavMeshPortals","drawNavMeshPolysWithFlags","col","drawNavMeshPoly","option","vertices","matricesData","colorData","Translation","thinInstanceSetBuffer","colors","z1","r1","g1","b1","z2","r2","g2","b2","materialOptions","CreateGreasedLine","NAV_MESH_DEBUG_NAME_LINES","customMesh","NAV_MESH_DEBUG_NAME_TRIS","isUnIndexed","NAV_MESH_DEBUG_NAME_QUADS","debugMeshes","NAV_MESH_DEBUG_NAME","_convertUnindexedToIndexed","merged","MergeMeshes","ExtractFromMesh","vertexCount","newVertexData"],"ignoreList":[],"sourceRoot":""}